<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">ClockTimeModule</string>
        <string name="Source"><![CDATA[local module = {}

module.ClockTimePaused = false

module.ONE_HOUR = 1
module.ONE_MINUTE = module.ONE_HOUR / 60

return module
]]></string>
      </Properties>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="2">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Script" referent="3">
      <Properties>
        <string name="Name">ClockTimeServer</string>
        <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local ClockTimeModule = require(ReplicatedStorage:WaitForChild("ClockTimeModule"))

-- Begin at sunset/moonrise.
local SIX_OCLOCK_PM = 18
game.Lighting.ClockTime = SIX_OCLOCK_PM

-- Increment the game clock by one minute for every second (approximately) that goes by.
while true do
	task.wait(0.1)
	if not ClockTimeModule.ClockTimePaused then
		game.Lighting.ClockTime += ClockTimeModule.ONE_MINUTE / 10
	end
end
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="4">
      <Properties>
        <string name="Name">ClockTimeServerEvents</string>
        <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local ClockTimeModule = require(ReplicatedStorage:WaitForChild("ClockTimeModule"))

local event = Instance.new("RemoteEvent")
event.Name = "ClockTimePauseToggleEvent"
event.OnServerEvent:Connect(function(player)
	ClockTimeModule.ClockTimePaused = not ClockTimeModule.ClockTimePaused
end)
event.Parent = ReplicatedStorage

local event = Instance.new("RemoteEvent")
event.Name = "ClockTimeAddHourEvent"
event.OnServerEvent:Connect(function(player)
	local time = game.Lighting.ClockTime + ClockTimeModule.ONE_HOUR
	if time > 24 then
		time -= 24
	end
	game.Lighting.ClockTime = time
end)
event.Parent = ReplicatedStorage

local event = Instance.new("RemoteEvent")
event.Name = "ClockTimeSubtractHourEvent"
event.OnServerEvent:Connect(function(player)
	local time = game.Lighting.ClockTime - ClockTimeModule.ONE_HOUR
	if time < 0 then
		time += 24
	end
	game.Lighting.ClockTime = time
end)
event.Parent = ReplicatedStorage

local event = Instance.new("RemoteEvent")
event.Name = "ClockTimeAddMinuteEvent"
event.OnServerEvent:Connect(function(player)
	local time = game.Lighting.ClockTime + ClockTimeModule.ONE_MINUTE
	if time > 24 then
		time -= 24
	end
	game.Lighting.ClockTime = time
end)
event.Parent = ReplicatedStorage
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="5">
      <Properties>
        <string name="Name">CreatorPrivileges</string>
        <string name="Source"><![CDATA[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local StarterPack = game:GetService("StarterPack")

local WeaponUpgrades = require(ServerScriptService.WeaponUpgrades)

Players.PlayerAdded:Connect(function(player)
	if player.UserId == game.CreatorId then
		print("Creator Privileges In Effect!")
		local clone
		for _, weapon in ipairs(StarterPack:GetChildren()) do
			print(weapon.Name)
			if weapon.Name == "Crossbow" then
				WeaponUpgrades.upgradeCrossbow(weapon)
			elseif weapon.Name == "Pistol" then
				WeaponUpgrades.upgradePistol(weapon)
			elseif weapon.Name == "Sniper Rifle" then
				WeaponUpgrades.upgradeSniperRifle(weapon)
			end
		end
		for _, weapon in ipairs(ReplicatedStorage.Weapons:GetChildren()) do
			if not StarterPack:FindFirstChild(weapon.Name) then
				print(weapon.Name)
				clone = weapon:Clone()
				if weapon.Name == "Grenade Launcher" then
					WeaponUpgrades.upgradeGrenadeLauncher(clone)
				end
				clone.Parent = StarterPack
			end
		end
	end
end)
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="6">
      <Properties>
        <string name="Name">LeaderboardServerEvents</string>
        <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local StarterPack = game:GetService("StarterPack")

local PlayerPoints = game:GetService("DataStoreService"):GetDataStore("PlayerPoints")
local Upgrades = game:GetService("DataStoreService"):GetDataStore("Upgrades")

local LevelChangedEvent = ReplicatedStorage:WaitForChild("LevelChangedEvent")
local ZombieKilledEvent = ReplicatedStorage:WaitForChild("ZombieKilledEvent")
local SoldierKilledEvent = ReplicatedStorage:WaitForChild("SoldierKilledEvent")
local WindowShatteredEvent = ReplicatedStorage:WaitForChild("WindowShatteredEvent")

local WeaponUpgrades = require(ServerScriptService.WeaponUpgrades)

local STARTING_POINTS = 0
local STARTING_LEVEL = 1

local ZOMBIE_KILLED_POINTS = 1
local SOLDIER_KILLED_POINTS = -10
local WINDOW_SHATTERED_POINTS = 1

game.Players.CharacterAutoLoads = false

local function addWeapon(player, weapon)
	if player.Character and not player.Character:FindFirstChild(weapon.Name)  then
		if not player.Backpack:FindFirstChild(weapon.Name) then
			local clone = weapon:Clone()
			clone.Parent = player.Backpack
		end
	end
end

local function onPointsChanged(player, newPointsValue, level)
	if newPointsValue < 20 then
		level.Value = 1
	end
	if newPointsValue >= 20 then
		if level.Value < 2 then
			level.Value = 2
		end
	end
	if newPointsValue >= 40 then
		if level.Value < 3 then
			level.Value = 3
		end
	end
	if newPointsValue >= 80 then
		if level.Value < 4 then
			level.Value = 4
		end
	end
	if newPointsValue >= 320 then
		if level.Value < 5 then
			level.Value = 5
		end
	end
end

local function onLevelChanged(player, newLevelValue)
	if newLevelValue >= 2 then
		local weapon = ReplicatedStorage.Weapons["Grenade Launcher"]
		addWeapon(player, weapon)
	end
	if newLevelValue >= 3 then
		local weapon = ReplicatedStorage.Weapons["Automatic Rifle"]
		addWeapon(player, weapon)
	end
	if newLevelValue >= 4 then
		local weapon = ReplicatedStorage.Weapons["Rocket Launcher"]
		addWeapon(player, weapon)
	end
	if newLevelValue >= 5 then
		local weapon = ReplicatedStorage.Weapons["Railgun"]
		addWeapon(player, weapon)
	end
end

local function setupLeaderboard(player)
	local folder = Instance.new("Folder")
	local points = Instance.new("IntValue")
	local level = Instance.new("IntValue")
	points.Value = STARTING_POINTS
	level.Value = STARTING_LEVEL
	folder.Name = "leaderstats"
	folder.Parent = player
	points.Name = "Points"
	points.Changed:Connect(function(newPointsValue)
		onPointsChanged(player, newPointsValue, level)
	end)
	points.Parent = folder
	level.Name = "Level"
	level.Changed:Connect(function(newLevelValue)
		onLevelChanged(player, newLevelValue)
	end)
	level.Parent = folder
	local success, savedPlayerPoints = pcall(function()
		return PlayerPoints:GetAsync(player.UserId)
	end)
	if success then
		if savedPlayerPoints then
			points.Value = savedPlayerPoints
		else
			points.Value = STARTING_POINTS
		end
	end
end

local function setupWeaponUpgrades(player)
	local success, savedUpgrades = pcall(function()
		return Upgrades:GetAsync(player.UserId)
	end)
	if success then
		if savedUpgrades then
			for _, toolName in ipairs(savedUpgrades) do
				WeaponUpgrades.upgradeTool(player, toolName)
			end
		end
	end
end

game.Players.PlayerAdded:Connect(function(player)
	player.CharacterAdded:Connect(function(character)
		local humanoid = character:WaitForChild("Humanoid")
		humanoid.Died:Connect(function()
			player:LoadCharacter()
			player.leaderstats.Points.Value = STARTING_POINTS
		end)
	end)
	player:LoadCharacter()
	setupLeaderboard(player)
	setupWeaponUpgrades(player)
end)

game.Players.PlayerRemoving:Connect(function(player)
	local success, errorMessage = pcall(function()
		PlayerPoints:SetAsync(player.UserId, player.leaderstats.Points.Value)
	end)
	if not success then
		warn(errorMessage)
	end
	local success, errorMessage = pcall(function()
		Upgrades:SetAsync(player.UserId, WeaponUpgrades.getUpgrades())
	end)
	if not success then
		warn(errorMessage)
	end
end)

ZombieKilledEvent.Event:Connect(function(player)
	player.leaderstats.Points.Value += ZOMBIE_KILLED_POINTS
end)

SoldierKilledEvent.Event:Connect(function(player)
	player.leaderstats.Points.Value += SOLDIER_KILLED_POINTS
end)

WindowShatteredEvent.Event:Connect(function(player)
	player.leaderstats.Points.Value += WINDOW_SHATTERED_POINTS
end)

local event = Instance.new("RemoteEvent")
event.Name = "ResetEvent"
event.OnServerEvent:Connect(function(player)
	player.leaderstats.Points.Value = STARTING_POINTS
	WeaponUpgrades.reset()
	player.Character.Humanoid.Health = 0
end)
event.Parent = ReplicatedStorage
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="7">
      <Properties>
        <string name="Name">ProximityPromptActions</string>
        <string name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local WeaponUpgrades = require(ServerScriptService.WeaponUpgrades)

local module = {}

local function cloneWeaponToBackpack(toolName, player)
	if not player.Character:FindFirstChild(toolName) and not player.Backpack:FindFirstChild(toolName) then
		local clone = ReplicatedStorage.Weapons[toolName]:Clone()
		clone.Parent = player.Backpack
	end
end

function module.promptTriggeredActions(promptObject, player)
	local toolName = promptObject.Parent.Parent.Name
	WeaponUpgrades.upgradeTool(player, toolName)
	promptObject.Enabled = false
end

return module
]]></string>
      </Properties>
    </Item>
    <Item class="Script" referent="8">
      <Properties>
        <string name="Name">ProximityPromptEvents</string>
        <string name="Source"><![CDATA[local ProximityPromptService = game:GetService("ProximityPromptService")
local ServerScriptService = game:GetService("ServerScriptService")

local ProximityPromptActions = require(ServerScriptService.ProximityPromptActions)

ProximityPromptService.PromptTriggered:Connect(function(promptObject, player)
	ProximityPromptActions.promptTriggeredActions(promptObject, player)
end)

--ProximityPromptService.PromptButtonHoldBegan:Connect(function(promptObject, player)
--	ProximityPromptActions.promptButtonHoldBeganActions(promptObject, player)
--end)

--ProximityPromptService.PromptButtonHoldEnded:Connect(function(promptObject, player)
--	ProximityPromptActions.promptButtonHoldEndedActions(promptObject, player)
--end)
]]></string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="9">
      <Properties>
        <string name="Name">WeaponUpgrades</string>
        <string name="Source"><![CDATA[local ServerScriptService = game:GetService("ServerScriptService")

local module = {}

local upgrades = {}

function module.reset()
	upgrades = {}
end

function module.upgradeCrossbow(weapon)
	weapon.Configuration.HasScope.Value = true
	weapon.Configuration.ZoomFactor.Value = 5
end

function module.upgradeGrenadeLauncher(weapon)
	weapon.Configuration.BulletSpeed.Value *= 2
end

function module.upgradePistol(weapon)
	weapon.Configuration.HitDamage.Value = 35 -- Upgrade from 20.
end

function module.upgradeSniperRifle(weapon)
	weapon.Configuration.HasScope.Value = true
	weapon.Configuration.ZoomFactor.Value = 10
end

function module.getWeapon(player, toolName)
	return player.Character:FindFirstChild(toolName) or player.Backpack:FindFirstChild(toolName)
end

function module.getUpgrades()
	return upgrades
end

function module.upgradeTool(player, toolName)
	local weapon = module.getWeapon(player, toolName)
	if weapon then
		table.insert(upgrades, toolName)
		local originalParent = weapon.Parent
		weapon.Parent = player.Backpack
		if toolName == "Crossbow" then
			module.upgradeCrossbow(weapon)
		elseif toolName == "Grenade Launcher" then
			module.upgradeGrenadeLauncher(weapon)
		elseif toolName == "Pistol" then
			module.upgradePistol(weapon)
		elseif toolName == "Sniper Rifle" then
			module.upgradeSniperRifle(weapon)
		end
		weapon.Parent = originalParent
	end
end

return module
]]></string>
      </Properties>
    </Item>
    <Item class="Folder" referent="10">
      <Properties>
        <string name="Name">WeaponsSystem</string>
      </Properties>
      <Item class="LocalScript" referent="11">
        <Properties>
          <string name="Name">ClientWeaponsScript</string>
          <string name="Source">local ReplicatedStorage = game:GetService("ReplicatedStorage")

local playerChildAddedConnection
local replicatedStorageChildAddedConnection
local clientWeaponsScript
local weaponsSystemFolder

local function setupWeaponsSystem()
	local WeaponsSystem = require(weaponsSystemFolder.WeaponsSystem)
	if not WeaponsSystem.doingSetup and not WeaponsSystem.didSetup then
		WeaponsSystem.setup()
	end
end

local function onReplicatedStorageChildAdded(child)
	if child.Name == "WeaponsSystem" then
		setupWeaponsSystem()
		replicatedStorageChildAddedConnection:Disconnect()
	end
end

local function onPlayerChildAdded(child)
	if child.Name == "PlayerScripts" then
		clientWeaponsScript.Parent = child
		playerChildAddedConnection:Disconnect()
	end
end

if script.Parent.Name ~= "PlayerScripts" then
	clientWeaponsScript = script:Clone()
	local PlayerScripts = script.Parent.Parent:FindFirstChild("PlayerScripts")
	
	if PlayerScripts ~= nil then
		clientWeaponsScript.Parent = PlayerScripts
	else
		playerChildAddedConnection = script.Parent.Parent.ChildAdded:Connect(onPlayerChildAdded)
	end
else
	weaponsSystemFolder = ReplicatedStorage:FindFirstChild("WeaponsSystem")
	if weaponsSystemFolder ~= nil then
		setupWeaponsSystem()
	else
		replicatedStorageChildAddedConnection = ReplicatedStorage.ChildAdded:Connect(onReplicatedStorageChildAdded)
	end
end</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="12">
        <Properties>
          <string name="Name">Libraries</string>
        </Properties>
        <Item class="ModuleScript" referent="13">
          <Properties>
            <string name="Name">BaseWeapon</string>
            <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent
local AnimationsFolder = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("Animations")

local localRandom = Random.new()

local BaseWeapon = {}
BaseWeapon.__index = BaseWeapon

BaseWeapon.CanAimDownSights = false
BaseWeapon.CanBeReloaded = false
BaseWeapon.CanBeFired = false
BaseWeapon.CanHit = false

function BaseWeapon.new(weaponsSystem, instance)
	assert(instance, "BaseWeapon.new() requires a valid Instance to be attached to.")

	local self = setmetatable({}, BaseWeapon)
	self.connections = {}
	self.descendants = {}
	self.descendantsRegistered = false
	self.optionalDescendantNames = {}
	self.weaponsSystem = weaponsSystem
	self.instance = instance
	self.animController = nil
	self.player = nil
	self.enabled = false
	self.equipped = false
	self.activated = false
	self.nextShotId = 1
	self.activeRenderStepName = nil
	self.curReloadSound = nil

	self.animTracks = {}
	self.sounds = {}
	self.configValues = {}
	self.trackedConfigurations = {}

	self.ammoInWeaponValue = nil

	self.reloading = false
	self.canReload = true

	self:registerDescendants()
	self.connections.descendantAdded = self.instance.DescendantAdded:Connect(function(descendant)
		self:onDescendantAdded(descendant)
	end)

	return self
end

function BaseWeapon:doInitialSetup()
	local selfClass = getmetatable(self)
	self.instanceIsTool = self.instance:IsA("Tool")

	-- Set up child added/removed
	self.connections.childAdded = self.instance.ChildAdded:Connect(function(child)
		self:onChildAdded(child)
	end)
	self.connections.childRemoved = self.instance.ChildRemoved:Connect(function(child)
		self:onChildRemoved(child)
	end)
	for _, child in pairs(self.instance:GetChildren()) do
		self:onChildAdded(child)
	end

	-- Initialize self.ammoInWeaponValue
	if selfClass.CanBeReloaded then
		if IsServer then
			self.ammoInWeaponValue = self.instance:FindFirstChild("CurrentAmmo")
			if not self.ammoInWeaponValue then
				self.ammoInWeaponValue = Instance.new("IntValue")
				self.ammoInWeaponValue.Name = "CurrentAmmo"
				self.ammoInWeaponValue.Value = 0
				self.ammoInWeaponValue.Parent = self.instance
			end
			self.ammoInWeaponValue.Value = self:getConfigValue("AmmoCapacity", 30)
		else
			self.ammoInWeaponValue = self.instance:WaitForChild("CurrentAmmo")
		end
	end

	self.connections.ancestryChanged = self.instance.AncestryChanged:Connect(function() self:onAncestryChanged() end)
	self:onAncestryChanged()

	-- Set up equipped/unequipped and activated/deactivated
	if self.instanceIsTool then
		self.connections.equipped = self.instance.Equipped:Connect(function()
			if IsServer or (Players.LocalPlayer and (self.instance:IsDescendantOf(Players.LocalPlayer.Backpack) or self.instance:IsDescendantOf(Players.LocalPlayer.Character))) then
				self:setEquipped(true)
				if self:getAmmoInWeapon() <= 0 then
					-- Have to wait a frame, otherwise the reload animation will not play
					coroutine.wrap(function()
						wait()
						self:reload()
					end)()
				end
			end
		end)
		self.connections.unequipped = self.instance.Unequipped:Connect(function()
			if IsServer or (Players.LocalPlayer and (self.instance:IsDescendantOf(Players.LocalPlayer.Backpack) or self.instance:IsDescendantOf(Players.LocalPlayer.Character))) then
				self:setEquipped(false)
				if self.reloading then
					self:cancelReload()
				end
			end
		end)
		if self.instance:IsDescendantOf(workspace) and self.player then
			self:setEquipped(true)
		end

		self.connections.activated = self.instance.Activated:Connect(function()
			self:setActivated(true)
		end)
		self.connections.deactivated = self.instance.Deactivated:Connect(function()
			self:setActivated(false)
		end)

		-- Weld handle to weapon primary part
		if IsServer then
			self.handle = self.instance:FindFirstChild("Handle")

			local model = self.instance:FindFirstChildOfClass("Model")
			local handleAttachment = model:FindFirstChild("HandleAttachment", true)

			if self.handle and handleAttachment then
				local handleOffset = model.PrimaryPart.CFrame:toObjectSpace(handleAttachment.WorldCFrame)

				local weld = Instance.new("Weld")
				weld.Name = "HandleWeld"
				weld.Part0 = self.handle
				weld.Part1 = model.PrimaryPart
				weld.C0 = CFrame.new()
				weld.C1 = handleOffset
				weld.Parent = self.handle

				self.handle.Anchored = false
				model.PrimaryPart.Anchored = false
			end
		end
	end
end

function BaseWeapon:registerDescendants()
	if not self.instance then
		error("No instance set yet!")
	end

	if self.descendantsRegistered then
		warn("Descendants already registered!")
		return
	end

	for _, descendant in ipairs(self.instance:GetDescendants()) do
		if self.descendants[descendant.Name] == nil then
			self.descendants[descendant.Name] = descendant
		else
			self.descendants[descendant.Name] = "Multiple"
		end
	end
	self.descendantsRegistered = true
end

function BaseWeapon:addOptionalDescendant(key, descendantName)
	if self.instance == nil then
		error("No instance set yet!")
	end

	if not self.descendantsRegistered then
		error("Descendants not registered!")
	end

	if self.descendants[descendantName] == "Multiple" then
		error("Weapon \""..self.instance.Name.."\" has multiple descendants named \""..descendantName.."\", so you cannot addOptionalDescendant with that descendant name.")
	end

	local found = self.descendants[descendantName]
	if found then
		self[key] = found
		return
	else
		self.optionalDescendantNames[descendantName] = key
	end
end

function BaseWeapon:onDescendantAdded(descendant)
	if self.descendants[descendant.Name] == nil then
		self.descendants[descendant.Name] = descendant
	else
		self.descendants[descendant.Name] = "Multiple"
	end

	local desiredKey = self.optionalDescendantNames[descendant.Name]
	if desiredKey then
		if self.descendants[descendant.Name] == "Multiple" then
			error("Weapon \""..self.instance.Name.."\" has multiple descendants named \""..descendant.Name.."\", so you cannot addOptionalDependency with that descendant name.")
		end
		self[desiredKey] = descendant
		self.optionalDescendantNames[descendant.Name] = nil
	end
end

function BaseWeapon:cleanupConnection(...)
	local args = { ... }
	for _, name in pairs(args) do
		if typeof(name) == "string" and self.connections[name] then
			self.connections[name]:Disconnect()
			self.connections[name] = nil
		end
	end
end

function BaseWeapon:onAncestryChanged()
	if self.instanceIsTool then
		local player = nil
		if self.instance:IsDescendantOf(Players) then
			local parentPlayer = self.instance.Parent.Parent
			if parentPlayer and parentPlayer:IsA("Player") then
				player = parentPlayer
			end
		elseif self.instance:IsDescendantOf(workspace) then
			local parentPlayer = Players:GetPlayerFromCharacter(self.instance.Parent)
			if parentPlayer and parentPlayer:IsA("Player") then
				player = parentPlayer
			end
		end

		self:setPlayer(player)
	end
end

function BaseWeapon:setPlayer(player)
	if self.player == player then
		return
	end

	self.player = player
end

function BaseWeapon:setEquipped(equipped)
	if self.equipped == equipped then
		return
	end

	self.equipped = equipped
	self:onEquippedChanged()

	if not self.equipped then
		self:stopAnimations()
	end
end

function BaseWeapon:onEquippedChanged()
	if self.activeRenderStepName then
		RunService:UnbindFromRenderStep(self.activeRenderStepName)
		self.activeRenderStepName = nil
	end
	self:cleanupConnection("localStepped")

	if not IsServer and self.weaponsSystem then
		self.weaponsSystem.setWeaponEquipped(self, self.equipped)
		if self.equipped then
			if self.player == Players.LocalPlayer then
				RunService:BindToRenderStep(self.instance:GetFullName(), Enum.RenderPriority.Input.Value, function(dt)
					self:onRenderStepped(dt)
				end)
				self.activeRenderStepName = self.instance:GetFullName()
			end
			self.connections.localStepped = RunService.Heartbeat:Connect(function(dt)
				self:onStepped(dt)
			end)
		end
	end

	if self.instanceIsTool then
		for _, part in pairs(self.instance:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = part ~= self.handle and not self.equipped
			end
		end
	end

	self:setActivated(false)
end

function BaseWeapon:setActivated(activated, fromNetwork)
	if not IsServer and fromNetwork and self.player == Players.LocalPlayer then
		return
	end

	if self.activated == activated then
		return
	end

	self.activated = activated
	if IsServer and not fromNetwork then
		self.weaponsSystem.getRemoteEvent("WeaponActivated"):FireAllClients(self.player, self.instance, self.activated)
	end

	self:onActivatedChanged()
end

function BaseWeapon:onActivatedChanged()

end

function BaseWeapon:renderFire(fireInfo)

end

function BaseWeapon:simulateFire(fireInfo)

end

function BaseWeapon:isOwnerAlive()
	if self.instance:IsA("Tool") then
		local humanoid = self.instance.Parent:FindFirstChildOfClass("Humanoid")
		if humanoid then
			return humanoid:GetState() ~= Enum.HumanoidStateType.Dead
		end
	end

	return true
end

function BaseWeapon:fire(origin, dir, charge)
	if not self:isOwnerAlive() or self.reloading then
		return
	end

	if self:useAmmo(1) <= 0 then
		self:reload()
		return
	end

	local fireInfo = {}
	fireInfo.origin = origin
	fireInfo.dir = dir
	fireInfo.charge = math.clamp(charge or 1, 0, 1)
	fireInfo.id = self.nextShotId
	self.nextShotId = self.nextShotId + 1

	if not IsServer then
		self:onFired(self.player, fireInfo, false)
		self.weaponsSystem.getRemoteEvent("WeaponFired"):FireServer(self.instance, fireInfo)
	else
		self:onFired(self.player, fireInfo, false)
	end
end

function BaseWeapon:onFired(firingPlayer, fireInfo, fromNetwork)
	if not IsServer then
		if firingPlayer == Players.LocalPlayer and fromNetwork then
			return
		end

		self:simulateFire(firingPlayer, fireInfo)
	else
		if self:useAmmo(1) <= 0 then
			return
		end

		self.weaponsSystem.getRemoteEvent("WeaponFired"):FireAllClients(firingPlayer, self.instance, fireInfo)
	end
end

function BaseWeapon:getConfigValue(valueName, defaultValue)
	if self.configValues[valueName] ~= nil then
		return self.configValues[valueName]
	else
		return defaultValue
	end
end

function BaseWeapon:tryPlaySound(soundName, playbackSpeedRange)
	playbackSpeedRange = playbackSpeedRange or 0

	local soundTemplate = self.sounds[soundName]
	if not soundTemplate then
		soundTemplate = self.instance:FindFirstChild(soundName, true)
		self.sounds[soundName] = soundTemplate
	end

	if not soundTemplate then
		return
	end

	local sound = soundTemplate:Clone()
	sound.PlaybackSpeed = sound.PlaybackSpeed + localRandom:NextNumber(-playbackSpeedRange * 0.5, playbackSpeedRange * 0.5)
	sound.Parent = soundTemplate.Parent
	sound:Play()
	coroutine.wrap(function()
		wait(sound.TimeLength / sound.PlaybackSpeed)
		sound:Destroy()
	end)()

	return sound
end

function BaseWeapon:getSound(soundName)
	local soundTemplate = self.sounds[soundName]
	if not soundTemplate then
		soundTemplate = self.instance:FindFirstChild(soundName, true)
		self.sounds[soundName] = soundTemplate
	end

	return soundTemplate
end

function BaseWeapon:onDestroyed()

end

function BaseWeapon:onConfigValueAdded(valueObj)
	local valueName = valueObj.Name
	local newValue = valueObj.Value
	self.configValues[valueName] = newValue
	self:onConfigValueChanged(valueName, newValue, nil)

	self.connections["valueChanged:" .. valueName] = valueObj.Changed:Connect(function(changedValue)
		local oldValue = self.configValues[valueName]
		self.configValues[valueName] = changedValue

		self:onConfigValueChanged(valueName, changedValue, oldValue)
	end)
	self.connections["valueRenamed:" .. valueName] = valueObj:GetPropertyChangedSignal("Name"):Connect(function()
		self.configValues[valueName] = nil
		self:cleanupConnection("valueChanged:" .. valueName)
		self:cleanupConnection("valueRenamed:" .. valueName)
		self:onConfigValueAdded(valueObj)
	end)
end

function BaseWeapon:onConfigValueRemoved(valueObj)
	local valueName = valueObj.Name
	self.configValues[valueName] = nil

	self:cleanupConnection("valueChanged:" .. valueName)
	self:cleanupConnection("valueRenamed:" .. valueName)
end

-- This function is used to set configuration values from outside configuration objects/folders
function BaseWeapon:importConfiguration(config)
	if not config or not config:IsA("Configuration") then
		for _, child in pairs(config:GetChildren()) do
			if child:IsA("ValueBase") then
				local valueName = child.Name
				local newValue = child.Value
				local oldValue = self.configValues[valueName]
				self.configValues[valueName] = newValue
				self:onConfigValueChanged(valueName, newValue, oldValue)
			end
		end
	end
end

function BaseWeapon:setConfiguration(config)
	self:cleanupConnection("configChildAdded", "configChildRemoved")
	if not config or not config:IsA("Configuration") then
		return
	end

	for _, child in pairs(config:GetChildren()) do
		if child:IsA("ValueBase") then
			self:onConfigValueAdded(child)
		end
	end
	self.connections.configChildAdded = config.ChildAdded:Connect(function(child)
		if child:IsA("ValueBase") then
			self:onConfigValueAdded(child)
		end
	end)
	self.connections.configChildRemoved = config.ChildRemoved:Connect(function(child)
		if child:IsA("ValueBase") then
			self:onConfigValueRemoved(child)
		end
	end)
end

function BaseWeapon:onChildAdded(child)
	if child:IsA("Configuration") then
		self:setConfiguration(child)
	end
end

function BaseWeapon:onChildRemoved(child)
	if child:IsA("Configuration") then
		self:setConfiguration(nil)
	end
end

function BaseWeapon:onConfigValueChanged(valueName, newValue, oldValue)

end

function BaseWeapon:onRenderStepped(dt)

end

function BaseWeapon:onStepped(dt)

end

function BaseWeapon:getAnimationController()
	if self.animController then
		if not self.instanceIsTool or (self.animController.Parent and self.animController.Parent:IsAncestorOf(self.instance)) then
			return self.animController
		end
	end

	self:setAnimationController(nil)

	if self.instanceIsTool then
		local humanoid = IsServer and self.instance.Parent:FindFirstChildOfClass("Humanoid") or self.instance.Parent:WaitForChild("Humanoid", math.huge)
		local animController = nil
		if not humanoid then
			animController = self.instance.Parent:FindFirstChildOfClass("AnimationController")
		end

		self:setAnimationController(humanoid or animController)
		return self.animController
	end
end

function BaseWeapon:setAnimationController(animController)
	if animController == self.animController then
		return
	end
	self:stopAnimations()
	self.animController = animController
end

function BaseWeapon:stopAnimations()
	for _, track in pairs(self.animTracks) do
		if track.IsPlaying then
			track:Stop()
		end
	end
	self.animTracks = {}
end

function BaseWeapon:getAnimTrack(key)
	local track = self.animTracks[key]
	if not track then
		local animController = self:getAnimationController()
		if not animController then
			warn("No animation controller when trying to play ", key)
			return nil
		end

		local animation = AnimationsFolder:FindFirstChild(key)
		if not animation then
			error(string.format("No such animation \"%s\" ", tostring(key)))
		end

		track = animController:LoadAnimation(animation)
		self.animTracks[key] = track
	end

	return track
end

function BaseWeapon:reload(player, fromNetwork)
	if
		not self.equipped or
		self.reloading or
		not self.canReload or
		self:getAmmoInWeapon() == self:getConfigValue("AmmoCapacity", 30)
	then
		return false
	end

	if not IsServer then
		if self.player ~= nil and self.player ~= Players.LocalPlayer then
			return
		end
		self.weaponsSystem.getRemoteEvent("WeaponReloadRequest"):FireServer(self.instance)
		self:onReloaded(self.player)
	else
		self:onReloaded(player, fromNetwork)
		self.weaponsSystem.getRemoteEvent("WeaponReloaded"):FireAllClients(player, self.instance)
	end
end

function BaseWeapon:onReloaded(player, fromNetwork)
	if fromNetwork and player == Players.LocalPlayer then -- make sure localplayer doesn't reload twice
		return
	end

	self.reloading = true
	self.canReload = false

	-- Play reload animation and sound
	if not IsServer then
		local reloadTrackKey = self:getConfigValue("ReloadAnimation", "RifleReload")
		if reloadTrackKey then
			self.reloadTrack = self:getAnimTrack(reloadTrackKey)
			if self.reloadTrack then
				self.reloadTrack:Play()
			end
		end

		self.curReloadSound = self:tryPlaySound("Reload", nil)
		if self.curReloadSound then
			self.curReloadSound.Ended:Connect(function()
				self.curReloadSound = nil
			end)
		end
	end

	local reloadTime = self:getConfigValue("ReloadTime", 2)
	local startTime = tick()

	if self.connections.reload ~= nil then -- this prevents an endless ammo bug
		return
	end
	self.connections.reload = RunService.Heartbeat:Connect(function()
		-- Stop trying to reload if the player unequipped this weapon or reloading was canceled some other way
		if not self.reloading then
			if self.connections.reload then
				self.connections.reload:Disconnect()
				self.connections.reload = nil
			end
		end

		-- Wait until gun finishes reloading
		if tick() < startTime + reloadTime then
			return
		end

		-- Add ammo to weapon
		if self.ammoInWeaponValue then
			self.ammoInWeaponValue.Value = self:getConfigValue("AmmoCapacity", 30)
		end

		if self.connections.reload then
			self.connections.reload:Disconnect()
			self.connections.reload = nil
		end

		self.reloading = false
		self.canReload = false
	end)
end

function BaseWeapon:cancelReload(player, fromNetwork)
	if not self.reloading then
		return
	end
	if fromNetwork and player == Players.LocalPlayer then
		return
	end

	if not IsServer and not fromNetwork and player == Players.LocalPlayer then
		self.weaponsSystem.getRemoteEvent("WeaponReloadCanceled"):FireServer(self.instance)
	elseif IsServer and fromNetwork then
		self.weaponsSystem.getRemoteEvent("WeaponReloadCanceled"):FireAllClients(player, self.instance)
	end

	self.reloading = false
	self.canReload = true

	if not IsServer and self.reloadTrack and self.reloadTrack.IsPlaying then
		warn("Stopping reloadTrack")
		self.reloadTrack:Stop()
	end
	if self.curReloadSound then
		self.curReloadSound:Stop()
		self.curReloadSound:Destroy()
		self.curReloadSound = nil
	end
end

function BaseWeapon:getAmmoInWeapon()
	if self.ammoInWeaponValue then
		return self.ammoInWeaponValue.Value
	end
	return 0
end

function BaseWeapon:useAmmo(amount)
	if self.ammoInWeaponValue then
		local ammoUsed = math.min(amount, self.ammoInWeaponValue.Value)
		self.ammoInWeaponValue.Value = self.ammoInWeaponValue.Value - ammoUsed
		self.canReload = true
		return ammoUsed
	else
		return 0
	end
end

function BaseWeapon:renderCharge()

end

return BaseWeapon
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="14">
          <Properties>
            <string name="Name">DamageBillboardHandler</string>
            <string name="Source">local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

if RunService:IsServer() then return {} end

local localPlayer = Players.LocalPlayer
while not localPlayer do
	Players.PlayerAdded:Wait()
	localPlayer = Players.LocalPlayer
end

local adorneeToBillboardGui = {}

local DamageBillboardHandler = {}

function DamageBillboardHandler:CreateBillboardForAdornee(adornee)
	local billboard = adorneeToBillboardGui[adornee]
	if billboard then
		return billboard
	end

	billboard = Instance.new("BillboardGui")
	billboard.Name = "DamageBillboardGui"
	billboard.Adornee = adornee
	billboard.AlwaysOnTop = true
	billboard.ExtentsOffsetWorldSpace = Vector3.new(0,18,0)
	billboard.Size = UDim2.new(0.42,20,15,0)
	billboard.ResetOnSpawn = false
	billboard.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	billboard.Parent = localPlayer.PlayerGui
	adorneeToBillboardGui[adornee] = billboard

	local ancestorCon
	ancestorCon = adornee.AncestryChanged:connect(function(child, parent)
		if parent == nil then
			ancestorCon:disconnect()
			ancestorCon = nil

			local adorneeBillboard = adorneeToBillboardGui[adornee]
			adorneeBillboard:Destroy()
			adorneeToBillboardGui[adornee] = nil
		end
	end)

	return billboard
end


-- Disable the display of the damage amount billboards.
function DamageBillboardHandler:ShowDamageBillboard(damageAmount, adornee)
	return nil
end


--function DamageBillboardHandler:ShowDamageBillboard(damageAmount, adornee)
--	damageAmount = math.ceil(damageAmount)

--	local billboard = self:CreateBillboardForAdornee(adornee)

--	local randomXPos = math.random(-10,10)/30

--	local damageNumber = Instance.new("TextLabel")
--	damageNumber.AnchorPoint = Vector2.new(0.5, 1)
--	damageNumber.BackgroundTransparency = 1
--	damageNumber.BorderSizePixel = 0
--	damageNumber.Position = UDim2.fromScale(0.5 + randomXPos,1)
--	damageNumber.Size = UDim2.fromScale(0,0.25)
--	damageNumber.Font = Enum.Font.GothamBlack
--	damageNumber.Text = tostring(damageAmount)
--	damageNumber.TextColor3 = Color3.new(0.7,0.7,0.7)
--	damageNumber.TextScaled = true
--	damageNumber.TextStrokeTransparency = 0
--	damageNumber.TextTransparency = 0
--	damageNumber.TextXAlignment = Enum.TextXAlignment.Center
--	damageNumber.TextYAlignment = Enum.TextYAlignment.Bottom
--	damageNumber.Parent = billboard

--	local appearTweenInfo = TweenInfo.new(
--		0.5, --time
--		Enum.EasingStyle.Elastic,
--		Enum.EasingDirection.Out,
--		0, --repeatCount
--		false, --reverses
--		0) --delayTime
--	local appearTween = TweenService:Create(
--		damageNumber,
--		appearTweenInfo, {
--			Size = UDim2.fromScale(1, damageNumber.Size.Y.Scale),
--			TextColor3 = Color3.new(1,1,1)
--		}
--	)

--	local upTweenInfo = TweenInfo.new(
--		0.5, --time
--		Enum.EasingStyle.Linear,
--		Enum.EasingDirection.Out,
--		0, --repeatCount
--		false, --reverses
--		0.2) --delayTime
--	local upTween = TweenService:Create(
--		damageNumber,
--		upTweenInfo, {
--			Position = UDim2.fromScale(damageNumber.Position.X.Scale, 0.25),
--			TextTransparency = 1,
--			TextStrokeTransparency = 4,
--			Rotation = math.random(-5,5)
--		}
--	)

--	local completedCon
--	completedCon = upTween.Completed:connect(function()
--		completedCon:disconnect()
--		completedCon = nil
--		damageNumber:Destroy()
--	end)

--	appearTween:Play()
--	upTween:Play()
--end

return DamageBillboardHandler</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="15">
          <Properties>
            <string name="Name">DirectionalIndicatorGuiManager</string>
            <string name="Source">local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local DirectionalIndicatorGuiManager = {}
DirectionalIndicatorGuiManager.__index = DirectionalIndicatorGuiManager

local function GetConfigValue(config, propertyName, default)
	if config then
		local property = config:FindFirstChild(propertyName)
		if property then
			return property.Value
		end
	end
	return default
end

function DirectionalIndicatorGuiManager.new(weaponsGui)
	local self = setmetatable({}, DirectionalIndicatorGuiManager)
	self.weaponsGui = weaponsGui
	self.connections = {}
	self.enabled = false

	-- Note DI is an abbreviation for DirectionalIndicator
	self.DIFolder = self.weaponsGui.scalingElementsFolder:WaitForChild("DirectionalIndicators")
	self.DIInfo = {}

	for _, DIFrame in ipairs(self.DIFolder:GetChildren()) do
		if DIFrame:IsA("Frame") and DIFrame:FindFirstChildOfClass("ImageLabel") then
			local config = DIFrame:FindFirstChildOfClass("Configuration")
			local name = GetConfigValue(config, "Name", DIFrame.Name)
			self.DIInfo[name] = self:GetDIInfoFromFrame(DIFrame)

			DIFrame.Visible = true
			self.DIInfo[name].image.ImageTransparency = 1
		end
	end

	return self
end

function DirectionalIndicatorGuiManager:GetDIInfoFromFrame(frame)
	local diInfo = {}
	diInfo.frame = frame
	diInfo.image = frame:FindFirstChildOfClass("ImageLabel")
	diInfo.config = frame:FindFirstChildOfClass("Configuration")
	diInfo.active = false
	diInfo.dieOnFade = false -- will only be true for copies of original DIs
	return diInfo
end

function DirectionalIndicatorGuiManager:ActivateDirectionalIndicator(DIName, otherPosition)
	-- Use original DI, or make a copy if it's already active
	local diInfo = self.DIInfo[DIName]
	if not diInfo then
		warn("Warning: invalid name given to ActivateDirectionalIndicator")
		return
	end

	if diInfo.active then
		local newFrame = diInfo.frame:Clone()
		newFrame.Parent = diInfo.frame.Parent
		diInfo = self:GetDIInfoFromFrame(newFrame)
		diInfo.dieOnFade = true
	end
	diInfo.active = true

	-- Update distance from center
	local distanceLevel = GetConfigValue(diInfo.config, "DistanceLevelFromCenter", 6)
	local widthLevel = GetConfigValue(diInfo.config, "WidthLevel", distanceLevel)
	local levelMultiplier = 0.03
	self.weaponsGui.originalScaleAmounts[diInfo.frame] = Vector2.new(widthLevel * levelMultiplier, distanceLevel * levelMultiplier * 2)
	self.weaponsGui:updateScale(diInfo.frame, workspace.CurrentCamera.ViewportSize)

	-- Set initial indicator rotation and transparency
	diInfo.frame.Rotation = self:CalculateDIRotation(otherPosition)
	diInfo.image.ImageTransparency = GetConfigValue(diInfo.config, "TransparencyBeforeFade", 0)

	-- Update rotation of indicator as player rotates
	coroutine.wrap(function()
		while diInfo.image.ImageTransparency &lt; 1 do
			diInfo.frame.Rotation = self:CalculateDIRotation(otherPosition)
			RunService.RenderStepped:Wait()
		end

		diInfo.active = false
		if diInfo.dieOnFade then
			diInfo.frame:Destroy()
			diInfo = nil
		end
	end)()

	-- Show indicator for a bit, then fade out
	coroutine.wrap(function()
		wait(GetConfigValue(diInfo.config, "TimeBeforeFade", 1))
		local tweenInfo = TweenInfo.new(GetConfigValue(diInfo.config, "FadeTime", 1))
		local goal = {}
		goal.ImageTransparency = 1
		local tween = TweenService:Create(diInfo.image, tweenInfo, goal)
		tween:Play()
	end)()
end

function DirectionalIndicatorGuiManager:CalculateDIRotation(otherPosition)
	local camera = self.weaponsGui.weaponsSystem.camera
	local localPlayerOffsetPositionXZ = Vector3.new(camera.currentCamera.Focus.X, 0, camera.currentCamera.Focus.Z)
	local otherPlayerPositionXZ = Vector3.new(otherPosition.X, 0, otherPosition.Z)
	local toOtherPlayer = (localPlayerOffsetPositionXZ - otherPlayerPositionXZ).Unit
	local forward = (Vector3.new(camera.currentCFrame.LookVector.X, 0, camera.currentCFrame.LookVector.Z)).Unit
	if toOtherPlayer == Vector3.new() then
		toOtherPlayer = forward
	end
	local dotProduct = forward:Dot(toOtherPlayer)
	local crossProduct = forward:Cross(toOtherPlayer)
	local acosAngle = math.deg(math.acos(dotProduct))
	local asinAngle = math.deg(math.asin(crossProduct.Y))
	if asinAngle >= 0 then
		acosAngle = 360 - acosAngle
	end
	return acosAngle
end

return DirectionalIndicatorGuiManager</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="16">
          <Properties>
            <string name="Name">Parabola</string>
            <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local MIN_HORZ_SPEED = 0.01 --The minimum X and Z velocity for a physical-launch parabola to be considered vertical, helps avoid numerical instability
local DEFAULT_NUM_SAMPLES = RunService:IsServer() and 32 or 32
local DEFAULT_NORMAL = Vector3.new(0, 1, 0)
local ROT_OFFSET = {
	[0] = CFrame.Angles(0, math.rad(90), 0) * CFrame.Angles(math.rad(90), 0, 0),
	[1] = CFrame.Angles(0, math.rad(-90), 0) * CFrame.Angles(math.rad(90), 0, 0)
}
local UP_VECTOR = Vector3.new(0, 1, 0)
local ONE_THIRD, TWO_THIRDS = 1/3, 2/3

local Parabola = {}
Parabola.__index = Parabola

function Parabola.new(a, b, c, x0, x1)
	local self = setmetatable({}, Parabola)

	self.referenceFrame = CFrame.new()

	self.a = a or 1
	self.b = b or 1
	self.c = c or 0

	self.x0 = x0 or 0
	self.x1 = x1 or 10

	self.velocity = Vector2.new()
	self.gravity = 0

	self.numSamples = DEFAULT_NUM_SAMPLES

	return self
end

function Parabola:setPhysicsLaunch(startPoint, velocity, endpointY, gravity)
	gravity = gravity or -workspace.Gravity

	local flatVelocity = velocity * Vector3.new(1, 0, 1)
	if flatVelocity.Magnitude > MIN_HORZ_SPEED then
		self.referenceFrame = CFrame.new(startPoint, startPoint + flatVelocity)
	else
		self.referenceFrame = CFrame.new(startPoint)
	end
	local relativeVelocity = self.referenceFrame:vectorToObjectSpace(velocity)
	local xVelocity, yVelocity = math.max(MIN_HORZ_SPEED, -relativeVelocity.Z), relativeVelocity.Y
	self.a = (0.5 * gravity) * (1 / (xVelocity ^ 2))
	self.b = yVelocity / xVelocity
	self.c = 0

	self.velocity = Vector2.new(xVelocity, yVelocity)
	self.gravity = gravity

	if math.abs(gravity) > 1e-3 then
		self.x0 = 0

		if endpointY and startPoint.Y - endpointY > 0 then
			--y = ax^2 + bx + c
			--0 = ax^2 + bx - y
			--x = (-b +- sqrt(b^2 - 4ac)) / 2a

			local a, b, c = self.a, self.b, startPoint.Y - endpointY
			local det = math.sqrt(b^2 - 4 * a * c)
			local s1, s2 = (-b + det) / (2 * a), (-b - det) / (2 * a)

			self.x1 = math.max(s1, s2)
		else
			self.x1 = math.abs(2 * xVelocity * yVelocity) / math.abs(gravity)
		end
	else
		self.x0 = 0
		self.x1 = 100
	end
end

function Parabola:setNumSamples(numSamples)
	self.numSamples = numSamples
end

function Parabola:setDomain(x0, x1)
	self.x0 = x0
	self.x1 = x1
end

function Parabola:samplePoint(t)
	local a, b, c = self.a, self.b, self.c
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local y = (a * x * x) + (b * x) + c
	return self.referenceFrame:pointToWorldSpace(Vector3.new(0, y, -x))
end

function Parabola:sampleSlope(t)
	local a, b = self.a, self.b
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local y = (2 * a * x) + b
	return y
end

function Parabola:sampleVelocity(t)
	local x0, x1 = self.x0, self.x1
	local x = x0 + (t * (x1 - x0))
	local xVelocity = self.velocity.X
	local xT = x / xVelocity
	local yVelocity = self.velocity.Y + (self.gravity * xT)
	return self.referenceFrame:vectorToWorldSpace(Vector3.new(0, yVelocity, -xVelocity))
end

function Parabola:_penetrateCast(ray, ignoreList)
	debug.profilebegin("penetrateCast")
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, UP_VECTOR, Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and not hitPart.CanCollide and hitPart.Parent:FindFirstChildOfClass("Humanoid") == nil then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	debug.profileend()
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function Parabola:_findPart(funcName, list)
	list = list or {}

	local numSamples = self.numSamples
	local hitPart, hitPoint, hitNormal, hitMaterial, hitT = nil, self.referenceFrame.p, DEFAULT_NORMAL, Enum.Material.Air, 0

	local func = funcName ~= "penetrateCast" and workspace[funcName] or Parabola._penetrateCast

	for i = 1, numSamples do
		local t0 = (i - 1) / numSamples
		local t1 = i / numSamples

		local p0 = self:samplePoint(t0)
		local p1 = self:samplePoint(t1)
		local ray = Ray.new(p0, p1 - p0)

		hitPart, hitPoint, hitNormal, hitMaterial = func(workspace, ray, list)
		if hitPart then
			local hitX = -self.referenceFrame:pointToObjectSpace(hitPoint).Z

			hitT = ((hitX - self.x0) / (self.x1 - self.x0))
			break
		end
	end
	if not hitPart then
		hitT = 1
	end
	return hitPart, hitPoint, hitNormal, hitMaterial, hitT
end

function Parabola:findPart(ignoreList)
	return self:_findPart("penetrateCast", ignoreList)
end
function Parabola:findPartWithWhitelist(whitelist)
	return self:_findPart("FindPartOnRayWithWhitelist", whitelist)
end

function Parabola:findSpheresHit(sphereTable, radius)

end

function Parabola:_setBeamControlPoint(beam, attachment, idx, pos, refFrame)
	local attachmentPos = attachment.WorldPosition
	local vecFromAttachment = pos - attachmentPos
	local curveSize = vecFromAttachment.Magnitude

	attachment.CFrame = refFrame:toObjectSpace(CFrame.new(attachmentPos, pos) * ROT_OFFSET[idx])
	if idx == 0 then
		beam.CurveSize0 = curveSize
	else
		beam.CurveSize1 = curveSize
	end
end

function Parabola:renderToBeam(beam)
	local att0, att1 = beam.Attachment0, beam.Attachment1
	--assert(att0 and att1 and att0.Parent and att0.Parent:IsA("BasePart") and att1.Parent and att1.Parent:IsA("BasePart"), "Beam must have valid attachments that are in a BasePart")

	if not att0.Parent or not att1.Parent then
		return
	end

	local root0, root1 = att0.Parent.CFrame, att1.Parent.CFrame

	local referenceFrame = self.referenceFrame

	local x0, x1 = self.x0, self.x1
	local domain = x1 - x0
	local halfDomain = domain * 0.5
	local p0 = self:samplePoint(0)
	local p1 = self:samplePoint(1)
	local a, b, c = self.a, self.b, self.c
	local x = x0 + (0 * (x1 - x0))
	local cY = ((a * x * x) + (b * x) + c) + self:sampleSlope(0) * halfDomain
	c = referenceFrame:pointToWorldSpace(Vector3.new(0, cY, -(x0 + x1) / 2))
	local c0 = TWO_THIRDS * c + ONE_THIRD * p0
	local c1 = TWO_THIRDS * c + ONE_THIRD * p1

	att0.Position = root0:pointToObjectSpace(p0)
	att1.Position = root1:pointToObjectSpace(p1)

	self:_setBeamControlPoint(beam, att0, 0, c0, root0)
	self:_setBeamControlPoint(beam, att1, 1, c1, root1)
end

return Parabola
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="17">
          <Properties>
            <string name="Name">Ragdoll</string>
            <string name="Source"><![CDATA[local RunService = game:GetService("RunService")

local JOINT_INFO = {
	LeftShoulder = {
		Limits = { Cone = 70, Twist = 30 },
		Offset = Vector3.new(0, -0.25, 0),
		Rotation = CFrame.Angles(0, 0, math.rad(45))
	},
	LeftElbow = {
		Limits = { Lower = 0, Upper = 160 }
	},
	LeftWrist = {
		Limits = { Cone = 90, Twist = 90 }
	},
	RightShoulder = {
		Limits = { Cone = 70, Twist = 30 },
		Offset = Vector3.new(0, -0.25, 0),
		Rotation = CFrame.Angles(0, 0, math.rad(-45))
	},
	RightElbow = {
		Limits = { Lower = 0, Upper = 160 }
	},
	RightWrist = {
		Limits = { Cone = 90, Twist = 90 }
	},

	Waist = {
		Limits = { Lower = -45, Upper = 30 }
	},
	Neck = {
		Limits = { Cone = 20, Twist = 20 }
	},

	LeftHip = {
		Limits = { Cone = 40, Twist = 2.5 },
		Rotation = CFrame.Angles(math.rad(-40), 0, math.rad(35)),
	},
	LeftKnee = {
		Limits = { Lower = 0, Upper = 120 }
	},
	LeftAnkle = {
		Limits = { Cone = 10, Twist = 0.5 }
	},
	RightHip = {
		Limits = { Cone = 40, Twist = 2.5 },
		Rotation = CFrame.Angles(math.rad(-40), 0, math.rad(-35))
	},
	RightKnee = {
		Limits = { Lower = 0, Upper = 120 }
	},
	RightAnkle = {
		Limits = { Cone = 10, Twist = 0.5 }
	}
}

local GROUPS = {
	UpperBody = {
		"Waist",
		"Neck",
		"LeftShoulder",
		"RightShoulder",
		"LeftElbow",
		"RightElbow",
		"LeftWrist",
		"RightWrist"
	},
	LowerBody = {
		"LeftHip",
		"RightHip",
		"LeftKnee",
		"RightKnee",
		"LeftAnkle",
		"RightAnkle"
	},
	LeftArm = {
		"LeftShoulder",
		"LeftElbow",
		"LeftWrist",
	},
	RightArm = {
		"RightShoulder",
		"RightElbow",
		"RightWrist"
	},
	LeftLeg = {
		"LeftHip",
		"LeftKnee",
		"LeftAnkle"
	},
	RightLeg = {
		"RightHip",
		"RightKnee",
		"RightAnkle"
	},
}

local Ragdoll = {}
Ragdoll.__index = Ragdoll

function Ragdoll.new(character)
	local self = setmetatable({}, Ragdoll)
	self.character = character
	self.humanoid = character:WaitForChild("Humanoid")

	self.joints = {}
	for jointName, info in pairs(JOINT_INFO) do
		self.joints[jointName] = self:setupJoint(jointName, info)
	end

	return self
end

function Ragdoll:setupJoint(jointName, info)
	if self.joints[jointName] then
		return self.joints[jointName]
	end

	local constraintName = jointName .. "Constraint"
	local rigAttachmentName = jointName .. "RigAttachment"
	local existingConstraint = self.character:FindFirstChild(constraintName, true)
	local existingMotor = self.character:FindFirstChild(jointName, true)
	if not existingMotor then
		return nil
	end

	if existingConstraint or RunService:IsClient() then
		existingConstraint = self.character:WaitForChild(constraintName)
		return {
			constraint = existingConstraint,
			motor = existingMotor,
			ragdolled = existingMotor.Part1 ~= nil
		}
	else
		local constraintType = "HingeConstraint"
		if info.Limits and info.Limits.Cone and info.Limits.Twist then
			constraintType = "BallSocketConstraint"
		end

		local constraint = Instance.new(constraintType)
		constraint.Name = constraintName
		constraint.Enabled = false
		constraint.Attachment0 = existingMotor.Part0:FindFirstChild(rigAttachmentName)
		constraint.Attachment1 = existingMotor.Part1:FindFirstChild(rigAttachmentName)
		constraint.LimitsEnabled = info.Limits ~= nil

		if info.Limits and info.Limits.Cone and info.Limits.Twist then
			constraint.UpperAngle = info.Limits.Cone
			constraint.TwistLimitsEnabled = true
			constraint.TwistLowerAngle = -info.Limits.Twist
			constraint.TwistUpperAngle = info.Limits.Twist
		elseif info.Limits and info.Limits.Lower and info.Limits.Upper then
			constraint.LowerAngle = info.Limits.Lower
			constraint.UpperAngle = info.Limits.Upper
		end

		constraint.Parent = existingMotor.Parent

		return {
			constraint = constraint,
			motor = existingMotor,
			ragdolled = false
		}
	end
end

function Ragdoll:setJointRagdolled(jointName, ragdolled)
	local joint = self.joints[jointName]
	if not joint then return end

	joint.constraint.Enabled = ragdolled
	if joint.motor and joint.motor:IsA("Motor6D") then
		if ragdolled then
			joint.motor.Part1 = nil
		else
			joint.motor.Part1 = joint.motor.Parent
		end
	end
end

function Ragdoll:setGroupRagdolled(groupName, ragdolled)
	local groupJoints = GROUPS[groupName]
	assert(groupJoints, string.format("%s is not a valid ragdoll group", tostring(groupName)))

	for _, jointName in pairs(groupJoints) do
		self:setJointRagdolled(jointName, ragdolled)
	end
end

function Ragdoll:setRagdolled(ragdolled, whitelist)
	for jointName in pairs(self.joints) do
		if not whitelist or whitelist[jointName] then
			self:setJointRagdolled(jointName, ragdolled)
		end
	end
end

function Ragdoll:destroy()
	self:setRagdolled(false)
	for _, joint in pairs(self.joints) do
		if joint.constraint then
			joint.constraint:Destroy()
		end
	end
	self.joints = {}
end

return Ragdoll
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="18">
          <Properties>
            <string name="Name">Roblox</string>
            <string name="Source"><![CDATA[local TweenService 		= game:GetService("TweenService")
local CollectionService = game:GetService("CollectionService")
local RunService 		= game:GetService("RunService")
local UserInputService	= game:GetService("UserInputService")

local Roblox = {}

Roblox.Random = Random.new()
Roblox.zeroVector2 = Vector2.new()
Roblox.zeroVector3 = Vector3.new()
Roblox.identityCFrame = CFrame.new()
Roblox.upVector2 = Vector2.new(0, 1)
Roblox.upVector3 = Vector3.new(0, 1, 0)

local guidCharsText = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+./"
local guidChars = {}
for i = 1, #guidCharsText do
	guidChars[i] = guidCharsText:sub(i, i)
end
local guidRandom = Random.new()

function Roblox.newGuid()
	local guid = ""
	for _ = 1, 10 do
		local char = guidRandom:NextInteger(1,#guidChars)
		guid = guid .. guidChars[char]
	end
	return guid
end

function Roblox.isPlaySolo()
	return RunService:IsClient() and RunService:IsServer() and RunService:IsStudio()
end

function Roblox.waitForDescendant(instance, descendantName, timeout)
	timeout = timeout or 60
	local found = instance:FindFirstChild(descendantName, true)
	if found then
		return found
	end

	if timeout < 1e6 and timeout > 0 then
		coroutine.wrap(function()
			wait(timeout)
			if not found then
				warn("Roblox.waitForDescendant(%s, %s) is taking too long")
			end
		end)()
	end

	while not found do
		local newDescendant = instance.DescendantAdded:Wait()
		if newDescendant.Name == descendantName then
			found = newDescendant
			return newDescendant
		end
	end
end

function Roblox.create(className)
	return function(props)
		local instance = Instance.new(className)
		for key, val in pairs(props) do
			if key ~= "Parent" then
				instance[key] = val
			end
		end
		instance.Parent = props.Parent
		return instance
	end
end

function Roblox.weldModel(model)
	local rootPart = model.PrimaryPart
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") and part ~= rootPart then
			local weld = Instance.new("WeldConstraint")
			weld.Part0 = rootPart
			weld.Part1 = part
			weld.Parent = part
		end
	end
end

function Roblox.setNetworkOwner(model, owner)
	if not model then warn("Cannot setNetworkOwner on nil model") return end
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") and not part.Anchored then
			part:SetNetworkOwner(owner)
		end
	end
end

function Roblox.createMotor6D(root, child)
	local motor = Instance.new("Motor6D")
	motor.Part0 = root
	motor.Part1 = child

	motor.C0 = root.CFrame:toObjectSpace(child.CFrame)
	motor.C1 = CFrame.new()

	motor.Parent = root
	return motor
end

function Roblox.getTotalMass(part)
	local allConnected = part:GetConnectedParts(true)
	local total = 0
	for _, v in pairs(allConnected) do
		total = total + v:GetMass()
	end
	return total
end

function Roblox.waitForTween(tweenInstance, tweenInfo, tweenProps)
	local tween = TweenService:Create(tweenInstance, tweenInfo, tweenProps)
	tween:Play()
	tween.Completed:wait()
end

function Roblox.tween(tweenInstance, tweenInfo, tweenProps)
	local tween = TweenService:Create(tweenInstance, tweenInfo, tweenProps)
	tween:Play()
end

function Roblox.fadeAway(gui, duration, level)
	duration = duration or 0.5
	level = level or 0

	local tweenInfo = TweenInfo.new(duration)
	local tweenProps = { BackgroundTransparency = 1 }

	if gui:IsA("TextButton") or gui:IsA("TextLabel") or gui:IsA("TextBox") then
		tweenProps.TextTransparency = 1
		tweenProps.TextStrokeTransparency = 1
	elseif gui:IsA("ImageLabel") or gui:IsA("ImageButton") then
		tweenProps.ImageTransparency = 1
	else
		return
	end

	for _, v in pairs(gui:GetChildren()) do
		Roblox.fadeAway(v, duration, level + 1)
	end


	if level == 0 then
		coroutine.wrap(function()
			Roblox.waitForTween(gui, tweenInfo, tweenProps)
			gui:Destroy()
		end)()
	else
		Roblox.tween(gui, tweenInfo, tweenProps)
	end
end

function Roblox.setModelAnchored(model, anchored)
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Anchored = anchored
		end
	end
end

function Roblox.setModelLocalVisible(model, visible)
	for _, part in pairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.LocalTransparencyModifier = visible and 0 or 1
		elseif part:IsA("SurfaceGui") then
			part.Enabled = visible
		elseif part:IsA("Decal") then
			part.Transparency = visible and 0 or 1
		end
	end
end

function Roblox.forAllTagged(tagName, enterFunc, exitFunc)
	for _, obj in pairs(CollectionService:GetTagged(tagName)) do
		if enterFunc then
			enterFunc(obj, tagName)
		end
	end
	if enterFunc then
		CollectionService:GetInstanceAddedSignal(tagName):Connect(function(obj) enterFunc(obj, tagName) end)
	end
	if exitFunc then
		CollectionService:GetInstanceRemovedSignal(tagName):Connect(function(obj) exitFunc(obj, tagName) end)
	end
end

function Roblox.getHumanoidFromCharacterPart(part)
	local currentNode = part
	while currentNode do
		local humanoid = currentNode:FindFirstChildOfClass("Humanoid")
		if humanoid then return humanoid end
		currentNode = currentNode.Parent
	end
	return nil
end

local addEsEndings = {
	s = true,
	sh = true,
	ch = true,
	x = true,
	z = true
}
local vowels = {
	a = true,
	e = true,
	i = true,
	o = true,
	u = true
}
function Roblox.formatPlural(num, name, wordOnly)
	if num ~= 1 then
		local lastTwo = name:sub(-2):lower()
		local lastOne = name:sub(-1):lower()

		local suffix = "s"
		if addEsEndings[lastTwo] or addEsEndings[lastOne] then
			suffix = "es"
		elseif lastOne == "o" and #lastTwo == 2 then
			local secondToLast = lastTwo:sub(1, 1)
			if not vowels[secondToLast] then
				suffix = "es"
			end
		end
		name = name .. suffix
	end
	if not wordOnly then
		return ("%s %s"):format(Roblox.formatInteger(num), name)
	else
		return name
	end
end

function Roblox.formatNumberTight(number)
	local order = math.log10(number)
	if order >= 3 and order < 6 then
		return ("%.1fK"):format(number / (10^3))
	end
	if order >= 6 and order < 9 then
		return ("%.1fM"):format(number / (10^6))
	end
	if order >= 9 then
		return ("%.1fB"):format(number / (10^9))
	end

	return tostring(math.floor(number + 0.5))
end

function Roblox.formatInteger(amount)
	amount = math.floor(amount + 0.5)
	local formatted = amount
	local numMatches
	repeat
		formatted, numMatches = string.gsub(formatted, "^(-?%d+)(%d%d%d)", "%1,%2")
	until numMatches == 0
	return formatted
end

function Roblox.round(val, decimal)
	if decimal then
		return math.floor((val * 10 ^ decimal) + 0.5) / (10 ^ decimal)
	else
		return math.floor(val + 0.5)
	end
end

function Roblox.formatNumber(number)
	local result, integral, fractional

	integral, fractional = math.modf(number)
	result = Roblox.formatInteger(integral)

	if fractional ~= 0 then
		result = result .. "." .. string.sub(tostring(math.abs(fractional)),3)
	end
	if number < 0 then
		result = "-" .. result
	end

	return result
end

function Roblox.isPointInsidePart(point, part)
	local localPos = part.CFrame:pointToObjectSpace(point)
	return math.abs(localPos.X) <= part.Size.X * 0.5 and math.abs(localPos.Y) <= part.Size.Y * 0.5 and math.abs(localPos.Z) <= part.Size.Z * 0.5
end

function Roblox.rayPlaneIntersect(ray, pointOnPlane, planeNormal)
	local Vd = planeNormal:Dot(ray.Direction)
	if Vd == 0 then -- parallel, no intersection
		return nil
	end

	local V0 = planeNormal:Dot(pointOnPlane - ray.Origin)
	local t = V0 / Vd
	if t < 0 then --plane is behind ray origin, and thus there is no intersection
		return nil
	end

	return ray.Origin + ray.Direction * t
end

function Roblox.debugPrint(t, level)
	level = level or 0
	local tabs = string.rep("\t", level)
	if typeof(t) == "table" then
		for key, val in pairs(t) do
			print(tabs, key, "=", val)
			if typeof(val) == "table" then
				Roblox.debugPrint(val, level + 1)
			end
		end
	end
end

local function findInstanceImpl(root, path, getChildFunc)
	local currentInstance = root

	while true do
		local nextChildName
		local nextSeparator = path:find("%.")
		if not nextSeparator then
			nextChildName = path
		else
			nextChildName = path:sub(1, nextSeparator - 1)
			path = path:sub(nextSeparator + 1)
		end

		local child = getChildFunc(currentInstance, nextChildName)
		if child then
			currentInstance = child
		else
			return nil
		end
	end
end

local function findFirstChildImpl(parent, childName)
	return parent:FindFirstChild(childName)
end
local function waitForChildImpl(parent, childName)
	return parent:WaitForChild(childName)
end

function Roblox.findInstance(root, path)
	return findInstanceImpl(root, path, findFirstChildImpl)
end

function Roblox.waitForInstance(root, path)
	return findInstanceImpl(root, path, waitForChildImpl)
end

function Roblox.penetrateCast(ray, ignoreList)
	debug.profilebegin("penetrateCast")
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, Vector3.new(0, 1, 0), Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and (not hitPart.CanCollide or CollectionService:HasTag(hitPart, "DroppedItemPart") or CollectionService:HasTag(hitPart, "Hidden")) and hitPart.Parent:FindFirstChildOfClass("Humanoid") == nil then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	debug.profileend()
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function Roblox.posInGuiObject(pos, guiObject)
	local guiMin = guiObject.AbsolutePosition
	local guiMax = guiMin + guiObject.AbsoluteSize
	return pos.X >= guiMin.X and pos.X <= guiMax.X and pos.Y >= guiMin.Y and pos.Y <= guiMax.Y
end

function Roblox.getUTCTime()
	local dateInfo = os.date("!*t")
	return string.format("%04d-%02d-%02d %02d:%02d:%02d", dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.min, dateInfo.sec)
end

function Roblox.getUTCTimestamp()
	return os.time(os.date("!*t"))
end

local DURATION_TOKENS = {
	{ "years",   "y",  31536000 },
	{ "months",  "mo", 2592000 },
	{ "weeks",   "w",  604800 },
	{ "days",    "d",  86400 },
	{ "hours",   "h",  3600 },
	{ "minutes", "m",  60 },
	{ "seconds", "s",  1 },
}
function Roblox.parseDurationInSeconds(inputStr)
	local tokensFound = {}
	local totalDurationSeconds = 0
	for _, tokenInfo in pairs(DURATION_TOKENS) do
		local numFound = string.match(inputStr, "(%d+)" .. tokenInfo[2])
		if numFound then
			local num = tonumber(numFound) or 0
			if num > 0 then
				table.insert(tokensFound, string.format("%d %s", num, tokenInfo[1]))
			end
			totalDurationSeconds = totalDurationSeconds + (num * tokenInfo[3])
		end
	end

	local outputStr = table.concat(tokensFound, ", ")
	return totalDurationSeconds, outputStr
end

local random = Random.new()
function Roblox.chooseWeighted(choiceTable)
    local sum = 0
    for _, weight in pairs(choiceTable) do
        sum = sum + weight
    end

    local roll = random:NextNumber(0, 1)
    local choiceSum = 0
    for choiceName, weight in pairs(choiceTable) do
        local chance = weight / sum
        if roll >= choiceSum and roll < choiceSum + chance then
            return choiceName
        else
            choiceSum = choiceSum + chance
        end
    end

    return nil
end

function Roblox.hasMatchingTag(instance, tagPattern)
	for _, tagName in pairs(CollectionService:GetTags(instance)) do
		if tagName:match(tagPattern) ~= nil then
			return true
		end
	end
	return false
end

local highlightTweens = setmetatable({}, { __mode = 'k' })
function Roblox.showHighlight(instance, show)
	local highlightInstance = instance:FindFirstChild("Highlight")
	if not highlightInstance or not highlightInstance:IsA("ImageLabel") then
		return
	end

	local existingTween = highlightTweens[instance]
	if existingTween then
		if show then
			return
		else
			existingTween:Cancel()
			highlightTweens[instance] = nil
			highlightInstance.ImageTransparency = 1
		end
	else
		if not show then
			return
		else
			coroutine.wrap(function()
				highlightInstance.ImageTransparency = 1
				local newTween = TweenService:Create(highlightInstance, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut, 0, true), { ImageTransparency = 0 })
				highlightTweens[instance] = newTween
				while highlightTweens[instance] == newTween do
					newTween:Play()
					newTween.Completed:Wait()
				end
			end)()
		end
	end
end

function Roblox.getClickVerb(capitalize)
	local verb = "Click"
	if UserInputService.TouchEnabled then
		verb = "Tap"
	end

	if not capitalize then
		verb = verb:lower()
	end
	return verb
end

function Roblox.computeLaunchAngle(relativePoint, launchVelocity)
	local dx, dy = -relativePoint.Z, relativePoint.Y

	local g = workspace.Gravity
	local invRoot = (launchVelocity ^ 4) - (g * ((g * dx * dx) + (2 * dy * launchVelocity * launchVelocity)))
	if invRoot <= 0 then
		return math.pi / 4
	end

	local root = math.sqrt(invRoot)
	local angle1 = math.atan(((launchVelocity * launchVelocity) + root) / (g * dx))
	local angle2 = math.atan(((launchVelocity * launchVelocity) - root) / (g * dx))

	local chosenAngle = math.min(angle1, angle2)

	return chosenAngle
end

function Roblox.getClosestPointOnLine(line0, line1, point, doClamp)
	local lineVec = line1 - line0
	local pointFromLine0 = point - line0

	local dotProduct = lineVec:Dot(pointFromLine0)
	local t = dotProduct / (lineVec.Magnitude ^ 2)
	if doClamp ~= false then
		t = math.clamp(t, 0, 1)
	end
	local pointOnLine = line0:Lerp(line1, t)
	return pointOnLine, t, (point - pointOnLine).Magnitude
end

function Roblox.getClosestPointOnLines(referencePoint, lines)
	local closestPoint, closestDist, closestLine, closestT = nil, math.huge, nil, 0
	for i = 1, #lines do
		local lineA, lineB = lines[i][1], lines[i][2]

		local point, t, dist = Roblox.getClosestPointOnLine(lineA, lineB, referencePoint)
		if dist < closestDist then
			closestPoint = point
			closestDist = dist
			closestLine = i
			closestT = t
		end
	end

	return closestPoint, closestDist, closestLine, closestT
end

function Roblox.getPointInFrontOnLines(referencePoint, forwardOffset, lines)
	local closestPoint, _, closestLine, closestT = Roblox.getClosestPointOnLines(referencePoint, lines)
	if closestPoint then
		local pointOffset = closestPoint
		local offsetBudget = forwardOffset

		if closestLine == 1 and closestT == 0 then
			local beforeDist = (lines[1][1] - Roblox.getClosestPointOnLine(lines[1][1], lines[1][2], referencePoint, false)).Magnitude
			offsetBudget = offsetBudget - beforeDist
		end

		local lineDir = Vector3.new(0, 0, 0)
		while offsetBudget > 0 and closestLine <= #lines do
			local lineA, lineB = lines[closestLine][1], lines[closestLine][2]
			local lineVec = lineB - lineA
			local lineLength = lineVec.Magnitude
			local pointDistAlongLine = (pointOffset - lineA).Magnitude
			local distLeftOnLine = lineLength - pointDistAlongLine
			lineDir = lineVec.Unit

			if offsetBudget > distLeftOnLine then
				offsetBudget = offsetBudget - distLeftOnLine
				pointOffset = lineB
				closestLine = closestLine + 1
			else
				break
			end
		end
		pointOffset = pointOffset + lineDir * offsetBudget

		return pointOffset
	end
	return closestPoint
end

function Roblox.applySpread(unspreadDir, randomGenerator, minSpread, maxSpread)
	local spreadRotation = randomGenerator:NextNumber(-math.pi, math.pi)
	local spreadOffset = randomGenerator:NextNumber(minSpread, maxSpread)
	local spreadTransform = CFrame.fromAxisAngle(Vector3.new(math.cos(spreadRotation), math.sin(spreadRotation), 0), spreadOffset)
	local unspreadCFrame = CFrame.new(Vector3.new(), unspreadDir)
	return (unspreadCFrame * spreadTransform).LookVector
end

return Roblox
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="19">
          <Properties>
            <string name="Name">ShoulderCamera</string>
            <string name="Source"><![CDATA[local ContextActionService = game:GetService("ContextActionService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")

local UserGameSettings = UserSettings():GetService("UserGameSettings")

local LocalPlayer = Players.LocalPlayer
if RunService:IsClient() then
	while not LocalPlayer do
		Players.PlayerAdded:Wait()
		LocalPlayer = Players.LocalPlayer
	end
end
local Settings = UserSettings()
local GameSettings = Settings.GameSettings

local CAMERA_RENDERSTEP_NAME = "ShoulderCameraUpdate"
local ZOOM_ACTION_NAME = "ShoulderCameraZoom"
local SPRINT_ACTION_NAME = "ShoulderCameraSprint"
local CONTROLLABLE_HUMANOID_STATES = {
	[Enum.HumanoidStateType.Running] = true,
	[Enum.HumanoidStateType.RunningNoPhysics] = true,
	[Enum.HumanoidStateType.Freefall] = true,
	[Enum.HumanoidStateType.Jumping] = true,
	[Enum.HumanoidStateType.Swimming] = false,
	[Enum.HumanoidStateType.Landed] = true
}

-- Gamepad thumbstick utilities
local k = 0.5
local lowerK = 0.9
local function SCurveTransform(t)
	t = math.clamp(t, -1,1)
	if t >= 0 then
		return (k*t) / (k - t + 1)
	end
	return -((lowerK*-t) / (lowerK + t + 1))
end

local DEADZONE = 0.25
local function toSCurveSpace(t)
	return (1 + DEADZONE) * (2*math.abs(t) - 1) - DEADZONE
end

local function fromSCurveSpace(t)
	return t/2 + 0.5
end

-- Applies a nonlinear transform to the thumbstick position to serve as the acceleration for camera rotation.
-- See https://www.desmos.com/calculator/xw2ytjpzco for a visual reference.
local function gamepadLinearToCurve(thumbstickPosition)
	return Vector2.new(
		math.clamp(math.sign(thumbstickPosition.X) * fromSCurveSpace(SCurveTransform(toSCurveSpace(math.abs(thumbstickPosition.X)))), -1, 1),
		math.clamp(math.sign(thumbstickPosition.Y) * fromSCurveSpace(SCurveTransform(toSCurveSpace(math.abs(thumbstickPosition.Y)))), -1, 1))
end


-- Remove back accessories since they frequently block the camera
local function isBackAccessory(instance)
	if instance and instance:IsA("Accessory") then
		local handle = instance:WaitForChild("Handle", 5)
		if handle and handle:IsA("Part") then
			local bodyBackAttachment = handle:WaitForChild("BodyBackAttachment", 5)
			if bodyBackAttachment and bodyBackAttachment:IsA("Attachment") then
				return true
			end

			local waistBackAttachment = handle:WaitForChild("WaistBackAttachment", 5)
			if waistBackAttachment and waistBackAttachment:IsA("Attachment") then
				return true
			end
		end
	end

	return false
end

local function removeBackAccessoriesFromCharacter(character)
	for _, child in ipairs(character:GetChildren()) do
		coroutine.wrap(function()
			if isBackAccessory(child) then
				child:Destroy()
			end
		end)()
	end
end

local descendantAddedConnection = nil
local function onCharacterAdded(character)
	removeBackAccessoriesFromCharacter(character)
	descendantAddedConnection = character.DescendantAdded:Connect(function(descendant)
		coroutine.wrap(function()
			if isBackAccessory(descendant) then
				descendant:Destroy()
			end
		end)()
	end)
end

local function onCharacterRemoving(character)
	if descendantAddedConnection then
		descendantAddedConnection:Disconnect()
		descendantAddedConnection = nil
	end
end

-- Set up the Local Player
if RunService:IsClient() then
	if LocalPlayer.Character then
		onCharacterAdded(LocalPlayer.Character)
	end
	LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
	LocalPlayer.CharacterRemoving:Connect(onCharacterRemoving)
end


local ShoulderCamera = {}
ShoulderCamera.__index = ShoulderCamera
ShoulderCamera.SpringService = nil

function ShoulderCamera.new(weaponsSystem)
	local self = setmetatable({}, ShoulderCamera)
	self.weaponsSystem = weaponsSystem

	-- Configuration parameters (constants)
	self.fieldOfView = 70
	self.minPitch = math.rad(-75) -- min degrees camera can angle down
	self.maxPitch = math.rad(75) -- max degrees camera can cangle up
	self.normalOffset = Vector3.new(2.25, 2.25, 10.5) -- this is the camera's offset from the player
	self.zoomedOffsetDistance = 8 -- number of studs to zoom in from default offset when zooming
	self.normalCrosshairScale = 1
	self.zoomedCrosshairScale = 0.75
	self.defaultZoomFactor = 1
	self.canZoom = true
	self.zoomInputs = { Enum.UserInputType.MouseButton2, Enum.KeyCode.ButtonL2 }
	self.sprintInputs = { Enum.KeyCode.LeftShift }
	self.mouseRadsPerPixel = Vector2.new(1 / 480, 1 / 480)
	self.zoomedMouseRadsPerPixel = Vector2.new(1 / 1200, 1 / 1200)
	self.touchSensitivity = Vector2.new(1 / 100, 1 / 100)
	self.zoomedTouchSensitivity = Vector2.new(1 / 200, 1 / 200)
	self.touchDelayTime = 0.25 -- max time for a touch to count as a tap (to shoot the weapon instead of control camera),
	                           -- also the amount of time players have to start a second touch after releasing the first time to trigger automatic fire
	self.recoilDecay = 2 -- higher number means faster recoil decay rate
	self.rotateCharacterWithCamera = true
	self.gamepadSensitivityModifier = Vector2.new(0.85, 0.65)
	-- Walk speeds
	self.zoomWalkSpeed = 8
	self.normalWalkSpeed = 16
	self.sprintingWalkSpeed = 24

	-- Current state
	self.enabled = false
	self.yaw = 0
	self.pitch = 0
	self.currentCFrame = CFrame.new()
	self.currentOffset = self.normalOffset
	self.currentRecoil = Vector2.new(0, 0)
	self.currentMouseRadsPerPixel = self.mouseRadsPerPixel
	self.currentTouchSensitivity = self.touchSensitivity
	self.mouseLocked = true
	self.touchPanAccumulator = Vector2.new(0, 0) -- used for touch devices, represents amount the player has dragged their finger since starting a touch
	self.currentTool = nil
	self.sprintingInputActivated = false
	self.desiredWalkSpeed = self.normalWalkSpeed
	self.sprintEnabled = false -- true means player will move faster while doing sprint inputs
	self.slowZoomWalkEnabled = false -- true means player will move slower while doing zoom inputs
	self.desiredFieldOfView = self.fieldOfView
	-- Zoom variables
	self.zoomedFromInput = false -- true if player has performed input to zoom
	self.forcedZoomed = false -- ignores zoomedFromInput and canZoom
	self.zoomState = false -- true if player is currently zoomed in
	self.zoomAlpha = 0
	self.hasScope = false
	self.hideToolWhileZoomed = false
	self.currentZoomFactor = self.defaultZoomFactor
	self.zoomedFOV = self.fieldOfView
	-- Gamepad variables
	self.gamepadPan = Vector2.new(0, 0) -- essentially the amount the gamepad has moved from resting position
	self.movementPan = Vector2.new(0, 0) -- this is for movement (gamepadPan is for camera)
	self.lastThumbstickPos = Vector2.new(0, 0)
	self.lastThumbstickTime = nil
	self.currentGamepadSpeed = 0
	self.lastGamepadVelocity = Vector2.new(0, 0)

	-- Occlusion
	self.lastOcclusionDistance = 0
	self.lastOcclusionReachedTime = 0 -- marks the last time camera was at the true occlusion distance
	self.defaultTimeUntilZoomOut = 0
	self.timeUntilZoomOut = self.defaultTimeUntilZoomOut -- time after lastOcclusionReachedTime that camera will zoom out
	self.timeLastPoppedWayIn = 0 -- this holds the last time camera popped nearly into first person
	self.isZoomingOut = false
	self.tweenOutTime = 0.2
	self.curOcclusionTween = nil
	self.occlusionTweenObject = nil

	-- Side correction (when player is against a wall)
	self.sideCorrectionGoalVector = nil
	self.lastSideCorrectionMagnitude = 0
	self.lastSideCorrectionReachedTime = 0 -- marks the last time the camera was at the true correction distance
	self.revertSideCorrectionSpeedMultiplier = 2 -- speed at which camera reverts the side correction (towards 0 correction)
	self.defaultTimeUntilRevertSideCorrection = 0.75
	self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection -- time after lastSideCorrectionReachedTime that camera will revert the correction
	self.isRevertingSideCorrection = false

	-- Datamodel references
	self.eventConnections = {}
	self.raycastIgnoreList = {}
	self.currentCamera = nil
	self.currentCharacter = nil
	self.currentHumanoid = nil
	self.currentRootPart = nil
	self.controlModule = nil -- used to get player's touch input for moving character
	self.random = Random.new()

	return self
end

function ShoulderCamera:setEnabled(enabled)
	if self.enabled == enabled then
		return
	end
	self.enabled = enabled

	if self.enabled then
		RunService:BindToRenderStep(CAMERA_RENDERSTEP_NAME, Enum.RenderPriority.Camera.Value - 1, function(dt) self:onRenderStep(dt) end)
		ContextActionService:BindAction(ZOOM_ACTION_NAME, function(...) self:onZoomAction(...) end, false, unpack(self.zoomInputs))
		ContextActionService:BindAction(SPRINT_ACTION_NAME, function(...) self:onSprintAction(...) end, false, unpack(self.sprintInputs))

		table.insert(self.eventConnections, LocalPlayer.CharacterAdded:Connect(function(character) self:onCurrentCharacterChanged(character) end))
		table.insert(self.eventConnections, LocalPlayer.CharacterRemoving:Connect(function() self:onCurrentCharacterChanged(nil) end))
		table.insert(self.eventConnections, workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function() self:onCurrentCameraChanged(workspace.CurrentCamera) end))
		table.insert(self.eventConnections, UserInputService.InputBegan:Connect(function(inputObj, wasProcessed) self:onInputBegan(inputObj, wasProcessed) end))
		table.insert(self.eventConnections, UserInputService.InputChanged:Connect(function(inputObj, wasProcessed) self:onInputChanged(inputObj, wasProcessed) end))
		table.insert(self.eventConnections, UserInputService.InputEnded:Connect(function(inputObj, wasProcessed) self:onInputEnded(inputObj, wasProcessed) end))

		self:onCurrentCharacterChanged(LocalPlayer.Character)
		self:onCurrentCameraChanged(workspace.CurrentCamera)

		-- Make transition to shouldercamera smooth by facing in same direction as previous camera
		local cameraLook = self.currentCamera.CFrame.lookVector
		self.yaw = math.atan2(-cameraLook.X, -cameraLook.Z)
		self.pitch = math.asin(cameraLook.Y)

		self.currentCamera.CameraType = Enum.CameraType.Scriptable

		self:setZoomFactor(self.currentZoomFactor) -- this ensures that zoomedFOV reflecs currentZoomFactor

		workspace.CurrentCamera.CameraSubject = self.currentRootPart

		self.occlusionTweenObject = Instance.new("NumberValue")
		self.occlusionTweenObject.Name = "OcclusionTweenObject"
		self.occlusionTweenObject.Parent = script
		self.occlusionTweenObject.Changed:Connect(function(value)
			self.lastOcclusionDistance = value
		end)

		-- Sets up weapon system to use camera for raycast direction instead of gun look vector
		self.weaponsSystem.aimRayCallback = function()
			local cameraCFrame = self.currentCFrame
			return Ray.new(cameraCFrame.p, cameraCFrame.LookVector * 500)
		end
	else
		RunService:UnbindFromRenderStep(CAMERA_RENDERSTEP_NAME)
		ContextActionService:UnbindAction(ZOOM_ACTION_NAME)
		ContextActionService:UnbindAction(SPRINT_ACTION_NAME)

		if self.currentHumanoid then
			self.currentHumanoid.AutoRotate = true
		end

		if self.currentCamera then
			self.currentCamera.CameraType = Enum.CameraType.Custom
			self.currentCamera.CameraSubject = self.currentHumanoid -- Added to fix camera issues.
		end

		self:updateZoomState()

		self.yaw = 0
		self.pitch = 0

		for _, conn in pairs(self.eventConnections) do
			conn:Disconnect()
		end
		self.eventConnections = {}

		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
	end
end

function ShoulderCamera:onRenderStep(dt)
	if not self.enabled or
	   not self.currentCamera or
	   not self.currentCharacter or
	   not self.currentHumanoid or
	   not self.currentRootPart
	then
		return
	end

	-- Hide mouse and lock to center if applicable
	if self.mouseLocked and not GuiService:GetEmotesMenuOpen() then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
		UserInputService.MouseIconEnabled = false
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
	end

	-- Handle gamepad input
	self:processGamepadInput(dt)

	-- Smoothly zoom to desired values
	if self.hasScope then
		ShoulderCamera.SpringService:Target(self, 0.8, 8, { zoomAlpha = self.zoomState and 1 or 0 })
		ShoulderCamera.SpringService:Target(self.currentCamera, 0.8, 8, { FieldOfView = self.desiredFieldOfView })
	else
		ShoulderCamera.SpringService:Target(self, 0.8, 3, { zoomAlpha = self.zoomState and 1 or 0 })
		ShoulderCamera.SpringService:Target(self.currentCamera, 0.8, 3, { FieldOfView = self.desiredFieldOfView })
	end

	-- Handle walk speed changes
	if self.sprintEnabled or self.slowZoomWalkEnabled then
		self.desiredWalkSpeed = self.normalWalkSpeed
		if self.sprintEnabled and (self.sprintingInputActivated or self:sprintFromTouchInput() or self:sprintFromGamepadInput()) and not self.zoomState then
			self.desiredWalkSpeed = self.sprintingWalkSpeed
		end
		if self.slowZoomWalkEnabled and self.zoomAlpha > 0.1 then
			self.desiredWalkSpeed = self.zoomWalkSpeed
		end

		ShoulderCamera.SpringService:Target(self.currentHumanoid, 0.95, 4, { WalkSpeed = self.desiredWalkSpeed })
	end

	-- Initialize variables used for side correction, occlusion, and calculating camera focus/rotation
	local rootPartPos = self.currentRootPart.CFrame.Position
	local rootPartUnrotatedCFrame = CFrame.new(rootPartPos)
	local yawRotation = CFrame.Angles(0, self.yaw, 0)
	local pitchRotation = CFrame.Angles(self.pitch + self.currentRecoil.Y, 0, 0)
	local xOffset = CFrame.new(self.normalOffset.X, 0, 0)
	local yOffset = CFrame.new(0, self.normalOffset.Y, 0)
	local zOffset = CFrame.new(0, 0, self.normalOffset.Z)
	local collisionRadius = self:getCollisionRadius()
	local cameraYawRotationAndXOffset =
		yawRotation * 		-- First rotate around the Y axis (look left/right)
		xOffset 			-- Then perform the desired offset (so camera is centered to side of player instead of directly on player)
	local cameraFocus = rootPartUnrotatedCFrame * cameraYawRotationAndXOffset

	-- Handle/Calculate side correction when player is adjacent to a wall (so camera doesn't go in the wall)
	local vecToFocus = cameraFocus.p - rootPartPos
	local rayToFocus = Ray.new(rootPartPos, vecToFocus + (vecToFocus.Unit * collisionRadius))
	local hitPart, hitPoint, hitNormal = self:penetrateCast(rayToFocus, self.raycastIgnoreList)
	local currentTime = tick()
	local sideCorrectionGoalVector = Vector3.new() -- if nothing is adjacent to player, goal vector is (0, 0, 0)
	if hitPart then
		hitPoint = hitPoint + (hitNormal * collisionRadius)
		sideCorrectionGoalVector = hitPoint - cameraFocus.p
		if sideCorrectionGoalVector.Magnitude >= self.lastSideCorrectionMagnitude then -- make it easy for camera to pop closer to player (move left)
			if currentTime > self.lastSideCorrectionReachedTime + self.timeUntilRevertSideCorrection and self.lastSideCorrectionMagnitude ~= 0 then
				self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection * 2 -- double time until revert if popping in repeatedly
			elseif self.lastSideCorrectionMagnitude == 0 and self.timeUntilRevertSideCorrection ~= self.defaultTimeUntilRevertSideCorrection then
				self.timeUntilRevertSideCorrection = self.defaultTimeUntilRevertSideCorrection
			end
			self.lastSideCorrectionMagnitude = sideCorrectionGoalVector.Magnitude
			self.lastSideCorrectionReachedTime = currentTime
			self.isRevertingSideCorrection = false
		else
			self.isRevertingSideCorrection = true
		end
	elseif self.lastSideCorrectionMagnitude ~= 0 then
		self.isRevertingSideCorrection = true
	end
	if self.isRevertingSideCorrection then -- make it hard/slow for camera to revert side correction (move right)
		if sideCorrectionGoalVector.Magnitude > self.lastSideCorrectionMagnitude - 1 and sideCorrectionGoalVector.Magnitude ~= 0 then
			self.lastSideCorrectionReachedTime = currentTime -- reset timer if occlusion significantly increased since last frame
		end
		if currentTime > self.lastSideCorrectionReachedTime + self.timeUntilRevertSideCorrection then
			local sideCorrectionChangeAmount = dt * (vecToFocus.Magnitude) * self.revertSideCorrectionSpeedMultiplier
			self.lastSideCorrectionMagnitude = self.lastSideCorrectionMagnitude - sideCorrectionChangeAmount
			if sideCorrectionGoalVector.Magnitude >= self.lastSideCorrectionMagnitude then
				self.lastSideCorrectionMagnitude = sideCorrectionGoalVector.Magnitude
				self.lastSideCorrectionReachedTime = currentTime
				self.isRevertingSideCorrection = false
			end
		end
	end

	-- Update cameraFocus to reflect side correction
	cameraYawRotationAndXOffset = cameraYawRotationAndXOffset + (-vecToFocus.Unit * self.lastSideCorrectionMagnitude)
	cameraFocus = rootPartUnrotatedCFrame * cameraYawRotationAndXOffset
	self.currentCamera.Focus = cameraFocus

	-- Calculate and apply CFrame for camera
	local cameraCFrameInSubjectSpace =
		cameraYawRotationAndXOffset *
		pitchRotation * 	-- rotate around the X axis (look up/down)
		yOffset *			-- move camera up/vertically
		zOffset				-- move camera back
	self.currentCFrame = rootPartUnrotatedCFrame * cameraCFrameInSubjectSpace

	-- Move camera forward if zoomed in
	if self.zoomAlpha > 0 then
		local trueZoomedOffset = math.max(self.zoomedOffsetDistance - self.lastOcclusionDistance, 0) -- don't zoom too far in if already occluded
		self.currentCFrame = self.currentCFrame:lerp(self.currentCFrame + trueZoomedOffset * self.currentCFrame.LookVector.Unit, self.zoomAlpha)
	end

	self.currentCamera.CFrame = self.currentCFrame

	-- Handle occlusion
	local occlusionDistance = self.currentCamera:GetLargestCutoffDistance(self.raycastIgnoreList)
	if occlusionDistance > 1e-5 then
		occlusionDistance = occlusionDistance + collisionRadius
	end
	if occlusionDistance >= self.lastOcclusionDistance then -- make it easy for the camera to pop in towards the player
		if self.curOcclusionTween ~= nil then
			self.curOcclusionTween:Cancel()
			self.curOcclusionTween = nil
		end
		if currentTime > self.lastOcclusionReachedTime + self.timeUntilZoomOut and self.lastOcclusionDistance ~= 0 then
			self.timeUntilZoomOut = self.defaultTimeUntilZoomOut * 2 -- double time until zoom out if popping in repeatedly
		elseif self.lastOcclusionDistance == 0  and self.timeUntilZoomOut ~= self.defaultTimeUntilZoomOut then
			self.timeUntilZoomOut = self.defaultTimeUntilZoomOut
		end

		if occlusionDistance / self.normalOffset.Z > 0.8 and self.timeLastPoppedWayIn == 0 then
			self.timeLastPoppedWayIn = currentTime
		end

		self.lastOcclusionDistance = occlusionDistance
		self.lastOcclusionReachedTime = currentTime
		self.isZoomingOut = false
	else -- make it hard/slow for camera to zoom out
		self.isZoomingOut = true
		if occlusionDistance > self.lastOcclusionDistance - 2 and occlusionDistance ~= 0 then -- reset timer if occlusion significantly increased since last frame
			self.lastOcclusionReachedTime = currentTime
		end

		-- If occlusion pops camera in to almost first person for a short time, pop out instantly
		if currentTime < self.timeLastPoppedWayIn + self.defaultTimeUntilZoomOut and self.lastOcclusionDistance / self.normalOffset.Z > 0.8 then
			self.lastOcclusionDistance = occlusionDistance
			self.lastOcclusionReachedTime = currentTime
			self.isZoomingOut = false
		elseif currentTime >= self.timeLastPoppedWayIn + self.defaultTimeUntilZoomOut and self.timeLastPoppedWayIn ~= 0 then
			self.timeLastPoppedWayIn = 0
		end
	end

	-- Update occlusion amount if timeout time has passed
	if currentTime >= self.lastOcclusionReachedTime + self.timeUntilZoomOut and not self.zoomState then
		if self.curOcclusionTween == nil then
			self.occlusionTweenObject.Value = self.lastOcclusionDistance
			local tweenInfo = TweenInfo.new(self.tweenOutTime)
			local goal = {}
			goal.Value = self.lastOcclusionDistance - self.normalOffset.Z
			self.curOcclusionTween = TweenService:Create(self.occlusionTweenObject, tweenInfo, goal)
			self.curOcclusionTween:Play()
		end
	end

	-- Apply occlusion to camera CFrame
	local currentOffsetDir = self.currentCFrame.LookVector.Unit
	self.currentCFrame = self.currentCFrame + (currentOffsetDir * self.lastOcclusionDistance)
	self.currentCamera.CFrame = self.currentCFrame

	-- Apply recoil decay
	self.currentRecoil = self.currentRecoil - (self.currentRecoil * self.recoilDecay * dt)

	if self:isHumanoidControllable() and self.rotateCharacterWithCamera then
		self.currentHumanoid.AutoRotate = false
		self.currentRootPart.CFrame = CFrame.Angles(0, self.yaw, 0) + self.currentRootPart.Position -- rotate character to be upright and facing the same direction as camera
		self:applyRootJointFix()
	else
		self.currentHumanoid.AutoRotate = true
	end

	self:handlePartTransparencies()
	self:handleTouchToolFiring()
end

-- This function keeps the held weapon from bouncing up and down too much when you move
function ShoulderCamera:applyRootJointFix()
	if self.rootJoint then
		local translationScale = self.zoomState and Vector3.new(0.25, 0.25, 0.25) or Vector3.new(0.5, 0.5, 0.5)
		local rotationScale = self.zoomState and 0.15 or 0.2
		local rootRotation = self.rootJoint.Part0.CFrame - self.rootJoint.Part0.CFrame.Position
		local rotation = self.rootJoint.Transform - self.rootJoint.Transform.Position
		local yawRotation = CFrame.Angles(0, self.yaw, 0)
		local leadRotation = rootRotation:toObjectSpace(yawRotation)
		local rotationFix = self.rootRigAttach.CFrame
		if self:isHumanoidControllable() then
			rotationFix = self.rootJoint.Transform:inverse() * leadRotation * rotation:Lerp(CFrame.new(), 1 - rotationScale) + (self.rootJoint.Transform.Position * translationScale)
		end

		self.rootJoint.C0 = CFrame.new(self.rootJoint.C0.Position, self.rootJoint.C0.Position + rotationFix.LookVector.Unit)
	end
end

function ShoulderCamera:sprintFromTouchInput()
	local moveVector = nil
	local activeController = nil
	local activeControllerIsTouch = nil
	if self.controlModule then
		moveVector = self.controlModule:GetMoveVector()
		activeController = self.controlModule:GetActiveController()
	end
	if moveVector and activeController then
		activeControllerIsTouch = activeController.thumbstickFrame ~= nil or activeController.thumbpadFrame ~= nil
	end

	if activeControllerIsTouch then
		return (moveVector and moveVector.Magnitude >= 0.9)
	else
		return false
	end
end

function ShoulderCamera:sprintFromGamepadInput()
	return self.movementPan.Magnitude > 0.9
end

function ShoulderCamera:onCurrentCharacterChanged(character)
	self.currentCharacter = character
	if self.currentCharacter then
		self.raycastIgnoreList[1] = self.currentCharacter
		self.currentHumanoid = character:WaitForChild("Humanoid")
		self.currentRootPart = character:WaitForChild("HumanoidRootPart")

		self.rootRigAttach = self.currentRootPart:WaitForChild("RootRigAttachment")
		self.rootJoint = character:WaitForChild("LowerTorso"):WaitForChild("Root")
		self.currentWaist = character:WaitForChild("UpperTorso"):WaitForChild("Waist")
		self.currentWrist = character:WaitForChild("RightHand"):WaitForChild("RightWrist")
		self.wristAttach0 = character:WaitForChild("RightLowerArm"):WaitForChild("RightWristRigAttachment")
		self.wristAttach1 = character:WaitForChild("RightHand"):WaitForChild("RightWristRigAttachment")
		self.rightGripAttachment = character:WaitForChild("RightHand"):WaitForChild("RightGripAttachment")

		self.currentTool = character:FindFirstChildOfClass("Tool")

		self.eventConnections.humanoidDied = self.currentHumanoid.Died:Connect(function()
			self.zoomedFromInput = false
			self:updateZoomState()
		end)
		self.eventConnections.characterChildAdded = character.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then
				self.currentTool = child
				self:updateZoomState()
			end
		end)
		self.eventConnections.characterChildRemoved = character.ChildRemoved:Connect(function(child)
			if child:IsA("Tool") and self.currentTool == child then
				self.currentTool = character:FindFirstChildOfClass("Tool")
				self:updateZoomState()
			end
		end)

		if Players.LocalPlayer then
			local PlayerScripts = Players.LocalPlayer:FindFirstChild("PlayerScripts")
			if PlayerScripts then
				local PlayerModule = PlayerScripts:FindFirstChild("PlayerModule")
				if PlayerModule then
					self.controlModule = require(PlayerModule:FindFirstChild("ControlModule"))
				end
			end
		end
	else
		if self.eventConnections.humanoidDied then
			self.eventConnections.humanoidDied:Disconnect()
			self.eventConnections.humanoidDied = nil
		end
		if self.eventConnections.characterChildAdded then
			self.eventConnections.characterChildAdded:Disconnect()
			self.eventConnections.characterChildAdded = nil
		end
		if self.eventConnections.characterChildRemoved then
			self.eventConnections.characterChildRemoved:Disconnect()
			self.eventConnections.characterChildRemoved = nil
		end

		self.currentTool = nil
		self.currentHumanoid = nil
		self.currentRootPart = nil
		self.controlModule = nil
	end
end

function ShoulderCamera:onCurrentCameraChanged(camera)
	if self.currentCamera == camera then
		return
	end

	self.currentCamera = camera

	if self.currentCamera then
		self.raycastIgnoreList[2] = self.currentCamera

		if self.eventConnections.cameraTypeChanged then
			self.eventConnections.cameraTypeChanged:Disconnect()
			self.eventConnections.cameraTypeChanged = nil
		end
		self.eventConnections.cameraTypeChanged = self.currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
			if self.enabled then
				self.currentCamera.CameraType = Enum.CameraType.Scriptable
			end
		end)
	end
end

function ShoulderCamera:isHumanoidControllable()
	if not self.currentHumanoid then
		return false
	end
	local humanoidState = self.currentHumanoid:GetState()
	return CONTROLLABLE_HUMANOID_STATES[humanoidState] == true
end

function ShoulderCamera:getCollisionRadius()
	if not self.currentCamera then
		return 0
	end
	local viewportSize = self.currentCamera.ViewportSize
	local aspectRatio = viewportSize.X / viewportSize.Y
	local fovRads = math.rad(self.fieldOfView)
	local imageHeight = math.tan(fovRads) * math.abs(self.currentCamera.NearPlaneZ)
	local imageWidth = imageHeight * aspectRatio

	local cornerPos = Vector3.new(imageWidth, imageHeight, self.currentCamera.NearPlaneZ)
	return cornerPos.Magnitude
end

function ShoulderCamera:penetrateCast(ray, ignoreList)
	local tries = 0
	local hitPart, hitPoint, hitNormal, hitMaterial = nil, ray.Origin + ray.Direction, Vector3.new(0, 1, 0), Enum.Material.Air
	while tries < 50 do
		tries = tries + 1
		hitPart, hitPoint, hitNormal, hitMaterial = workspace:FindPartOnRayWithIgnoreList(ray, ignoreList, false, true)
		if hitPart and not hitPart.CanCollide then
			table.insert(ignoreList, hitPart)
		else
			break
		end
	end
	return hitPart, hitPoint, hitNormal, hitMaterial
end

function ShoulderCamera:getRelativePitch()
	if self.currentRootPart then
		local pitchRotation = CFrame.Angles(self.pitch, 0, 0)
		local relativeRotation = self.currentRootPart.CFrame:toObjectSpace(pitchRotation)
		local relativeLook = relativeRotation.lookVector

		local angle = math.asin(relativeLook.Y)
		return math.clamp(angle, self.minPitch, self.maxPitch)
	end
	return self.pitch
end

function ShoulderCamera:getCurrentFieldOfView()
	if self.zoomState then
		return self.zoomedFOV
	else
		return self.fieldOfView
	end
end

function ShoulderCamera:handlePartTransparencies()
	local partsLookup = {}
	local accoutrementsLookup = {}

	for _, child in pairs(self.currentCharacter:GetChildren()) do
		local hidden = false
		if child:IsA("BasePart") then
			hidden = partsLookup[child.Name] == true
			child.LocalTransparencyModifier = hidden and 1 or 0
		elseif child:IsA("Accoutrement") then
			local descendants = child:GetDescendants()
			local accoutrementParts = {}
			for _, desc in pairs(descendants) do
				if desc:IsA("Attachment") and accoutrementsLookup[desc.Name] then
					hidden = true
				elseif desc:IsA("BasePart") then
					table.insert(accoutrementParts, desc)
				end
			end
			for _, part in pairs(accoutrementParts) do
				part.LocalTransparencyModifier = hidden and 1 or 0
			end
		elseif child:IsA("Tool") then
			hidden = self.zoomState and (self.hasScope or self.hideToolWhileZoomed)
			for _, part in pairs(child:GetDescendants()) do
				if part:IsA("BasePart") then
					part.LocalTransparencyModifier = hidden and 1 or 0
				end
			end
		end
	end
end

function ShoulderCamera:setSprintEnabled(enabled)
	self.sprintEnabled = enabled
end

function ShoulderCamera:setSlowZoomWalkEnabled(enabled)
	self.slowZoomWalkEnabled = enabled
end

function ShoulderCamera:setHasScope(hasScope)
	if self.hasScope == hasScope then
		return
	end

	self.hasScope = hasScope
	self:updateZoomState()
end

function ShoulderCamera:onSprintAction(actionName, inputState, inputObj)
	self.sprintingInputActivated = inputState == Enum.UserInputState.Begin
end


-- Zoom related functions

function ShoulderCamera:isZoomed()
	return self.zoomState
end

function ShoulderCamera:setHideToolWhileZoomed(hide)
	self.hideToolWhileZoomed = hide
end

function ShoulderCamera:setZoomFactor(zoomFactor)
	self.currentZoomFactor = zoomFactor
	local nominalFOVRadians = math.rad(self.fieldOfView)
	local nominalImageHeight = math.tan(nominalFOVRadians / 2)
	local zoomedImageHeight = nominalImageHeight / self.currentZoomFactor
	self.zoomedFOV = math.deg(math.atan(zoomedImageHeight) * 2)
	self:updateZoomState()
end

function ShoulderCamera:resetZoomFactor()
	self:setZoomFactor(self.defaultZoomFactor)
end

function ShoulderCamera:setForceZoomed(zoomed)
	if self.forcedZoomed == zoomed then return end
	self.forcedZoomed = zoomed
	self:updateZoomState()
end

function ShoulderCamera:setZoomedFromInput(zoomedFromInput)
	if self.zoomedFromInput == zoomedFromInput or (self.currentHumanoid and self.currentHumanoid:GetState() == Enum.HumanoidStateType.Dead) then
		return
	end

	self.zoomedFromInput = zoomedFromInput
	self:updateZoomState()
end

function ShoulderCamera:updateZoomState()
	local isZoomed = self.forcedZoomed
	if self.canZoom and not self.forcedZoomed then
		isZoomed = self.zoomedFromInput
	end

	if not self.enabled or not self.currentTool then
		isZoomed = false
	end

	self.zoomState = isZoomed

	self.currentMouseRadsPerPixel = isZoomed and self.zoomedMouseRadsPerPixel or self.mouseRadsPerPixel
	self.currentTouchSensitivity = isZoomed and self.zoomedTouchSensitivity or self.touchSensitivity

	if self.weaponsSystem and self.weaponsSystem.gui then
		self.weaponsSystem.gui:setCrosshairScaleTarget(self.zoomState and self.zoomedCrosshairScale or self.normalCrosshairScale)
		self.weaponsSystem.gui:setCrosshairEnabled(not self.zoomState or not self.hasScope)
		self.weaponsSystem.gui:setScopeEnabled(self.zoomState and self.hasScope)
		if self.currentTool then
			self.currentTool.ManualActivationOnly = self.zoomState and self.hasScope and UserInputService.TouchEnabled
		end
	end

	if self.currentCamera then
		self.desiredFieldOfView = self:getCurrentFieldOfView()
	end
end

function ShoulderCamera:onZoomAction(actionName, inputState, inputObj)
	if not self.enabled or not self.canZoom or not self.currentCamera or not self.currentCharacter or not self.weaponsSystem.currentWeapon then
		self:setZoomedFromInput(false)
		return Enum.ContextActionResult.Pass
	end

	self:setZoomedFromInput(inputState == Enum.UserInputState.Begin)
	return Enum.ContextActionResult.Sink
end


-- Recoil related functions

function ShoulderCamera:setCurrentRecoilIntensity(x, y)
	self.currentRecoil = Vector2.new(x, y)
end

function ShoulderCamera:addRecoil(recoilAmount)
	self.currentRecoil = self.currentRecoil + recoilAmount
end


-- Input related functions

function ShoulderCamera:applyInput(yaw, pitch)
	local yInvertValue = UserGameSettings:GetCameraYInvertValue()
	self.yaw = self.yaw + yaw
	self.pitch = math.clamp(self.pitch + pitch * yInvertValue, self.minPitch, self.maxPitch)
end

function ShoulderCamera:processGamepadInput(dt)
	local gamepadPan = self.gamepadPan
	if gamepadPan then
		gamepadPan = gamepadLinearToCurve(gamepadPan)
		if gamepadPan.X == 0 and gamepadPan.Y == 0 then
			self.lastThumbstickTime = nil
			if self.lastThumbstickPos.X == 0 and self.lastThumbstickPos.Y == 0 then
				self.currentGamepadSpeed = 0
			end
		end

		local finalConstant = 0
		local currentTime = tick()

		if self.lastThumbstickTime then
			local elapsed = (currentTime - self.lastThumbstickTime) * 10
			self.currentGamepadSpeed = self.currentGamepadSpeed + (6 * ((elapsed ^ 2) / 0.7))

			if self.currentGamepadSpeed > 6 then self.currentGamepadSpeed = 6 end

			if self.lastGamepadVelocity then
				local velocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickTime)
				local velocityDeltaMag = (velocity - self.lastGamepadVelocity).Magnitude

				if velocityDeltaMag > 12 then
					self.currentGamepadSpeed = self.currentGamepadSpeed * (20 / velocityDeltaMag)
					if self.currentGamepadSpeed > 6 then
						self.currentGamepadSpeed = 6
					end
				end
			end

			finalConstant = GameSettings.GamepadCameraSensitivity * self.currentGamepadSpeed * dt
			self.lastGamepadVelocity = (gamepadPan - self.lastThumbstickPos) / (currentTime - self.lastThumbstickTime)
		end
		self.lastThumbstickPos = gamepadPan
		self.lastThumbstickTime = currentTime

		local yawInput = -gamepadPan.X * finalConstant * self.gamepadSensitivityModifier.X
		local pitchInput = finalConstant * gamepadPan.Y * GameSettings:GetCameraYInvertValue() * self.gamepadSensitivityModifier.Y

		self:applyInput(yawInput, pitchInput)
	end
end

function ShoulderCamera:handleTouchToolFiring()
	if self.touchObj then
		if self.lastTapEndTime then -- and not (self.zoomState and self.hasScope) then
			local touchTime = tick() - self.lastTapEndTime
			if touchTime < self.touchDelayTime and self.currentTool and self.touchPanAccumulator.Magnitude < 0.5 and not self.firingTool and not self.applyingTouchPan then
				self.firingTool = true
				self.currentTool:Activate()
			end
		end
	else
		if self.currentTool and self.firingTool then
			self.currentTool:Deactivate()
		end
		self.firingTool = false
	end
end

function ShoulderCamera:isTouchPositionForCamera(pos)
	if LocalPlayer then
		local guiObjects = LocalPlayer.PlayerGui:GetGuiObjectsAtPosition(pos.X, pos.Y)
		for _, guiObject in ipairs(guiObjects) do
			if guiObject.Name == "DynamicThumbstickFrame" then
				return false
			end
		end
		return true
	end
	return false
end

function ShoulderCamera:onInputBegan(inputObj, wasProcessed)
	if self.touchObj then
		self.touchObj = nil
		wasProcessed = false
	end

	if inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.UserInputType == Enum.UserInputType.Touch then
		local touchStartPos = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
		if not wasProcessed and self:isTouchPositionForCamera(touchStartPos) and not self.touchObj then
			self.touchObj = inputObj
			self.touchStartTime = tick()
			self.eventConnections.touchChanged = inputObj.Changed:Connect(function(prop)
				if prop == "Position" then
					local touchTime = tick() - self.touchStartTime

					local newTouchPos = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
					local delta = (newTouchPos - touchStartPos) * self.currentTouchSensitivity
					local yawInput = -delta.X
					local pitchInput = -delta.Y
					if self.touchPanAccumulator.Magnitude > 0.01 and touchTime > self.touchDelayTime then
						if not self.applyingTouchPan then
							self.applyingTouchPan = true
							self.touchPanAccumulator = Vector2.new(0, 0)
						end
					end
					self:applyInput(yawInput, pitchInput)
					self.touchPanAccumulator = self.touchPanAccumulator + Vector2.new(yawInput, pitchInput)
					touchStartPos = newTouchPos
				end
			end)
		end
	end
end

function ShoulderCamera:onInputChanged(inputObj, wasProcessed)
	if inputObj.UserInputType == Enum.UserInputType.MouseMovement then
		local yawInput = -inputObj.Delta.X * self.currentMouseRadsPerPixel.X
		local pitchInput = -inputObj.Delta.Y * self.currentMouseRadsPerPixel.Y

		self:applyInput(yawInput, pitchInput)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(inputObj.Position.X, inputObj.Position.Y)
	end
end

function ShoulderCamera:onInputEnded(inputObj, wasProcessed)
	if inputObj.KeyCode == Enum.KeyCode.Thumbstick2 then
		self.gamepadPan = Vector2.new(0, 0)
	elseif inputObj.KeyCode == Enum.KeyCode.Thumbstick1 then
		self.movementPan = Vector2.new(0, 0)
	elseif inputObj.UserInputType == Enum.UserInputType.Touch then
		if self.touchObj == inputObj then
			if self.eventConnections and self.eventConnections.touchChanged then
				self.eventConnections.touchChanged:Disconnect()
				self.eventConnections.touchChanged = nil
			end

			local touchTime = tick() - self.touchStartTime
			if self.currentTool and self.firingTool then
				self.currentTool:Deactivate()
			elseif self.zoomState and self.hasScope and touchTime < self.touchDelayTime and not self.applyingTouchPan then
				self.currentTool:Activate() -- this makes sure to shoot the sniper with a single tap when it is zoomed in
				self.currentTool:Deactivate()
			end
			self.firingTool = false

			self.touchPanAccumulator = Vector2.new(0, 0)
			if touchTime < self.touchDelayTime and not self.applyingTouchPan then
				self.lastTapEndTime = tick()
			else
				self.lastTapEndTime = nil
			end
			self.applyingTouchPan = false

			self.gamepadPan = Vector2.new(0, 0)
			self.touchObj = nil
		end
	end
end

return ShoulderCamera
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="20">
          <Properties>
            <string name="Name">SpringService</string>
            <string name="Source"><![CDATA[-- SpringService.lua
-- Binds properties to spring simulations
-- @author Parker Stebbins <pstebbins@roblox.com>

local RunService = game:GetService('RunService')

local LinearSpring = {} do
	LinearSpring.__index = LinearSpring

	local pi = math.pi
	local exp = math.exp
	local sin = math.sin
	local cos = math.cos
	local sqrt = math.sqrt

	function LinearSpring.new(dampingRatio, frequency, goal)
		assert(
			dampingRatio*frequency >= 0,
			'No steady state solution for the given damping ratio & frequency'
		)

		return setmetatable(
			{
				d = dampingRatio, -- Damping ratio - Dimensionless
				f = frequency, -- Undamped frequency - Hertz
				g = goal, -- Goal position - Vector
				v = goal*0, -- Current velocity - Vector
			},
			LinearSpring
		)
	end

	function LinearSpring:setGoal(goal)
		self.g = goal
	end

	function LinearSpring:canSleep()
		return false -- @todo add sleeping
	end

	function LinearSpring:step(dt, p0)

		-- Problem: Advance the spring simulation by t seconds.
		-- Start by taking the ODE of a damped harmonic oscillator:
		--    f^2*(X[t] - g) + 2*d*f*X'[t] + X''[t] = 0
		-- Where X[t] is position at time t, g is desired position, f is angular frequency, and d is damping ratio.
		-- Apply some constant initial conditions:
		--    X[0] = p0
		--    X'[0] = v0
		-- The IVP can now be solved to obtain analytic expressions for X[t] and X'[t].
		-- The solution takes on one of three forms depending on the value of d.

		local d = self.d
		local f = self.f*pi*2 -- cycle/s -> rad/s
		local g = self.g
		local v0 = self.v

		local o = p0 - g
		local decay = exp(-dt*d*f)

		local p1, v1

		if d == 1 then -- Critically damped

			p1 = (v0*dt + o*(f*dt + 1))*decay + g
			v1 = (v0 - (o*f + v0)*(f*dt))*decay

		elseif d < 1 then -- Underdamped

			local c = sqrt(1 - d*d)

			local i = cos(dt*f*c)
			local j = sin(dt*f*c)

			-- @todo improve stability as d approaches 1

			p1 = (o*i + (v0 + o*(d*f))*j/(f*c))*decay + g
			v1 = (v0*(i*c) - (v0*d + o*f)*j)*(decay/c)

		else -- Overdamped

			local c = sqrt(d*d - 1)

			local r1 = -f*(d - c)
			local r2 = -f*(d + c)

			-- @todo improve stability as d approaches 1

			local co2 = (v0 - o*r1)/(2*f*c)
			local co1 = o - co2

			local e1 = co1*exp(r1*dt)
			local e2 = co2*exp(r2*dt)

			p1 = e1 + e2 + g
			v1 = r1*e1 + r2*e2
		end

		self.v = v1

		return p1
	end
end

local LinearValue = {} do
	LinearValue.__index = LinearValue

	function LinearValue.new(...)
		return setmetatable(
			{
				...
			},
			LinearValue
		)
	end

	function LinearValue:__add(rhs)
		-- vector + vector
		assert(type(rhs) == 'table')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i] + rhs[i]
		end

		return out
	end

	function LinearValue:__sub(rhs)
		-- vector - vector
		assert(type(rhs) == 'table')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i] - rhs[i]
		end

		return out
	end

	function LinearValue:__mul(rhs)
		-- vector*scalar
		assert(type(rhs) == 'number')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i]*rhs
		end

		return out
	end

	function LinearValue:__div(rhs)
		-- vector/scalar
		assert(type(rhs) == 'number')

		local out = LinearValue.new(unpack(self))
		for i = 1, #out do
			out[i] = out[i]/rhs
		end

		return out
	end
end

local springMetadata = {
	-- Defines a spring type with functions for converting to/from values that the spring can digest
	number = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value)
		end,
		fromIntermediate = function(value)
			return value[1]
		end,
	},

	UDim = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.Scale, value.Offset)
		end,
		fromIntermediate = function(value)
			return UDim.new(value[1], value[2])
		end,
	},

	UDim2 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			local x = value.X
			local y = value.Y
			return LinearValue.new(x.Scale, x.Offset, y.Scale, y.Offset)
		end,
		fromIntermediate = function(value)
			return UDim2.new(value[1], value[2], value[3], value[4])
		end,
	},

	Vector2 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.X, value.Y)
		end,
		fromIntermediate = function(value)
			return Vector2.new(value[1], value[2])
		end,
	},

	Vector3 = {
		springType = LinearSpring,
		toIntermediate = function(value)
			return LinearValue.new(value.X, value.Y, value.Z)
		end,
		fromIntermediate = function(value)
			return Vector3.new(value[1], value[2], value[3])
		end,
	},
}

local springStates = {} -- {[object] = {[property] = Spring}

local steppedEvent = RunService:IsClient() and RunService.RenderStepped or RunService.Heartbeat
steppedEvent:Connect(function(dt)
	for object, state in pairs(springStates) do
		for name, spring in pairs(state) do
			local oldValue = object[name]
			local meta = assert(springMetadata[typeof(oldValue)])

			local oldIntermediate = meta.toIntermediate(oldValue)
			local newIntermediate = spring:step(dt, oldIntermediate)

			if spring:canSleep() then
				state[name] = nil
			end

			object[name] = meta.fromIntermediate(newIntermediate)
		end

		if not next(state) then
			springStates[object] = nil
		end
	end
end)

local SpringService = {} do
	function SpringService:Target(object, dampingRatio, frequency, properties)
		local state = springStates[object]

		if not state then
			state = {}
			springStates[object] = state
		end

		for name, goal in pairs(properties) do
			local spring = state[name]

			local meta = assert(
				springMetadata[typeof(goal)],
				'Unsupported type: ' .. typeof(goal)
			)
			local intermediateGoal = meta.toIntermediate(goal)

			if spring then
				spring:setGoal(intermediateGoal)
			else
				spring = meta.springType.new(dampingRatio, frequency, intermediateGoal)
				state[name] = spring
			end
		end
	end

	function SpringService:Stop(object, property)
		if property then
			-- Unbind a property
			local state = springStates[object]
			if state then
				state[property] = nil
			end
		else
			-- Unbind all the properties
			springStates[object] = nil
		end
	end
end

return SpringService
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="21">
          <Properties>
            <string name="Name">WeaponsGui</string>
            <string name="Source">local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ContentProvider = game:GetService("ContentProvider")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer

local WeaponsSystemFolder = script.Parent.Parent
local WeaponData = WeaponsSystemFolder:WaitForChild("WeaponData")
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local SpringService = require(Libraries:WaitForChild("SpringService"))

local DirectionalIndicatorGuiManager = require(Libraries:WaitForChild("DirectionalIndicatorGuiManager"))
local DamageBillboardHandler = require(Libraries:WaitForChild("DamageBillboardHandler"))

local WeaponsSystemGuiTemplate = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("WeaponsSystemGui")

local AIM_ON_NORMAL = "rbxassetid://2804583948"
local AIM_OFF_NORMAL = "rbxassetid://2804597178"
local AIM_ON_PRESSED = "rbxassetid://2804598866"
local AIM_OFF_PRESSED = "rbxassetid://2804599869"

local FIRE_NORMAL = "rbxassetid://2804818047"
local FIRE_PRESSED = "rbxassetid://2804818076"

local WeaponsGui = {}
WeaponsGui.__index = WeaponsGui

function WeaponsGui.new(weaponsSystem)
	local self = setmetatable({}, WeaponsGui)
	self.weaponsSystem = weaponsSystem
	self.connections = {}
	self.enabled = false

	self.referenceViewportSize = Vector2.new(1000, 1000) -- viewport size that ui elements in scalingElementsFolder were designed on
	self.scaleWeight = 0.75 -- determines weight of scaling (a higher value increases the degree to which elements are scaled)
	self.originalScaleAmounts = {}

	self.crosshairDampingRatio = 0.9
	self.crosshairFrequency = 3
	self.crosshairScaleTarget = 1
	self.crosshairScale = 1
	self.crosshairWeaponScale = 1
	self.crosshairEnabled = true

	self.scopeEnabled = false
	self.isZoomed = false

	self.gui = WeaponsSystemGuiTemplate:Clone()
	self.gui.Enabled = false

	coroutine.wrap(function()
		self.scalingElementsFolder = self.gui:WaitForChild("ScalingElements")

		self.DirectionalIndicatorGuiManager = DirectionalIndicatorGuiManager.new(self)

		self.crosshairFrame = self.scalingElementsFolder:WaitForChild("Crosshair")
		self.crosshairBottom = self.crosshairFrame:WaitForChild("Bottom")
		self.crosshairLeft = self.crosshairFrame:WaitForChild("Left")
		self.crosshairRight = self.crosshairFrame:WaitForChild("Right")
		self.crosshairTop = self.crosshairFrame:WaitForChild("Top")
		self.origCrosshairScales = {} -- these will be used to size crosshair pieces when screen size changes
		self.origCrosshairScales[self.crosshairBottom] = Vector2.new(self.crosshairBottom.Size.X.Scale, self.crosshairBottom.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairLeft] = Vector2.new(self.crosshairLeft.Size.X.Scale, self.crosshairLeft.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairRight] = Vector2.new(self.crosshairRight.Size.X.Scale, self.crosshairRight.Size.Y.Scale)
		self.origCrosshairScales[self.crosshairTop] = Vector2.new(self.crosshairTop.Size.X.Scale, self.crosshairTop.Size.Y.Scale)
		self.crosshairNormalSize = self.crosshairFrame.AbsoluteSize

		self.hitMarker = self.scalingElementsFolder:WaitForChild("HitMarker"):WaitForChild("HitMarkerImage")

		self.scopeFrame = self.gui:WaitForChild("Scope")
		local scopeImage = self.scopeFrame:WaitForChild("ScopeImage")

		self.smallTouchscreen = self.gui:WaitForChild("SmallTouchscreen")
		self.largeTouchscreen = self.gui:WaitForChild("LargeTouchscreen")

		self.smallAimButton = self.smallTouchscreen:WaitForChild("AimButton")
		self.smallAimButton.Activated:Connect(function() self:onTouchAimButtonActivated() end)
		self.largeAimButton = self.largeTouchscreen:WaitForChild("AimButton")
		self.largeAimButton.Activated:Connect(function() self:onTouchAimButtonActivated() end)
		self.smallFireButton = self.smallTouchscreen:WaitForChild("FireButton")
		self.smallFireButton.InputBegan:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.Begin) end)
		self.smallFireButton.InputEnded:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.End) end)
		self.largeFireButton = self.largeTouchscreen:WaitForChild("FireButton")
		self.largeFireButton.InputBegan:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.Begin) end)
		self.largeFireButton.InputEnded:Connect(function(inputObj) self:onTouchFireButton(inputObj, Enum.UserInputState.End) end)

		self.smallFireButton.Visible = false
		self.largeFireButton.Visible = false

		self.gui.Parent = LocalPlayer:WaitForChild("PlayerGui")
		self.gui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function() self:onScreenSizeChanged() end)
		self:onScreenSizeChanged()

		WeaponData.OnClientEvent:Connect(function(cmd, otherPlayerPosition)
			if cmd == "HitByOtherPlayer" then
				self.DirectionalIndicatorGuiManager:ActivateDirectionalIndicator("DamageIndicator", otherPlayerPosition)
			end
		end)

		ContentProvider:PreloadAsync({
			self.crosshairBottom,
			self.crosshairLeft,
			self.crosshairRight,
			self.crosshairTop,
			scopeImage,
			self.smallAimButton,
			self.largeAimButton,
			self.smallFireButton,
			self.largeFireButton,
		})
	end)()

	return self
end

local function getJumpButton()
	if UserInputService.TouchEnabled then
		local touchGui = LocalPlayer.PlayerGui:WaitForChild("TouchGui")
		return touchGui.TouchControlFrame:FindFirstChild("JumpButton")
	end

	return nil
end

function WeaponsGui:onScreenSizeChanged()
	if self.smallTouchscreen and self.largeTouchscreen then
		if UserInputService.TouchEnabled then
			local isSmallScreen
			local jumpButton = getJumpButton()
			if jumpButton then
				isSmallScreen = jumpButton.Size.X.Offset &lt;= 70
			else
				isSmallScreen = self.gui.AbsoluteSize.Y &lt; 600
			end
			self.smallTouchscreen.Visible = isSmallScreen
			self.largeTouchscreen.Visible = not isSmallScreen
		else
			self.smallTouchscreen.Visible = false
			self.largeTouchscreen.Visible = false
		end
	end

	-- Scales all ui elements in scalingElementsFolder based on current screen size relative to self.referenceViewportSize
	local viewportSize = workspace.CurrentCamera.ViewportSize
	for _, child in pairs(self.scalingElementsFolder:GetChildren()) do
		self:updateScale(child, viewportSize)
	end

	self.crosshairNormalSize = self.crosshairFrame.AbsoluteSize

	-- Update crosshair sizes...they must use offset because crosshairFrame changes size frequently
	self.crosshairBottom.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairBottom].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairBottom].Y * self.crosshairNormalSize.Y)
	self.crosshairLeft.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairLeft].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairLeft].Y * self.crosshairNormalSize.Y)
	self.crosshairRight.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairRight].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairRight].Y * self.crosshairNormalSize.Y)
	self.crosshairTop.Size = UDim2.new(0, self.origCrosshairScales[self.crosshairTop].X * self.crosshairNormalSize.X, 0, self.origCrosshairScales[self.crosshairTop].Y * self.crosshairNormalSize.Y)
end

-- This scales the scale amount non-linearly according to scaleWeight
function WeaponsGui:getWeightedScaleAmount(originalScaleAmount, newScreenDim, referenceScreenDim)
	return (1 - self.scaleWeight) * originalScaleAmount * referenceScreenDim / newScreenDim + self.scaleWeight * originalScaleAmount
end

function WeaponsGui:updateScale(guiObject, viewportSize)
	if guiObject:IsA("GuiObject") then
		local xScale = guiObject.Size.X.Scale
		local yScale = guiObject.Size.Y.Scale
		if xScale ~= 0 or yScale ~= 0 or self.originalScaleAmounts[guiObject] ~= nil then
			if self.originalScaleAmounts[guiObject] == nil then
				self.originalScaleAmounts[guiObject] = Vector2.new(xScale, yScale)
			end

			xScale = self:getWeightedScaleAmount(self.originalScaleAmounts[guiObject].X, viewportSize.X, self.referenceViewportSize.X)
			yScale = self:getWeightedScaleAmount(self.originalScaleAmounts[guiObject].Y, viewportSize.Y, self.referenceViewportSize.Y)
			guiObject.Size = UDim2.new(xScale, 0, yScale, 0)
		end
		return -- makes it so only the most outer container will be scaled
	end

	for _, child in ipairs(guiObject:GetChildren()) do
		self:updateScale(child, viewportSize)
	end
end

function WeaponsGui:setEnabled(enabled)
	if self.enabled == enabled then
		return
	end

	self.enabled = enabled
	if self.enabled then
		self.connections.renderStepped = RunService.RenderStepped:Connect(function(dt) self:onRenderStepped(dt) end)
	else
		self:setZoomed(false)

		for _, v in pairs(self.connections) do
			v:Disconnect()
		end
		self.connections = {}
	end

	if self.gui then
		self.gui.Enabled = self.enabled
	end
end

function WeaponsGui:setCrosshairEnabled(crosshairEnabled)
	if self.crosshairEnabled == crosshairEnabled then
		return
	end

	self.crosshairEnabled = crosshairEnabled
	if self.crosshairFrame then
		self.crosshairFrame.Visible = self.crosshairEnabled
	end
	if self.hitMarker then
		self.hitMarker.ImageTransparency = 1
		self.hitMarker.Visible = self.crosshairEnabled
	end
end

function WeaponsGui:setScopeEnabled(scopeEnabled)
	if self.scopeEnabled == scopeEnabled then
		return
	end

	self.scopeEnabled = scopeEnabled
	if self.scopeFrame then
		self.scopeFrame.Visible = self.scopeEnabled
	end

	local jumpButton = getJumpButton()

	if self.scopeEnabled then
		self.smallFireButton.Visible = true
		self.largeFireButton.Visible = true

		if jumpButton then
			jumpButton.Visible = false
		end
	else
		self.smallFireButton.Visible = false
		self.largeFireButton.Visible = false

		if jumpButton then
			jumpButton.Visible = true
		end
	end
end

function WeaponsGui:setCrosshairWeaponScale(scale)
	if self.crosshairWeaponScale == scale then
		return
	end

	self.crosshairWeaponScale = scale
end

function WeaponsGui:setCrosshairScaleTarget(target, dampingRatio, frequency)
	if typeof(dampingRatio) == "number" then
		self.crosshairDampingRatio = dampingRatio
	end
	if typeof(frequency) == "number" then
		self.crosshairFrequency = frequency
	end
	if self.crosshairScaleTarget == target then
		return
	end

	self.crosshairScaleTarget = target
	SpringService:Target(self, self.crosshairDampingRatio, self.crosshairFrequency, { crosshairScale = self.crosshairScaleTarget })
end

function WeaponsGui:setCrosshairScale(scale)
	if self.crosshairScale == scale then
		return
	end

	self.crosshairScale = scale
	SpringService:Target(self, self.crosshairDampingRatio, self.crosshairFrequency, { crosshairScale = self.crosshairScaleTarget })
end

function WeaponsGui:OnHitOtherPlayer(damage, humanoidHit) -- show hit indicator, then fade
	self.hitMarker.ImageTransparency = 0
	local tweenInfo = TweenInfo.new(0.8)
	local goal = {}
	goal.ImageTransparency = 1
	local tween = TweenService:Create(self.hitMarker, tweenInfo, goal)
	tween:Play()

	DamageBillboardHandler:ShowDamageBillboard(damage, humanoidHit.Parent:FindFirstChild("Head"))
end

function WeaponsGui:onRenderStepped(dt)
	if not self.enabled then
		return
	end
	if not self.gui then
		return
	end

	if self.crosshairFrame and self.crosshairEnabled then
		local crosshairSize = self.crosshairNormalSize * self.crosshairScale * self.crosshairWeaponScale
		self.crosshairFrame.Size = UDim2.new(0, crosshairSize.X, 0, crosshairSize.Y)
	end
end

function WeaponsGui:setZoomed(zoomed)
	if zoomed == self.isZoomed then
		return
	end

	self.isZoomed = zoomed
	local normalImage = self.isZoomed and AIM_OFF_NORMAL or AIM_ON_NORMAL
	local pressedImage = self.isZoomed and AIM_OFF_PRESSED or AIM_ON_PRESSED

	if self.smallAimButton then
		self.smallAimButton.Image = normalImage
		self.smallAimButton.PressedImage = pressedImage
	end
	if self.largeAimButton then
		self.largeAimButton.Image = normalImage
		self.largeAimButton.PressedImage = pressedImage
	end

	if self.weaponsSystem.camera then
		self.weaponsSystem.camera:setForceZoomed(self.isZoomed)
	end
end

function WeaponsGui:onTouchAimButtonActivated()
	self:setZoomed(not self.isZoomed)
end

function WeaponsGui:onTouchFireButton(inputObj, inputState)
	local currentWeapon = self.weaponsSystem.currentWeapon
	if currentWeapon and currentWeapon.instance and currentWeapon.instance:IsA("Tool") then
		if inputObj.UserInputState == Enum.UserInputState.Begin then
			currentWeapon.instance:Activate()
			if self.smallFireButton then
				self.smallFireButton.Image = FIRE_PRESSED
			end
			if self.largeFireButton then
				self.largeFireButton.Image = FIRE_PRESSED
			end

			inputObj:GetPropertyChangedSignal("UserInputState"):Connect(function()
				if inputObj.UserInputState == Enum.UserInputState.End then
					currentWeapon.instance:Deactivate()
					if self.smallFireButton then
						self.smallFireButton.Image = FIRE_NORMAL
					end
					if self.largeFireButton then
						self.largeFireButton.Image = FIRE_NORMAL
					end
				end
			end)
		end
	end
end

return WeaponsGui</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="22">
          <Properties>
            <string name="Name">ancestorHasTag</string>
            <string name="Source">local CollectionService = game:GetService("CollectionService")

local function ancestorHasTag(instance, tag)
	local currentInstance = instance
	while currentInstance do
		if CollectionService:HasTag(currentInstance, tag) then
			return true
		else
			currentInstance = currentInstance.Parent
		end
	end

	return false
end

return ancestorHasTag</string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="23">
        <Properties>
          <string name="Name">NetworkingCallbacks</string>
          <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local IsServer = RunService:IsServer()
local LocalPlayer = (not IsServer) and Players.LocalPlayer or nil

local NetworkingCallbacks = {}
NetworkingCallbacks.WeaponsSystem = nil

function NetworkingCallbacks.WeaponFired(player, instance, fireInfo)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)

	if weapon and weaponType then
		if weapon.instance == instance and weaponType.CanBeFired and weapon.player == player then
			weapon:onFired(player, fireInfo, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloadRequest(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded then
			weapon:reload(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloaded(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded and player ~= nil and player ~= LocalPlayer then
			weapon:onReloaded(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponReloadCanceled(player, instance)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanBeReloaded and player ~= LocalPlayer then
			weapon:cancelReload(player, true)
		end
	end
end

function NetworkingCallbacks.WeaponHit(player, instance, hitInfo)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)
	if weapon then
		if weapon.instance == instance and weaponType.CanHit then
			if IsServer then
				weapon:onHit(hitInfo)
			end
		end
	end
end

function NetworkingCallbacks.WeaponActivated(player, instance, activated)
	local WeaponsSystem = NetworkingCallbacks.WeaponsSystem
	if not WeaponsSystem then
		return
	end

	local weapon = WeaponsSystem.getWeaponForInstance(instance)
	local weaponType = getmetatable(weapon)

	if weapon and weaponType then
		if weapon.instance == instance and weapon.player == player then
			weapon:setActivated(activated, true)
		end
	end
end

return NetworkingCallbacks
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="24">
        <Properties>
          <string name="Name">ServerWeaponsScript</string>
          <string name="Source">local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local curWeaponsSystemFolder = script.Parent
local weaponsSystemFolder = ReplicatedStorage:FindFirstChild("WeaponsSystem")
local weaponsSystemInitialized = false

local function initializeWeaponsSystemAssets()
	if not weaponsSystemInitialized then
		-- Enable/make visible all necessary assets
		local effectsFolder = weaponsSystemFolder.Assets.Effects
		local partNonZeroTransparencyValues = {
			["BulletHole"] = 1, ["Explosion"] = 1, ["Pellet"] = 1, ["Scorch"] = 1,
			["Bullet"] = 1, ["Plasma"] = 1, ["Railgun"] = 1,
		}
		local decalNonZeroTransparencyValues = { ["ScorchMark"] = 0.25 }
		local particleEmittersToDisable = { ["Smoke"] = true }
		local imageLabelNonZeroTransparencyValues = { ["Impact"] = 0.25 }
		for _, descendant in pairs(effectsFolder:GetDescendants()) do
			if descendant:IsA("BasePart") then
				if partNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.Transparency = partNonZeroTransparencyValues[descendant.Name]
				else
					descendant.Transparency = 0
				end
			elseif descendant:IsA("Decal") then
				descendant.Transparency = 0
				if decalNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.Transparency = decalNonZeroTransparencyValues[descendant.Name]
				else
					descendant.Transparency = 0
				end
			elseif descendant:IsA("ParticleEmitter") then
				descendant.Enabled = true
				if particleEmittersToDisable[descendant.Name] ~= nil then
					descendant.Enabled = false
				else
					descendant.Enabled = true
				end
			elseif descendant:IsA("ImageLabel") then
				if imageLabelNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.ImageTransparency = imageLabelNonZeroTransparencyValues[descendant.Name]
				else
					descendant.ImageTransparency = 0
				end
			end
		end
		
		weaponsSystemInitialized = true
	end
end

if weaponsSystemFolder == nil then
	weaponsSystemFolder = curWeaponsSystemFolder:Clone()
	initializeWeaponsSystemAssets()
	weaponsSystemFolder.Parent = ReplicatedStorage
end

if ServerScriptService:FindFirstChild("ServerWeaponsScript") == nil then
	script.Parent = ServerScriptService
	initializeWeaponsSystemAssets()

	local WeaponsSystem = require(weaponsSystemFolder.WeaponsSystem)
	if not WeaponsSystem.doingSetup and not WeaponsSystem.didSetup then
		WeaponsSystem.setup()
	end
	
	local function setupClientWeaponsScript(player)
		local clientWeaponsScript = player.PlayerGui:FindFirstChild("ClientWeaponsScript")
		if clientWeaponsScript == nil then
			clientWeaponsScript = weaponsSystemFolder.ClientWeaponsScript:Clone()
			clientWeaponsScript.Parent = player.PlayerGui
		end
	end
	
	Players.PlayerAdded:Connect(function(player)
		setupClientWeaponsScript(player)
	end)
	
	for _, player in ipairs(Players:GetPlayers()) do
		setupClientWeaponsScript(player)
	end
end

if curWeaponsSystemFolder.Name == "WeaponsSystem" then
	curWeaponsSystemFolder:Destroy()
end</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="25">
        <Properties>
          <string name="Name">WeaponTypes</string>
        </Properties>
        <Item class="ModuleScript" referent="26">
          <Properties>
            <string name="Name">BowWeapon</string>
            <string name="Source">local RunService = game:GetService("RunService")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent

local WeaponTypes = WeaponsSystemFolder:WaitForChild("WeaponTypes")
local BulletWeapon = require(WeaponTypes:WaitForChild("BulletWeapon"))

local BowWeapon = {}
BowWeapon.__index = BowWeapon
setmetatable(BowWeapon, BulletWeapon)

BowWeapon.CanAimDownSights = true
BowWeapon.CanBeFired = true
BowWeapon.CanBeReloaded = true
BowWeapon.CanHit = true

function BowWeapon.new(weaponsSystem, instance)
	local self = BulletWeapon.new(weaponsSystem, instance)
	setmetatable(self, BowWeapon)

	self.hasArrow = true

	self.arrowPart = self.instance:FindFirstChild("Arrow", true)
	self.armsPart = self.instance:FindFirstChild("Arms", true)
	if self.armsPart then
		self.armsMesh = self.armsPart:FindFirstChildOfClass("SpecialMesh")

		self.tightOffsetValue = self.armsPart:FindFirstChild("TightOffset")
		self.tightScaleValue = self.armsPart:FindFirstChild("TightScale")

		self.looseOffsetValue = self.armsPart:FindFirstChild("LooseOffset")
		self.looseScaleValue = self.armsPart:FindFirstChild("LooseScale")

		self.leftLooseAttach = self.armsPart:FindFirstChild("LeftLoose")
		self.rightLooseAttach = self.armsPart:FindFirstChild("RightLoose")

		self.leftTightAttach = self.armsPart:FindFirstChild("LeftTight")
		self.rightTightAttach = self.armsPart:FindFirstChild("RightTight")

		self.leftString0 = self.armsPart:FindFirstChild("LeftString0")
		self.rightString0 = self.armsPart:FindFirstChild("RightString0")
	end

	self.string1 = self.instance:FindFirstChild("String1", true)
	self.stringLooseAttach = self.instance:FindFirstChild("StringLoose", true)
	self.stringTightAttach = self.instance:FindFirstChild("StringTight", true)

	self:setHasArrow(false)

	return self
end

function BowWeapon:renderCharge()
	if self.armsMesh and self.looseOffsetValue and self.looseScaleValue and self.tightOffsetValue and self.tightScaleValue then
		local looseOffset, tightOffset = self.looseOffsetValue.Value, self.tightOffsetValue.Value
		local looseScale, tightScale = self.looseScaleValue.Value, self.tightScaleValue.Value

		self.armsMesh.Offset = looseOffset:Lerp(tightOffset, self.charge)
		self.armsMesh.Scale = looseScale:Lerp(tightScale, self.charge)
	end

	if self.leftString0 and self.leftLooseAttach and self.leftTightAttach then
		self.leftString0.CFrame = self.leftLooseAttach.CFrame:lerp(self.leftTightAttach.CFrame, self.charge)
	end
	if self.rightString0 and self.rightLooseAttach and self.rightTightAttach then
		self.rightString0.CFrame = self.rightLooseAttach.CFrame:lerp(self.rightTightAttach.CFrame, self.charge)
	end

	if self.string1 and self.stringLooseAttach and self.stringTightAttach then
		self.string1.CFrame = self.stringLooseAttach.CFrame:lerp(self.stringTightAttach.CFrame, self.charge)
	end
end

function BowWeapon:handleCharging(dt)
	if self.hasArrow then return end
	BulletWeapon.handleCharging(self, dt)

	if self.charge >= 1 then
		self:setHasArrow(true)
	end
end

function BowWeapon:onActivatedChanged()
	if not IsServer then
		if not self.activated then
			if self.didFire then
				self.didFire = false
			end
		end
	end
	BulletWeapon.onActivatedChanged(self)
end

function BowWeapon:isCharged()
	return self.hasArrow and self.charge >= 1
end

function BowWeapon:doLocalFire()
	BulletWeapon.doLocalFire(self)
	self:setHasArrow(false)
	self.didFire = true
end

function BowWeapon:setHasArrow(hasArrow)
	if self.hasArrow == hasArrow then
		return
	end

	self.hasArrow = hasArrow
	if self.arrowPart then
		self.arrowPart.Transparency = self.hasArrow and 0 or 1
	end
end

return BowWeapon</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="27">
          <Properties>
            <string name="Name">BulletWeapon</string>
            <string name="Source"><![CDATA[local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Debris = game:GetService("Debris")
local ContextActionService = game:GetService("ContextActionService")
local CollectionService = game:GetService("CollectionService")
local ContentProvider = game:GetService("ContentProvider")

local IsServer = RunService:IsServer()

local WeaponsSystemFolder = script.Parent.Parent
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local BaseWeapon = require(Libraries:WaitForChild("BaseWeapon"))
local Parabola = require(Libraries:WaitForChild("Parabola"))
local Roblox = require(Libraries:WaitForChild("Roblox"))

local Effects = WeaponsSystemFolder:WaitForChild("Assets"):WaitForChild("Effects")
local ShotsFolder = Effects:WaitForChild("Shots")
local HitMarksFolder = Effects:WaitForChild("HitMarks")
local CasingsFolder = Effects:WaitForChild("Casings")

local NO_BULLET_DECALS = false
local NO_BULLET_CASINGS = false

--The ignore list will fill up over time. This is how many seconds it will go before
--being refreshed in order to keep it from filling up with instances that aren't in
--the datamodel anymore.
local IGNORE_LIST_LIFETIME = 5

local MAX_BULLET_TIME = 10

local localRandom = Random.new()
local localPlayer = not IsServer and Players.LocalPlayer

local BulletWeapon = {}
BulletWeapon.__index = BulletWeapon
setmetatable(BulletWeapon, BaseWeapon)

BulletWeapon.CanAimDownSights = true
BulletWeapon.CanBeFired = true
BulletWeapon.CanBeReloaded = true
BulletWeapon.CanHit = true

function BulletWeapon.new(weaponsSystem, instance)
	local self = BaseWeapon.new(weaponsSystem, instance)
	setmetatable(self, BulletWeapon)

	self.usesCharging = false
	self.charge = 0
	self.chargeSoundPitchMin = 0.5
	self.chargeSoundPitchMax = 1

	self.triggerDisconnected = false
	self.startupFinished = false -- TODO: make startup time use a configuration value
	self.burstFiring = false
	self.burstIdx = 0
	self.nextFireTime = 0

	self.recoilIntensity = 0
	self.aimPoint = Vector3.new()

	self:addOptionalDescendant("tipAttach", "TipAttachment")

	self:addOptionalDescendant("boltMotor", "BoltMotor")
	self:addOptionalDescendant("boltMotorStart", "BoltMotorStart")
	self:addOptionalDescendant("boltMotorTarget", "BoltMotorTarget")

	self:addOptionalDescendant("chargeGlowPart", "ChargeGlow")
	self:addOptionalDescendant("chargeCompleteParticles", "ChargeCompleteParticles")
	self:addOptionalDescendant("dischargeCompleteParticles", "DischargeCompleteParticles")

	self:addOptionalDescendant("muzzleFlash0", "MuzzleFlash0")
	self:addOptionalDescendant("muzzleFlash1", "MuzzleFlash1")
	self:addOptionalDescendant("muzzleFlashBeam", "MuzzleFlash")

	self.hitMarkTemplate = HitMarksFolder:FindFirstChild(self:getConfigValue("HitMarkEffect", "BulletHole"))

	self.casingTemplate = CasingsFolder:FindFirstChild(self:getConfigValue("CasingEffect", ""))
	self:addOptionalDescendant("casingEjectPoint", "CasingEjectPoint")

	self.ignoreList = {}
	self.ignoreListRefreshTime = 0

	self:addOptionalDescendant("handAttach", "LeftHandAttachment")
	self.handAlignPos = nil
	self.handAlignRot = nil

	self.chargingParticles = {}
	self.instance.DescendantAdded:Connect(function(descendant)
		if descendant.Name == "ChargingParticles" and descendant:IsA("ParticleEmitter") then
			table.insert(self.chargingParticles, descendant)
		end
	end)
	for _, v in pairs(self.instance:GetDescendants()) do
		if v.Name == "ChargingParticles" and v:IsA("ParticleEmitter") then
			table.insert(self.chargingParticles, v)
		end
	end

	self:doInitialSetup()

	return self
end

function BulletWeapon:onEquippedChanged()
	BaseWeapon.onEquippedChanged(self)

	if not IsServer then
		if self.weaponsSystem.camera then
			if self.equipped then
				self.startupFinished = false
			end
		end

		if self.equipped then
			ContextActionService:BindAction("ReloadWeapon", function(...) self:onReloadAction(...) end, false, Enum.KeyCode.R, Enum.KeyCode.ButtonX)
		else
			ContextActionService:UnbindAction("ReloadWeapon")

			-- Stop charging/discharging sounds
			local chargingSound = self:getSound("Charging")
			local dischargingSound = self:getSound("Discharging")
			if chargingSound and chargingSound.Playing then
				chargingSound:Stop()
			end
			if dischargingSound and dischargingSound.Playing then
				dischargingSound:Stop()
			end
		end

		self.triggerDisconnected = false
	end
end

function BulletWeapon:onReloadAction(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin and not self.reloading then
		self:reload()
	end
end

function BulletWeapon:animateBoltAction(isOpen)
	if not self.boltMotor or not self.boltMotorStart or not self.boltMotorTarget then
		return
	end

	if isOpen then
		self:tryPlaySound("BoltOpenSound")
	else
		self:tryPlaySound("BoltCloseSound")
	end

	local actionMoveTime = isOpen and self:getConfigValue("ActionOpenTime", 0.025) or self:getConfigValue("ActionCloseTime", 0.075)
	local targetCFrame = isOpen and self.boltMotorTarget.CFrame or self.boltMotorStart.CFrame

	local boltTween = TweenService:Create(self.boltMotor, TweenInfo.new(actionMoveTime, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), { C0 = targetCFrame })
	boltTween:Play()
	boltTween.Completed:Wait()
end

function BulletWeapon:getRandomSeedForId(id)
	return id
end

-- This function is only called on clients
function BulletWeapon:simulateFire(firingPlayer, fireInfo)
	BaseWeapon.simulateFire(self, fireInfo)

	-- Play "Fired" sound
	if self.lastFireSound then
		self.lastFireSound:Stop()
	end
	self.lastFireSound = self:tryPlaySound("Fired", self:getConfigValue("FiredPlaybackSpeedRange", 0.1))

	-- Simulate each projectile/bullet fired from current weapon
	local numProjectiles = self:getConfigValue("NumProjectiles", 1)
	local randomGenerator = Random.new(self:getRandomSeedForId(fireInfo.id))
	for i = 1, numProjectiles do
		self:simulateProjectile(firingPlayer, fireInfo, i, randomGenerator)
	end

	-- Animate the bolt if the current gun has one
	local actionOpenTime = self:getConfigValue("ActionOpenTime", 0.025)
	if self.boltMotor then
		coroutine.wrap(function()
			self:animateBoltAction(true)
			wait(actionOpenTime)
			self:animateBoltAction(false)
		end)()
	end

	-- Eject bullet casings and play "CasingHitSound" (child of casing) sound if applicable for current weapon
	if not NO_BULLET_CASINGS and self.casingTemplate and self.casingEjectPoint then
		local casing = self.casingTemplate:Clone()
		casing.Anchored = false
		casing.Archivable = false
		casing.CFrame = self.casingEjectPoint.WorldCFrame
		casing.Velocity = self.casingEjectPoint.Parent.Velocity + (self.casingEjectPoint.WorldAxis * localRandom:NextNumber(self:getConfigValue("CasingEjectSpeedMin", 15), self:getConfigValue("CasingEjectSpeedMax", 18)))
		casing.Parent = workspace.CurrentCamera
		CollectionService:AddTag(casing, "WeaponsSystemIgnore")

		local casingHitSound = casing:FindFirstChild("CasingHitSound")
		if casingHitSound then
			local touchedConn = nil
			touchedConn = casing.Touched:Connect(function(hitPart)
				if not hitPart:IsDescendantOf(self.instance) then
					casingHitSound:Play()
					touchedConn:Disconnect()
					touchedConn = nil
				end
			end)
		end

		Debris:AddItem(casing, 2)
	end

	if self.player == Players.LocalPlayer then
		coroutine.wrap(function()
			-- Wait for "RecoilDelayTime" before adding recoil
			local startTime = tick()
			local recoilDelayTime = self:getConfigValue("RecoilDelayTime", 0.07)
			while tick() < startTime + recoilDelayTime do
				RunService.RenderStepped:Wait()
			end
			RunService.RenderStepped:Wait()

			-- Add recoil to camera
			local recoilMin, recoilMax = self:getConfigValue("RecoilMin", 0.05), self:getConfigValue("RecoilMax", 0.5)
			local intensityToAdd = randomGenerator:NextNumber(recoilMin, recoilMax)
			local xIntensity = math.sin(tick() * 2) * intensityToAdd * math.rad(0.05)
			local yIntensity = intensityToAdd * 0.025
			self.weaponsSystem.camera:addRecoil(Vector2.new(xIntensity, yIntensity))

			if not (self.weaponsSystem.camera:isZoomed() and self:getConfigValue("HasScope", false)) then
				self.recoilIntensity = math.clamp(self.recoilIntensity * 1 + (intensityToAdd / 10), 0.005, 1)
			end

			-- Make crosshair reflect recoil/spread amount
			local weaponsGui = self.weaponsSystem.gui
			if weaponsGui then
				weaponsGui:setCrosshairScale(1 + intensityToAdd)
			end
		end)()
	end
end

function BulletWeapon:getIgnoreList(includeLocalPlayer)
	local now = tick()
	local ignoreList = self.ignoreList
	if not ignoreList or now - self.ignoreListRefreshTime > IGNORE_LIST_LIFETIME then
		ignoreList = {
			self.instanceIsTool and self.instance.Parent or self.instance,
			workspace.CurrentCamera
		}
		if not RunService:IsServer() then
			if includeLocalPlayer and Players.LocalPlayer and Players.LocalPlayer.Character then
				table.insert(ignoreList, Players.LocalPlayer.Character)
			end
		end
		self.ignoreList = ignoreList
	end
	return ignoreList
end

-- This function is only called on clients
function BulletWeapon:simulateProjectile(firingPlayer, fireInfo, projectileIdx, randomGenerator)
	local localPlayerInitiatedShot = self.player == Players.LocalPlayer

	-- Retrieve config values
	local bulletSpeed = self:getConfigValue("BulletSpeed", 1000)
	local maxDistance = self:getConfigValue("MaxDistance", 2000)
	local trailLength = self:getConfigValue("TrailLength", nil)
	local trailLengthFactor = self:getConfigValue("TrailLengthFactor", 1)
	local showEntireTrailUntilHit = self:getConfigValue("ShowEntireTrailUntilHit", false)
	local gravityFactor = self:getConfigValue("GravityFactor", 0)
	local minSpread = self:getConfigValue("MinSpread", 0)
	local maxSpread = self:getConfigValue("MaxSpread", 0)
	local shouldMovePart = self:getConfigValue("ShouldMovePart", false)
	local explodeOnImpact = self:getConfigValue("ExplodeOnImpact", false)
	local blastRadius = self:getConfigValue("BlastRadius", 8)

	-- Cheat the origin of the shot back if gun tip in wall/object
	if self.tipAttach ~= nil then
		local tipCFrame = self.tipAttach.WorldCFrame
		local tipPos = tipCFrame.Position
		local tipDir = tipCFrame.LookVector
		local amountToCheatBack = math.abs((self.instance:FindFirstChild("Handle").Position - tipPos):Dot(tipDir)) + 1
		local gunRay = Ray.new(tipPos - tipDir.Unit * amountToCheatBack, tipDir.Unit * amountToCheatBack)
		local hitPart, hitPoint = Roblox.penetrateCast(gunRay, self:getIgnoreList(localPlayerInitiatedShot))
		if hitPart and math.abs((tipPos - hitPoint).Magnitude) > 0 then
			fireInfo.origin = hitPoint - tipDir.Unit * 0.1
			fireInfo.dir = tipDir.Unit
		end
	end

	local origin, dir = fireInfo.origin, fireInfo.dir

	dir = Roblox.applySpread(dir, randomGenerator, math.rad(minSpread), math.rad(maxSpread))

	-- Initialize variables for visuals/particle effects
	local bulletEffect = self.bulletEffectTemplate:Clone()
	bulletEffect.CFrame = CFrame.new(origin, origin + dir)
	bulletEffect.Parent = workspace.CurrentCamera
	CollectionService:AddTag(bulletEffect, "WeaponsSystemIgnore")

	local leadingParticles = bulletEffect:FindFirstChild("LeadingParticles", true)
	local attachment0 = bulletEffect:FindFirstChild("Attachment0")
	local trailParticles = nil
	if attachment0 then
		trailParticles = attachment0:FindFirstChild("TrailParticles")
	end

	local hitAttach = bulletEffect:FindFirstChild("HitEffect")
	local hitParticles = bulletEffect:FindFirstChild("HitParticles", true)
	local numHitParticles = self:getConfigValue("NumHitParticles", 3)
	local hitSound = bulletEffect:FindFirstChild("HitSound", true)
	local flyingSound = bulletEffect:FindFirstChild("Flying", true)

	local muzzleFlashTime = self:getConfigValue("MuzzleFlashTime", 0.03)
	local muzzleFlashShown = false

	local beamThickness0 = self:getConfigValue("BeamWidth0", 1.5)
	local beamThickness1 = self:getConfigValue("BeamWidth1", 1.8)
	local beamFadeTime = self:getConfigValue("BeamFadeTime", nil)

	-- Enable beam trails for projectile
	local beam0 = bulletEffect:FindFirstChild("Beam0")
	if beam0 then
		beam0.Enabled = true
	end
	local beam1 = bulletEffect:FindFirstChild("Beam1")
	if beam1 then
		beam1.Enabled = true
	end

	-- Emit muzzle particles
	local muzzleParticles = bulletEffect:FindFirstChild("MuzzleParticles", true)
	local numMuzzleParticles = self:getConfigValue("NumMuzzleParticles", 50)
	if muzzleParticles then
		muzzleParticles.Parent.CFrame = CFrame.new(origin, origin + dir)
		local numSteps = 5
		for _ = 1, numSteps do
			muzzleParticles.Parent.Velocity = Vector3.new(localRandom:NextNumber(-10, 10), localRandom:NextNumber(-10, 10), localRandom:NextNumber(-10, 10))
			muzzleParticles:Emit(numMuzzleParticles / numSteps)
		end
	end

	-- Show muzzle flash
	if self.tipAttach and self.muzzleFlash0 and self.muzzleFlash1 and self.muzzleFlashBeam and projectileIdx == 1 then
		local minFlashRotation, maxFlashRotation = self:getConfigValue("MuzzleFlashRotation0", -math.pi), self:getConfigValue("MuzzleFlashRotation1", math.pi)
		local minFlashSize, maxFlashSize = self:getConfigValue("MuzzleFlashSize0", 1), self:getConfigValue("MuzzleFlashSize1", 1)
		local flashRotation = localRandom:NextNumber(minFlashRotation, maxFlashRotation)
		local flashSize = localRandom:NextNumber(minFlashSize, maxFlashSize)
		local baseCFrame = self.tipAttach.CFrame * CFrame.Angles(0, 0, flashRotation)
		self.muzzleFlash0.CFrame = baseCFrame * CFrame.new(flashSize * -0.5, 0, 0) * CFrame.Angles(0, math.pi, 0)
		self.muzzleFlash1.CFrame = baseCFrame * CFrame.new(flashSize * 0.5, 0, 0) * CFrame.Angles(0, math.pi, 0)

		self.muzzleFlashBeam.Enabled = true
		self.muzzleFlashBeam.Width0 = flashSize
		self.muzzleFlashBeam.Width1 = flashSize
		muzzleFlashShown = true
	end

	-- Play projectile flying sound
	if flyingSound then
		flyingSound:Play()
	end

	-- Enable trail particles
	if trailParticles then
		trailParticles.Enabled = true
	end

	-- Set up parabola for projectile path
	local parabola = Parabola.new()
	parabola:setPhysicsLaunch(origin, dir * bulletSpeed, nil, 35 * -gravityFactor)
	-- More samples for higher gravity since path will be more curved but raycasts can only be straight lines
	if gravityFactor > 0.66 then
		parabola:setNumSamples(3)
	elseif gravityFactor > 0.33 then
		parabola:setNumSamples(2)
	else
		parabola:setNumSamples(1)
	end

	-- Set up/initialize variables used in steppedCallback
	local stepConn = nil
	local pTravelDistance = 0 -- projected travel distance so far if projectile never stops
	local startTime = tick()
	local didHit = false
	local stoppedMotion = false
	local stoppedMotionAt = 0
	local timeSinceStart = 0
	local flyingVisualEffectsFinished = false -- true if all particle effects shown while projectile is flying are done
	local visualEffectsFinishTime = math.huge
	local visualEffectsLingerTime = 0 -- max time any visual effect needs to finish
	if beamFadeTime then
		visualEffectsLingerTime = beamFadeTime
	end
	local hitInfo = {
		sid = fireInfo.id,
		pid = projectileIdx,
		maxDist = maxDistance,
		part = nil,
		p = nil,
		n = nil,
		m = Enum.Material.Air,
		d = 1e9,
	}

	local steppedCallback = function(dt)
		local now = tick()
		timeSinceStart = now - startTime

		local travelDist = bulletSpeed * dt -- distance projectile has travelled since last frame
		trailLength = trailLength or travelDist * trailLengthFactor

		-- Note: the next three variables are all in terms of distance from starting point (which should be tip of current weapon)
		local projBack = pTravelDistance - trailLength -- furthest back part of projectile (including the trail effect, so will be the start of the trail effect if any)
		local projFront = pTravelDistance -- most forward part of projectile
		local maxDist = hitInfo.maxDist or 0 -- before it collides, this is the max distance the projectile can travel. After it collides, this is the hit point

		-- This will make trailing beams render from tip of gun to wherever projectile is until projectile is destroyed
		if showEntireTrailUntilHit then
			projBack = 0
		end

		-- Validate projBack and projFront
		projBack = math.clamp(projBack, 0, maxDist)
		projFront = math.clamp(projFront, 0, maxDist)

		if not didHit then
			-- Check if bullet hit since last frame
			local castProjBack, castProjFront = projFront, projFront + travelDist
			parabola:setDomain(castProjBack, castProjFront)
			local hitPart, hitPoint, hitNormal, hitMaterial, hitT = parabola:findPart(self.ignoreList)

			if hitPart then
				didHit = true
				projFront = castProjBack + hitT * (castProjFront - castProjBack) -- set projFront to point along projectile arc where an object was hit
				parabola:setDomain(projBack, projFront) -- update parabola domain to match new projFront

				-- Update hitInfo
				hitInfo.part = hitPart
				hitInfo.p = hitPoint
				hitInfo.n = hitNormal
				hitInfo.m = hitMaterial
				hitInfo.d = (hitPoint - origin).Magnitude
				hitInfo.t = hitT
				hitInfo.maxDist = projFront -- since the projectile hit, maxDist is now the hitPoint instead of maxDistance

				-- Register hit on clients
				self:onHit(hitInfo)

				-- Notify the server that this projectile hit something from client that initiated the shot
				-- Show hit indicators on gui of client that shot projectile
				if localPlayerInitiatedShot then
					local hitInfoClone = {}
					for hitInfoKey, value in pairs(hitInfo) do
						hitInfoClone[hitInfoKey] = value
					end
					self.weaponsSystem.getRemoteEvent("WeaponHit"):FireServer(self.instance, hitInfoClone)
				end


				-- Deal with all effects that start/stop/change on hit

				-- Disable trail particles
				if trailParticles then
					trailParticles.Enabled = false
				end

				-- Stop bullet flying sound
				if flyingSound and flyingSound.IsPlaying then
					flyingSound:Stop()
				end

				-- Hide the actual projectile model
				if bulletEffect then
					bulletEffect.Transparency = 1
				end

				-- Stop emitting leading particles
				if leadingParticles then
					leadingParticles.Rate = 0
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, leadingParticles.Lifetime.Max)
				end

				-- Show the explosion on clients for explosive projectiles
				if explodeOnImpact then
					local explosion = Instance.new("Explosion")
					explosion.Position = hitPoint + (hitNormal * 0.5)
					explosion.BlastRadius = blastRadius
					explosion.BlastPressure = 0 -- no blast pressure because the real explosion happens on server
					explosion.ExplosionType = Enum.ExplosionType.NoCraters
					explosion.DestroyJointRadiusPercent = 0
					explosion.Visible = true
					if localPlayerInitiatedShot then
						-- Trigger hit indicators on client that initiated the shot if the explosion hit another player/humanoid
						explosion.Hit:Connect(function(explodedPart, hitDist)
							local humanoid = self.weaponsSystem.getHumanoid(explodedPart)
							if humanoid and
							   explodedPart.Name == "UpperTorso" and
							   humanoid:GetState() ~= Enum.HumanoidStateType.Dead and
							   self.weaponsSystem.gui and
							   explodedPart.Parent ~= self.player.Character and
							   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(humanoid), self.player)
							then
								self.weaponsSystem.gui:OnHitOtherPlayer(self:calculateDamage(hitInfo.d), humanoid)
							end
						end)
					end
					explosion.Parent = workspace
				end

				-- Make sure hitAttach is in correct position before showing hit effects
				if hitAttach and beam0 and beam0.Attachment1 then
					parabola:renderToBeam(beam0)
					hitAttach.CFrame = beam0.Attachment1.CFrame * CFrame.Angles(0, math.rad(90), 0)
				end

				-- Show hit particle effect
				local hitPartColor = hitPart and hitPart.Color or Color3.fromRGB(255, 255, 255)
				if hitPart and hitPart:IsA("Terrain") then
					hitPartColor = workspace.Terrain:GetMaterialColor(hitMaterial or Enum.Material.Sand)
				end
				if hitInfo.h and hitInfo.h:IsA("Humanoid") and hitParticles and numHitParticles > 0 and hitPart then
					-- Show particle effect for hitting a player/humanoid
					hitParticles.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
					hitParticles:Emit(numHitParticles)
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitParticles.Lifetime.Max)
				elseif (not hitInfo.h or not hitInfo.h:IsA("Humanoid")) and hitParticles and numHitParticles > 0 then
					-- Show particle effect for hitting anything else
					if hitPart and self:getConfigValue("HitParticlesUsePartColor", true) then
						local existingSeq = hitParticles.Color
						local newKeypoints = {}

						for i, keypoint in pairs(existingSeq.Keypoints) do
							local newColor = keypoint.Value
							if newColor == Color3.fromRGB(255, 0, 255) then
								newColor = hitPartColor
							end
							newKeypoints[i] = ColorSequenceKeypoint.new(keypoint.Time, newColor)
						end

						hitParticles.Color = ColorSequence.new(newKeypoints)
					end

					hitParticles:Emit(numHitParticles)
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitParticles.Lifetime.Max)
				end

				-- Play hit sound
				if hitSound then
					hitSound:Play()
					visualEffectsLingerTime = math.max(visualEffectsLingerTime, hitSound.TimeLength)
				end

				-- Manage/show decals, billboards, and models (such as an arrow) that appear where the projectile hit (only if the hit object was not a humanoid/player)
				local hitPointObjectSpace = hitPart.CFrame:pointToObjectSpace(hitPoint)
				local hitNormalObjectSpace = hitPart.CFrame:vectorToObjectSpace(hitNormal)
				if not NO_BULLET_DECALS and
				   hitPart and
				   not hitPart.Parent or not hitPart.Parent:FindFirstChildOfClass("Humanoid") and
				   hitPointObjectSpace and
				   hitNormalObjectSpace and
				   self.hitMarkTemplate
				then
					-- Clone hitMark (this contains all the decals/billboards/models to show on the hit surface)
					local hitMark = self.hitMarkTemplate:Clone()
					hitMark.Parent = hitPart
					CollectionService:AddTag(hitMark, "WeaponsSystemIgnore")

					-- Move/align hitMark to the hit surface
					local incomingVec = parabola:sampleVelocity(1).Unit
					if self:getConfigValue("AlignHitMarkToNormal", true) then
						-- Make hitMark face straight out from surface where projectile hit (good for decals)
						local forward = hitNormalObjectSpace
						local up = incomingVec
						local right = -forward:Cross(up).Unit
						up = forward:Cross(right)
						local orientationCFrame = CFrame.fromMatrix(hitPointObjectSpace + hitNormalObjectSpace * 0.05, right, up, -forward)
						hitMark.CFrame = hitPart.CFrame:toWorldSpace(orientationCFrame)
					else
						-- Make hitmark appear stuck in the hit surface from the direction the projectile came from (good for things like arrows)
						hitMark.CFrame = hitPart.CFrame * CFrame.new(hitPointObjectSpace, hitPointObjectSpace + hitPart.CFrame:vectorToObjectSpace(incomingVec))
					end

					-- Weld hitMark to the hitPart
					local weld = Instance.new("WeldConstraint")
					weld.Part0 = hitMark
					weld.Part1 = hitPart
					weld.Parent = hitMark

					-- Fade glow decal over time
					local glowDecal = hitMark:FindFirstChild("Glow")
					if glowDecal then
						coroutine.wrap(function()
							local heartbeat = RunService.Heartbeat
							for i = 0, 1, 1/60 do
								heartbeat:Wait()
								glowDecal.Transparency = (i ^ 2)
							end
						end)()
					end

					-- Set bullethole decal color and fade over time
					local bulletHole = hitMark:FindFirstChild("BulletHole")
					if bulletHole then
						bulletHole.Color3 = hitPartColor
						TweenService:Create(
							bulletHole,
							TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 4),
							{ Transparency = 1 }
						):Play()
					end

					-- Fade impact billboard's size and transparency over time
					local impactBillboard = hitMark:FindFirstChild("ImpactBillboard")
					if impactBillboard then
						local impact = impactBillboard:FindFirstChild("Impact")
						local impactTween = TweenService:Create(
							impact,
							TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0),
							{ Size = UDim2.new(1, 0, 1, 0) }
						)
						impactTween.Completed:Connect(function()
							TweenService:Create(
								impact,
								TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0),
								{ Size = UDim2.new(0.5, 0, 0.5, 0), ImageTransparency = 1 }
							):Play()
						end)
						impactTween:Play()
					end

					-- Destroy hitMark in 5 seconds
					Debris:AddItem(hitMark, 5)
				end

				flyingVisualEffectsFinished = true
				visualEffectsFinishTime = now + visualEffectsLingerTime
			end
		end

		-- Will enter this if-statement if projectile hit something or maxDistance has been reached
		if projFront >= maxDist then
			if not stoppedMotion then
				stoppedMotion = true
				stoppedMotionAt = now
			end

			-- Stop particle effects if projectile didn't hit anything and projBack has reached the end
			if projBack >= maxDist and not flyingVisualEffectsFinished then
				flyingVisualEffectsFinished = true
				visualEffectsFinishTime = now + visualEffectsLingerTime
			end
		end

		-- Update parabola domain
		parabola:setDomain(projBack, projFront)

		-- Continue updating pTravelDistance until projBack has reached maxDist (this helps with some visual effects)
		if projBack < maxDist then
			pTravelDistance = math.max(0, timeSinceStart * bulletSpeed)
		end


		-- Update visual effects each frame

		-- Update CFrame/velocity of projectile if the projectile uses a model (such as rocket or grenade)
		if shouldMovePart then
			local bulletPos = parabola:samplePoint(1)
			local bulletVelocity = parabola:sampleVelocity(1)
			bulletEffect.CFrame = CFrame.new(bulletPos, bulletPos + bulletVelocity)
			bulletEffect.Velocity = bulletVelocity.Unit * bulletSpeed
		end

		-- Update thickness and render trailing beams
		local thickness0 = beamThickness0
		local thickness1 = beamThickness1
		if beamFadeTime then
			-- Fade out trail beams if projectile is no longer moving (hit something or reached max distance)
			local timeSinceEnd = stoppedMotion and (now - stoppedMotionAt) or 0
			local fadeAlpha = math.clamp(timeSinceEnd / beamFadeTime, 0, 1)
			thickness0 = thickness0 * (1 - fadeAlpha)
			thickness1 = thickness1 * (1 - fadeAlpha)
		end
		if beam0 then
			beam0.Width0 = thickness0
			beam0.Width1 = thickness1
			parabola:renderToBeam(beam0)
		end
		if beam1 then
			beam1.Width0 = thickness0
			beam1.Width1 = thickness1
			parabola:renderToBeam(beam1)
		end

		-- Disable muzzle flash after muzzleFlashTime seconds have passed
		if muzzleFlashShown and timeSinceStart > muzzleFlashTime and self.muzzleFlashBeam then
			self.muzzleFlashBeam.Enabled = false
			muzzleFlashShown = false
		end

		-- Destroy projectile and attached visual effects when visual effects are done showing or max bullet time has been reached
		local timeSinceParticleEffectsFinished = now - visualEffectsFinishTime
		if (flyingVisualEffectsFinished and timeSinceParticleEffectsFinished > 0) or timeSinceStart > MAX_BULLET_TIME then
			if bulletEffect then
				bulletEffect:Destroy()
				bulletEffect = nil
			end

			stepConn:Disconnect()
		end
	end

	stepConn = RunService.Heartbeat:Connect(steppedCallback)

	-- Get rid of charge on chargeable weapons
	if not IsServer and self.usesCharging then
		self.charge = math.clamp(self.charge - self:getConfigValue("FireDischarge", 1), 0, 1)
	end
end

function BulletWeapon:calculateDamage(travelDistance)
	local zeroDamageDistance = self:getConfigValue("ZeroDamageDistance", 10000)
	local fullDamageDistance = self:getConfigValue("FullDamageDistance", 1000)
	local distRange = zeroDamageDistance - fullDamageDistance
	local falloff = math.clamp(1 - (math.max(0, travelDistance - fullDamageDistance) / math.max(1, distRange)), 0, 1)
	return math.max(self:getConfigValue("HitDamage", 10) * falloff, 0)
end

function BulletWeapon:applyDamage(hitInfo)
	local damage = self:calculateDamage(hitInfo.d)

	if damage <= 0 then
		return
	end

	self.weaponsSystem.doDamage(hitInfo.h, damage, nil, self.player)
end

function BulletWeapon:onHit(hitInfo)
	local hitPoint = hitInfo.p
	local hitNormal = hitInfo.n
	local hitPart = hitInfo.part

	if hitPart and hitPart.Parent then
		local humanoid = self.weaponsSystem.getHumanoid(hitPart)
		hitInfo.h = humanoid or hitPart

		if IsServer and
		   (not hitInfo.h:IsA("Humanoid") or
		   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(hitInfo.h), self.player))
		then
			self:applyDamage(hitInfo)
		elseif hitInfo.h:IsA("Humanoid") and
			hitInfo.h:GetState() ~= Enum.HumanoidStateType.Dead and
			self.weaponsSystem.gui and
			self.player == Players.LocalPlayer and
			self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(hitInfo.h), self.player)
		then
			-- Show hit indicators on gui of client that shot projectile if players are not on same team
			self.weaponsSystem.gui:OnHitOtherPlayer(self:calculateDamage(hitInfo.d), hitInfo.h)
		end
	end

	-- Create invisible explosion on server that deals damage to anything caught in the explosion
	if IsServer and self:getConfigValue("ExplodeOnImpact", false) then
		local blastRadius = self:getConfigValue("BlastRadius", 8)
		local blastPressure = self:getConfigValue("BlastPressure", 10000)
		local blastDamage = self:getConfigValue("BlastDamage", 100)

		local explosion = Instance.new("Explosion")
		explosion.Position = hitPoint + (hitNormal * 0.5)
		explosion.BlastRadius = blastRadius
		explosion.BlastPressure = blastPressure
		explosion.ExplosionType = Enum.ExplosionType.NoCraters
		explosion.DestroyJointRadiusPercent = 0
		explosion.Visible = false

		explosion.Hit:Connect(function(explodedPart, hitDist)
			local damageMultiplier = (1 - math.clamp((hitDist / blastRadius), 0, 1))
			local damageToDeal = blastDamage * damageMultiplier

			local humanoid = self.weaponsSystem.getHumanoid(explodedPart)
			if humanoid then
				if explodedPart.Name == "UpperTorso" and
				   humanoid:GetState() ~= Enum.HumanoidStateType.Dead and
				   self.weaponsSystem.playersOnDifferentTeams(self.weaponsSystem.getPlayerFromHumanoid(humanoid), self.player)
				then
					-- Do damage to players/humanoids
					self.weaponsSystem.doDamage(humanoid, damageToDeal, nil, self.player)
				end
			elseif not CollectionService:HasTag(explodedPart, "WeaponsSystemIgnore") then
				-- Do damage to a part (sends damage to breaking system)
				self.weaponsSystem.doDamage(explodedPart, damageToDeal, nil, self.player)
			end
		end)

		explosion.Parent = workspace
	end
end

function BulletWeapon:fire(origin, dir, charge)
	if not self:isCharged() then
		return
	end

	BaseWeapon.fire(self, origin, dir, charge)
end

function BulletWeapon:onFired(firingPlayer, fireInfo, fromNetwork)
	if not IsServer and firingPlayer == Players.LocalPlayer and fromNetwork then
		return
	end

	local cooldownTime = self:getConfigValue("ShotCooldown", 0.1)
	local fireMode = self:getConfigValue("FireMode", "Semiautomatic")
	local isSemiAuto = fireMode == "Semiautomatic"
	local isBurst = fireMode == "Burst"

	if isBurst and not self.burstFiring then
		self.burstIdx = 0
		self.burstFiring = true
	elseif isSemiAuto then
		self.triggerDisconnected = true
	end

	-- Calculate cooldown time for burst firing
	if self.burstFiring then
		self.burstIdx = self.burstIdx + 1
		if self.burstIdx >= self:getConfigValue("NumBurstShots", 3) then
			self.burstFiring = false
			self.triggerDisconnected = true
		else
			cooldownTime = self:getConfigValue("BurstShotCooldown", nil) or cooldownTime
		end
	end

	self.nextFireTime = tick() + cooldownTime

	BaseWeapon.onFired(self, firingPlayer, fireInfo, fromNetwork)
end

function BulletWeapon:onConfigValueChanged(valueName, newValue, oldValue)
	BaseWeapon.onConfigValueChanged(self, valueName, newValue, oldValue)
	if valueName == "ShotEffect" then
		self.bulletEffectTemplate = ShotsFolder:FindFirstChild(self:getConfigValue("ShotEffect", "Bullet"))
		if self.bulletEffectTemplate then
			local config = self.bulletEffectTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end

			local beam0 = self.bulletEffectTemplate:FindFirstChild("Beam0")
			if beam0 then
				coroutine.wrap(function()
					ContentProvider:PreloadAsync({ beam0 })
				end)()
			end
		end
	elseif valueName == "HitMarkEffect" then
		self.hitMarkTemplate = HitMarksFolder:FindFirstChild(self:getConfigValue("HitMarkEffect", "BulletHole"))
		if self.hitMarkTemplate then
			local config = self.hitMarkTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end
		end
	elseif valueName == "CasingEffect" then
		self.casingTemplate = CasingsFolder:FindFirstChild(self:getConfigValue("CasingEffect", ""))
		if self.casingTemplate then
			local config = self.casingTemplate:FindFirstChildOfClass("Configuration")
			if config then
				self:importConfiguration(config)
			end
		end
	elseif valueName == "ChargeRate" then
		self.usesCharging = newValue ~= nil
	end
end

function BulletWeapon:onActivatedChanged()
	BaseWeapon.onActivatedChanged(self)

	if not IsServer then
		-- Reload if no ammo left in clip
		if self.equipped and self:getAmmoInWeapon() <= 0 then
			self:reload()
			return
		end

		-- Fire weapon
		if self.activated and self.player == localPlayer and self:canFire() and tick() > self.nextFireTime then
			self:doLocalFire()
		end

		-- Reenable trigger after activated changes to false
		if not self.activated and self.triggerDisconnected and not self.burstFiring then
			self.triggerDisconnected = false
		end
	end
end

function BulletWeapon:onRenderStepped(dt)
	BaseWeapon.onRenderStepped(self, dt)
	if not self.tipAttach then return end
	if not self.equipped then return end

	local tipCFrame = self.tipAttach.WorldCFrame

	if self.player == Players.LocalPlayer then
		-- Retrieve aim point from camera and update player's aim animation
		local aimTrack = self:getAnimTrack(self:getConfigValue("AimTrack", "RifleAim"))
		local aimZoomTrack = self:getAnimTrack(self:getConfigValue("AimZoomTrack", "RifleAimDownSights"))
		if aimTrack then
			local aimDir = tipCFrame.LookVector

			local gunLookRay = Ray.new(tipCFrame.p, aimDir * 500)

			local _, gunHitPoint = Roblox.penetrateCast(gunLookRay, self.ignoreList)

			if self.weaponsSystem.aimRayCallback then
				local _, hitPoint = Roblox.penetrateCast(self.weaponsSystem.aimRayCallback(), self.ignoreList)
				self.aimPoint = hitPoint
			else
				self.aimPoint = gunHitPoint
			end

			if not aimTrack.IsPlaying and not self.reloading then
				aimTrack:Play(0.15)
				coroutine.wrap(function() -- prevent player from firing until gun is fully out
					wait(self:getConfigValue("StartupTime", 0.2))
					self.startupFinished = true
				end)()
			end

			if aimZoomTrack and not self.reloading then
				if not aimZoomTrack.IsPlaying then
					aimZoomTrack:Play(0.15)
				end
				aimZoomTrack:AdjustSpeed(0.001)
				if self.weaponsSystem.camera:isZoomed() then
					if aimTrack.WeightTarget ~= 0 then
						aimZoomTrack:AdjustWeight(1)
						aimTrack:AdjustWeight(0)
					end
				elseif aimTrack.WeightTarget ~= 1 then
					aimZoomTrack:AdjustWeight(0)
					aimTrack:AdjustWeight(1)
				end
			end

			local MIN_ANGLE = -80
			local MAX_ANGLE = 80
			local aimYAngle = math.deg(self.recoilIntensity)
			if self.weaponsSystem.camera.enabled then
				-- Gets pitch and recoil from camera to figure out how high/low to aim the gun
				aimYAngle = math.deg(self.weaponsSystem.camera:getRelativePitch() + self.weaponsSystem.camera.currentRecoil.Y + self.recoilIntensity)
			end
			local aimTimePos = 2 * ((aimYAngle - MIN_ANGLE) / (MAX_ANGLE - MIN_ANGLE))

			aimTrack:AdjustSpeed(0.001)
			aimTrack.TimePosition = math.clamp(aimTimePos, 0.001, 1.97)

			if aimZoomTrack then
				aimZoomTrack.TimePosition = math.clamp(aimTimePos, 0.001, 1.97)
			end

			-- Update recoil (decay over time)
			local recoilDecay = self:getConfigValue("RecoilDecay", 0.825)
			self.recoilIntensity = math.clamp(self.recoilIntensity * recoilDecay, 0, math.huge)
		else
			warn("no aimTrack")
		end
	end
end

function BulletWeapon:setChargingParticles(charge)
	local ratePerCharge = self:getConfigValue("ChargingParticlesRatePerCharge", 20)
	local rate = ratePerCharge * charge
	for _, v in pairs(self.chargingParticles) do
		v.Rate = rate
	end
end

function BulletWeapon:onStepped(dt)
	if not self.tipAttach then return end
	if not self.equipped then return end

	BaseWeapon.onStepped(self, dt)

	local now = tick()

	local chargingSound = self:getSound("Charging")
	local dischargingSound = self:getSound("Discharging")

	if self.usesCharging then
		-- Update charge amount
		local chargeBefore = self.charge
		self:handleCharging(dt)
		local chargeDelta = self.charge - chargeBefore

		-- Update charge particles
		if chargeDelta > 0 then
			self:setChargingParticles(self.charge)
		else
			self:setChargingParticles(0)
		end

		-- Play charging sounds
		if chargingSound then
			if chargingSound.Looped then
				if chargeDelta < 0 then
					chargingSound:Stop()
				else
					if not chargingSound.Playing and self.charge < 1 and chargeDelta > 0 then
						chargingSound:Play()
					end
					chargingSound.PlaybackSpeed = self.chargeSoundPitchMin + (self.charge * (self.chargeSoundPitchMax - self.chargeSoundPitchMin))
				end
			else
				if chargeDelta > 0 and self.charge <= 1 and not chargingSound.Playing then
					chargingSound.TimePosition = chargingSound.TimeLength * self.charge
					chargingSound:Play()
				elseif chargeDelta <= 0 and chargingSound.Playing then
					chargingSound:Stop()
				end
			end
		end
		if dischargingSound then
			if dischargingSound.Looped then
				if chargeDelta > 0 then
					dischargingSound:Stop()
				else
					if not dischargingSound.Playing and self.charge > 0 then
						dischargingSound:Play()
					end
					dischargingSound.PlaybackSpeed = self.chargeSoundPitchMin + (self.charge * (self.chargeSoundPitchMax - self.chargeSoundPitchMin))
				end
			else
				if chargeDelta < 0 and self.charge >= 0 and not dischargingSound.Playing then
					dischargingSound.TimePosition = dischargingSound.TimeLength * self.charge
					dischargingSound:Play()
				elseif chargeDelta >= 0 and dischargingSound.Playing then
					dischargingSound:Stop()
				end
			end
		end

		-- Play charge/discharge completed sounds and particle effects
		if chargeBefore < 1 and self.charge >= 1 then
			local chargeCompleteSound = self:getSound("ChargeComplete")
			if chargeCompleteSound then
				chargeCompleteSound:Play()
			end
			if chargingSound and chargingSound.Playing then
				chargingSound:Stop()
			end
			if self.chargeCompleteParticles then
				self.chargeCompleteParticles:Emit(self:getConfigValue("NumChargeCompleteParticles", 25))
			end
		end
		if chargeBefore > 0 and self.charge <= 0 then
			local dischargeCompleteSound = self:getSound("DischargeComplete")
			if dischargeCompleteSound then
				dischargeCompleteSound:Play()
			end
			if dischargingSound and dischargingSound.Playing then
				dischargingSound:Stop()
			end
			if self.dischargeCompleteParticles then
				self.dischargeCompleteParticles:Emit(self:getConfigValue("NumDischargeCompleteParticles", 25))
			end
		end

		self:renderCharge()
	else
		if chargingSound then
			chargingSound:Stop()
		end
		if dischargingSound then
			dischargingSound:Stop()
		end
	end

	if self.usesCharging and self.chargeGlowPart then
		self.chargeGlowPart.Transparency = 1 - self.charge
	end

	-- Fire weapon if it is fully charged
	if self:canFire() and now > self.nextFireTime then
		self:doLocalFire()
	end
end

function BulletWeapon:handleCharging(dt)
	local chargeDelta
	local shouldCharge = self.activated or self.burstFiring or self:getConfigValue("ChargePassively", false)
	if self.reloading or self.triggerDisconnected then
		shouldCharge = false
	end

	if shouldCharge then
		chargeDelta = self:getConfigValue("ChargeRate", 0) * dt
	else
		chargeDelta = self:getConfigValue("DischargeRate", 0) * -dt
	end

	self.charge = math.clamp(self.charge + chargeDelta, 0, 1)
end

function BulletWeapon:isCharged()
	return not self.usesCharging or self.charge >= 1
end

function BulletWeapon:canFire()
	return self.player == Players.LocalPlayer and (self.burstFiring or self.activated) and not self.triggerDisconnected and not self.reloading and self:isCharged() and self.startupFinished
end

function BulletWeapon:doLocalFire()
	if self.tipAttach then
		local tipCFrame = self.tipAttach.WorldCFrame
		local tipPos = tipCFrame.Position
		local aimDir = (self.aimPoint - tipPos).Unit

		self:fire(tipPos, aimDir, self.charge)
	end
end

return BulletWeapon
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="28">
        <Properties>
          <string name="Name">WeaponsSystem</string>
          <string name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")

local IsServer = RunService:IsServer()

-- Dependencies
local WeaponData = script.Parent:WaitForChild("WeaponData")
local WeaponsSystemFolder = script.Parent
local WeaponTypes = WeaponsSystemFolder:WaitForChild("WeaponTypes")
local Libraries = WeaponsSystemFolder:WaitForChild("Libraries")
local ShoulderCamera = require(Libraries:WaitForChild("ShoulderCamera"))
local WeaponsGui = require(Libraries:WaitForChild("WeaponsGui"))
local SpringService = require(Libraries:WaitForChild("SpringService"))
local ancestorHasTag = require(Libraries:WaitForChild("ancestorHasTag"))
ShoulderCamera.SpringService = SpringService

local Configuration = WeaponsSystemFolder:WaitForChild("Configuration")
local ConfigurationValues = {
	SprintEnabled = Configuration:WaitForChild("SprintEnabled"),
	SlowZoomWalkEnabled = Configuration:WaitForChild("SlowZoomWalkEnabled"),
}

local WEAPON_TAG = "WeaponsSystemWeapon"
local WEAPON_TYPES_LOOKUP = {}

local REMOTE_EVENT_NAMES = {
	"WeaponFired",
	"WeaponHit",
	"WeaponReloadRequest",
	"WeaponReloaded",
	"WeaponReloadCanceled",
	"WeaponActivated"
}
local REMOTE_FUNCTION_NAMES = {}

--Set up WeaponTypes lookup table
do
	local function onNewWeaponType(weaponTypeModule)
		if not weaponTypeModule:IsA("ModuleScript") then
			return
		end
		local weaponTypeName = weaponTypeModule.Name
		xpcall(function()
			coroutine.wrap(function()
				local weaponType = require(weaponTypeModule)
				assert(typeof(weaponType) == "table", string.format("WeaponType \"%s\" did not return a valid table", weaponTypeModule:GetFullName()))
				WEAPON_TYPES_LOOKUP[weaponTypeName] = weaponType
			end)()
		end, function(errMsg)
			warn(string.format("Error while loading %s: %s", weaponTypeModule:GetFullName(), errMsg))
			warn(debug.traceback())
		end)
	end
	for _, child in pairs(WeaponTypes:GetChildren()) do
		onNewWeaponType(child)
	end
	WeaponTypes.ChildAdded:Connect(onNewWeaponType)
end

local WeaponsSystem = {}
WeaponsSystem.didSetup = false
WeaponsSystem.knownWeapons = {}
WeaponsSystem.connections = {}
WeaponsSystem.networkFolder = nil
WeaponsSystem.remoteEvents = {}
WeaponsSystem.remoteFunctions = {}
WeaponsSystem.currentWeapon = nil
WeaponsSystem.aimRayCallback = nil

WeaponsSystem.CurrentWeaponChanged = Instance.new("BindableEvent")

local NetworkingCallbacks = require(WeaponsSystemFolder:WaitForChild("NetworkingCallbacks"))
NetworkingCallbacks.WeaponsSystem = WeaponsSystem

local _damageCallback = nil
local _getTeamCallback = nil

function WeaponsSystem.setDamageCallback(cb)
	_damageCallback = cb
end

function WeaponsSystem.setGetTeamCallback(cb)
	_getTeamCallback = cb
end

function WeaponsSystem.setup()
	if WeaponsSystem.didSetup then
		warn("Warning: trying to run WeaponsSystem setup twice on the same module.")
		return
	end
	print(script.Parent:GetFullName(), "is now active.")

	WeaponsSystem.doingSetup = true

	--Setup network routing
	if IsServer then
		local networkFolder = Instance.new("Folder")
		networkFolder.Name = "Network"

		for _, remoteEventName in pairs(REMOTE_EVENT_NAMES) do
			local remoteEvent = Instance.new("RemoteEvent")
			remoteEvent.Name = remoteEventName
			remoteEvent.Parent = networkFolder

			local callback = NetworkingCallbacks[remoteEventName]
			if not callback then
				--Connect a no-op function to ensure the queue doesn't pile up.
				warn("There is no server callback implemented for the WeaponsSystem RemoteEvent \"%s\"!")
				warn("A default no-op function will be implemented so that the queue cannot be abused.")
				callback = function() end
			end
			WeaponsSystem.connections[remoteEventName .. "Remote"] = remoteEvent.OnServerEvent:Connect(function(...)
				callback(...)
			end)
			WeaponsSystem.remoteEvents[remoteEventName] = remoteEvent
		end
		for _, remoteFuncName in pairs(REMOTE_FUNCTION_NAMES) do
			local remoteFunc = Instance.new("RemoteEvent")
			remoteFunc.Name = remoteFuncName
			remoteFunc.Parent = networkFolder

			local callback = NetworkingCallbacks[remoteFuncName]
			if not callback then
				--Connect a no-op function to ensure the queue doesn't pile up.
				warn("There is no server callback implemented for the WeaponsSystem RemoteFunction \"%s\"!")
				warn("A default no-op function will be implemented so that the queue cannot be abused.")
				callback = function() end
			end
			remoteFunc.OnServerInvoke = function(...)
				return callback(...)
			end
			WeaponsSystem.remoteFunctions[remoteFuncName] = remoteFunc
		end

		networkFolder.Parent = WeaponsSystemFolder
		WeaponsSystem.networkFolder = networkFolder
	else
		WeaponsSystem.StarterGui = game:GetService("StarterGui")

		WeaponsSystem.camera = ShoulderCamera.new(WeaponsSystem)
		WeaponsSystem.gui = WeaponsGui.new(WeaponsSystem)

		if ConfigurationValues.SprintEnabled.Value then
			WeaponsSystem.camera:setSprintEnabled(ConfigurationValues.SprintEnabled.Value)
		end
		
		if ConfigurationValues.SlowZoomWalkEnabled.Value then
			WeaponsSystem.camera:setSlowZoomWalkEnabled(ConfigurationValues.SlowZoomWalkEnabled.Value)
		end

		local networkFolder = WeaponsSystemFolder:WaitForChild("Network", math.huge)

		for _, remoteEventName in pairs(REMOTE_EVENT_NAMES) do
			coroutine.wrap(function()
				local remoteEvent = networkFolder:WaitForChild(remoteEventName, math.huge)
				local callback = NetworkingCallbacks[remoteEventName]
				if callback then
					WeaponsSystem.connections[remoteEventName .. "Remote"] = remoteEvent.OnClientEvent:Connect(function(...)
						callback(...)
					end)
				end
				WeaponsSystem.remoteEvents[remoteEventName] = remoteEvent
			end)()
		end
		for _, remoteFuncName in pairs(REMOTE_FUNCTION_NAMES) do
			coroutine.wrap(function()
				local remoteFunc = networkFolder:WaitForChild(remoteFuncName, math.huge)
				local callback = NetworkingCallbacks[remoteFuncName]
				if callback then
					remoteFunc.OnClientInvoke = function(...)
						return callback(...)
					end
				end
				WeaponsSystem.remoteFunctions[remoteFuncName] = remoteFunc
			end)()
		end

		Players.LocalPlayer.CharacterAdded:Connect(WeaponsSystem.onCharacterAdded)
		if Players.LocalPlayer.Character then
			WeaponsSystem.onCharacterAdded(Players.LocalPlayer.Character)
		end

		WeaponsSystem.networkFolder = networkFolder
		--WeaponsSystem.camera:setEnabled(true) -- Removed to fix camera issues.
	end

	--Setup weapon tools and listening
	WeaponsSystem.connections.weaponAdded = CollectionService:GetInstanceAddedSignal(WEAPON_TAG):Connect(WeaponsSystem.onWeaponAdded)
	WeaponsSystem.connections.weaponRemoved = CollectionService:GetInstanceRemovedSignal(WEAPON_TAG):Connect(WeaponsSystem.onWeaponRemoved)

	for _, instance in pairs(CollectionService:GetTagged(WEAPON_TAG)) do
		WeaponsSystem.onWeaponAdded(instance)
	end

	WeaponsSystem.doingSetup = false
	WeaponsSystem.didSetup = true
end

function WeaponsSystem.onCharacterAdded(character)
	-- Make it so players unequip weapons while seated, then reequip weapons when they become unseated
	local humanoid = character:WaitForChild("Humanoid")
	WeaponsSystem.connections.seated = humanoid.Seated:Connect(function(isSeated)
		if isSeated then
			WeaponsSystem.seatedWeapon = character:FindFirstChildOfClass("Tool")
			humanoid:UnequipTools()
			WeaponsSystem.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
		else
			WeaponsSystem.StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, true)
			humanoid:EquipTool(WeaponsSystem.seatedWeapon)
		end
	end)
end

function WeaponsSystem.shutdown()
	if not WeaponsSystem.didSetup then
		return
	end

	for _, weapon in pairs(WeaponsSystem.knownWeapons) do
		weapon:onDestroyed()
	end
	WeaponsSystem.knownWeapons = {}

	if IsServer and WeaponsSystem.networkFolder then
		WeaponsSystem.networkFolder:Destroy()
	end
	WeaponsSystem.networkFolder = nil
	WeaponsSystem.remoteEvents = {}
	WeaponsSystem.remoteFunctions = {}

	for _, connection in pairs(WeaponsSystem.connections) do
		if typeof(connection) == "RBXScriptConnection" then
			connection:Disconnect()
		end
	end
	WeaponsSystem.connections = {}
end

function WeaponsSystem.getWeaponTypeFromTags(instance)
	for _, tag in pairs(CollectionService:GetTags(instance)) do
		local weaponTypeFound = WEAPON_TYPES_LOOKUP[tag]
		if weaponTypeFound then
			return weaponTypeFound
		end
	end

	return nil
end

function WeaponsSystem.createWeaponForInstance(weaponInstance)
	coroutine.wrap(function()
		local weaponType = WeaponsSystem.getWeaponTypeFromTags(weaponInstance)
		if not weaponType then
			local weaponTypeObj = weaponInstance:WaitForChild("WeaponType")

			if weaponTypeObj and weaponTypeObj:IsA("StringValue") then
				local weaponTypeName = weaponTypeObj.Value
				local weaponTypeFound = WEAPON_TYPES_LOOKUP[weaponTypeName]
				if not weaponTypeFound then
					warn(string.format("Cannot find the weapon type \"%s\" for the instance %s!", weaponTypeName, weaponInstance:GetFullName()))
					return
				end

				weaponType = weaponTypeFound
			else
				warn("Could not find a WeaponType tag or StringValue for the instance ", weaponInstance:GetFullName())
				return
			end
		end

		-- Since we might have yielded while trying to get the WeaponType, we need to make sure not to continue
		-- making a new weapon if something else beat this iteration.
		if WeaponsSystem.getWeaponForInstance(weaponInstance) then
			warn("Already got ", weaponInstance:GetFullName())
			warn(debug.traceback())
			return
		end

		-- We should be pretty sure we got a valid weaponType by now
		assert(weaponType, "Got invalid weaponType")

		local weapon = weaponType.new(WeaponsSystem, weaponInstance)
		WeaponsSystem.knownWeapons[weaponInstance] = weapon
	end)()
end

function WeaponsSystem.getWeaponForInstance(weaponInstance)
	if not typeof(weaponInstance) == "Instance" then
		warn("WeaponsSystem.getWeaponForInstance(weaponInstance): 'weaponInstance' was not an instance.")
		return nil
	end

	return WeaponsSystem.knownWeapons[weaponInstance]
end

-- and (IsServer or weaponInstance:IsDescendantOf(Players.LocalPlayer))

function WeaponsSystem.onWeaponAdded(weaponInstance)
	local weapon = WeaponsSystem.getWeaponForInstance(weaponInstance)
	if not weapon then
		WeaponsSystem.createWeaponForInstance(weaponInstance)
	end
end

function WeaponsSystem.onWeaponRemoved(weaponInstance)
	local weapon = WeaponsSystem.getWeaponForInstance(weaponInstance)
	if weapon then
		weapon:onDestroyed()
	end
	WeaponsSystem.knownWeapons[weaponInstance] = nil
end

function WeaponsSystem.getRemoteEvent(name)
	if not WeaponsSystem.networkFolder then
		return
	end

	local remoteEvent = WeaponsSystem.remoteEvents[name]
	if IsServer then
		if not remoteEvent then
			warn("No RemoteEvent named ", name)
			return nil
		end

		return remoteEvent
	else
		if not remoteEvent then
			remoteEvent = WeaponsSystem.networkFolder:WaitForChild(name, math.huge)
		end

		return remoteEvent
	end
end

function WeaponsSystem.getRemoteFunction(name)
	if not WeaponsSystem.networkFolder then
		return
	end

	local remoteFunc = WeaponsSystem.remoteFunctions[name]
	if IsServer then
		if not remoteFunc then
			warn("No RemoteFunction named ", name)
			return nil
		end

		return remoteFunc
	else
		if not remoteFunc then
			remoteFunc = WeaponsSystem.networkFolder:WaitForChild(name, math.huge)
		end

		return remoteFunc
	end
end

function WeaponsSystem.setWeaponEquipped(weapon, equipped)
	assert(not IsServer, "WeaponsSystem.setWeaponEquipped should only be called on the client.")
	if not weapon then
		return
	end

	local lastWeapon = WeaponsSystem.currentWeapon
	local hasWeapon = false
	local weaponChanged = false

	if lastWeapon == weapon then
		if not equipped then
			WeaponsSystem.currentWeapon = nil
			hasWeapon = false
			weaponChanged = true
		else
			weaponChanged = false
		end
	else
		if equipped then
			WeaponsSystem.currentWeapon = weapon
			hasWeapon = true
			weaponChanged = true
		end
	end

	if WeaponsSystem.camera then
		WeaponsSystem.camera:resetZoomFactor()
		WeaponsSystem.camera:setHasScope(false)

		if WeaponsSystem.currentWeapon then
			WeaponsSystem.camera:setZoomFactor(WeaponsSystem.currentWeapon:getConfigValue("ZoomFactor", 1.1))
			WeaponsSystem.camera:setHasScope(WeaponsSystem.currentWeapon:getConfigValue("HasScope", false))
		end
	end

	if WeaponsSystem.gui then
		WeaponsSystem.camera:setEnabled(hasWeapon)  -- Added to fix camera issues.
		WeaponsSystem.gui:setEnabled(hasWeapon)

		if WeaponsSystem.currentWeapon then
			WeaponsSystem.gui:setCrosshairWeaponScale(WeaponsSystem.currentWeapon:getConfigValue("CrosshairScale", 1))
		else
			WeaponsSystem.gui:setCrosshairWeaponScale(1)
		end
	end

	if weaponChanged then
		WeaponsSystem.CurrentWeaponChanged:Fire(weapon.instance, lastWeapon and lastWeapon.instance)
	end
end

function WeaponsSystem.getHumanoid(part)
	while part and part ~= workspace do
		if part:IsA("Model") and part.PrimaryPart and part.PrimaryPart.Name == "HumanoidRootPart" then
			return part:FindFirstChildOfClass("Humanoid")
		end

		part = part.Parent
	end
end

function WeaponsSystem.getPlayerFromHumanoid(humanoid)
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Character and humanoid:IsDescendantOf(player.Character) then
			return player
		end
	end
end

-- Modified so that certain weapons can destroy glass windows as determined by a custom attribute.
local ZombieKilledEvent = ReplicatedStorage:WaitForChild("ZombieKilledEvent")
local SoldierKilledEvent = ReplicatedStorage:WaitForChild("SoldierKilledEvent")
local WindowShatteredEvent = ReplicatedStorage:WaitForChild("WindowShatteredEvent")

local windowColor = BrickColor.new("Bright blue")
local sound = Instance.new("Sound")
sound.SoundId = "rbxassetid://5961220911" -- Glass shatter.
sound.Volume = 5

local function _defaultDamageCallback(system, target, amount, damageType, dealer, hitInfo, damageData)
	if target:IsA("Humanoid") then
		if not WeaponsSystem.getPlayerFromHumanoid(target) then
			target:TakeDamage(amount)
			if target.Parent.Name == "Zombie" then
				if target.Health == 0 then
					ZombieKilledEvent:Fire(dealer)
				end
			elseif target.Parent.Name == "Soldier" then
				if target.Health == 0 then
					SoldierKilledEvent:Fire(dealer)
				end
			end
		end
	elseif target.BrickColor == windowColor and target.Transparency == 0.5 then
		local tool = dealer.Character:FindFirstChildOfClass("Tool")
		if tool:GetAttribute("CanBreakGlass") then
			sound.Parent = target
			sound:Play()
			sound.Parent = SoundService
			task.wait(0.25)
			target:Destroy()
			WindowShatteredEvent:Fire(dealer)
		end
	end
end

function WeaponsSystem.doDamage(target, amount, damageType, dealer, hitInfo, damageData)
	if not target or ancestorHasTag(target, "WeaponsSystemIgnore") then
		return
	end
	if IsServer then
		if target:IsA("Humanoid") and dealer:IsA("Player") and dealer.Character then
			local dealerHumanoid = dealer.Character:FindFirstChildOfClass("Humanoid")
			local targetPlayer = Players:GetPlayerFromCharacter(target.Parent)
			if dealerHumanoid and target ~= dealerHumanoid and targetPlayer then
				-- Trigger the damage indicator
				WeaponData:FireClient(targetPlayer, "HitByOtherPlayer", dealer.Character.HumanoidRootPart.CFrame.Position)
			end
		end

		-- NOTE:  damageData is a more or less free-form parameter that can be used for passing information from the code that is dealing damage about the cause.
		-- .The most obvious usage is extracting icons from the various weapon types (in which case a weapon instance would likely be passed in)
		-- ..The default weapons pass in that data
		local handler = _damageCallback or _defaultDamageCallback
		handler(WeaponsSystem, target, amount, damageType, dealer, hitInfo, damageData)
	end
end

local function _defaultGetTeamCallback(player)
	return 0
end

function WeaponsSystem.getTeam(player)
	local handler = _getTeamCallback or _defaultGetTeamCallback
	return handler(player)
end

function WeaponsSystem.playersOnDifferentTeams(player1, player2)
	if player1 == player2 or player1 == nil or player2 == nil then
		-- This allows players to damage themselves and NPC's
		return true
	end

	local player1Team = WeaponsSystem.getTeam(player1)
	local player2Team = WeaponsSystem.getTeam(player2)
	return player1Team == 0 or player1Team ~= player2Team
end

return WeaponsSystem
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Script" referent="29">
      <Properties>
        <string name="Name">ZombieDiamondManager</string>
        <string name="Source"><![CDATA[--[[
We begin with all the diamonds in the Zombie_Diamonds folder, all set to clone zombies.
When a diamond is converted to a different type it is also moved to a different folder.
--]]

local Players = game:GetService("Players")
local ServerStorage = game:GetService("ServerStorage")

local zombieDiamondsFolder = workspace:WaitForChild("Zombie_Diamonds")
local totalDiamonds = zombieDiamondsFolder:GetChildren()

local DIAMOND_COOLDOWN = 10

local function onDiamondTouched(otherPart, diamond)
	local character = otherPart.Parent
	local humanoid = character:FindFirstChildWhichIsA("Humanoid")
	local clone
	if humanoid then
		local name = humanoid.Parent.Name
		if name == "Robot" then
			-- Do nothing.
		elseif name == "Zombie" then
			-- Do nothing.
		elseif name == "Soldier" then
			-- Do nothing.
		else
			diamond.Color = BrickColor.new("Lime green").Color
			diamond:SetAttribute("CloneType", "Soldier")
			diamond.Parent.Parent = workspace.Soldier_Diamonds
		end
	end
end

for _, zombieDiamond in ipairs(totalDiamonds) do
	local diamond = zombieDiamond.Diamond
	diamond.Color = BrickColor.new("Really red").Color
	diamond:SetAttribute("CloneType", "Zombie")
	diamond.Touched:Connect(function(otherPart)
		onDiamondTouched(otherPart, diamond)
	end)
end

local clone

while true do
	for _, zombieDiamond in ipairs(totalDiamonds) do
		local diamond = zombieDiamond.Diamond
		local cloneType = diamond:GetAttribute("CloneType")
		local particleEmitter = diamond.Parent.DiskWithParticles.ParticleEmitter
		local cooldown
		if cloneType == "Zombie" then
			clone = ServerStorage.Zombie:Clone()
			clone.Configuration.AttackDamage.Value = 25
			clone.Configuration.AttackRadius.Value = math.random(50, 100)
			clone.Configuration.PatrolRadius.Value = math.random(20, 4000)
			cooldown = DIAMOND_COOLDOWN
		elseif cloneType == "Soldier" then
			clone = ServerStorage.Soldier:Clone()
			clone.Configuration.AttackDamage.Value = math.random(5, 20)
			clone.Configuration.AttackDelay.Value = 1
			clone.Configuration.AttackRadius.Value = 50
			clone.Configuration.ClipCapacity.Value = 8
			clone.Configuration.PatrolRadius.Value = math.random(200, 400)
			clone.Configuration.ReloadDelay.Value = 3
			cooldown = DIAMOND_COOLDOWN * 2
		end
		clone.HumanoidRootPart.Position = diamond.Position
		local folderName = clone.Name .. "s"
		clone.Parent = workspace[folderName]
		task.wait(cooldown / #totalDiamonds)
	end
	for _, zombieDiamond in ipairs(totalDiamonds) do
		local diamond = zombieDiamond.Diamond
		local particleEmitter = diamond.Parent.DiskWithParticles.ParticleEmitter
	end
end
]]></string>
      </Properties>
    </Item>
  </Item>
  <Item class="ServerStorage" referent="30">
    <Properties>
      <string name="Name">ServerStorage</string>
    </Properties>
    <Item class="Model" referent="31">
      <Properties>
        <string name="Name">Robot</string>
      </Properties>
      <Item class="Script" referent="32">
        <Properties>
          <string name="Name">Animate</string>
          <string name="Source"><![CDATA[local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local animateScriptEmoteHookFlagExists, animateScriptEmoteHookFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserAnimateScriptEmoteHook")
end)
local FFlagAnimateScriptEmoteHook = animateScriptEmoteHookFlagExists and animateScriptEmoteHookFlagEnabled

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			return 1
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return 1
end

local smallButNotZero = 0.0001
function setRunSpeed(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale

	if runSpeed ~= currentAnimSpeed then
		if runSpeed < 0.33 then
			currentAnimTrack:AdjustWeight(1.0)		
			runAnimTrack:AdjustWeight(smallButNotZero)
		elseif runSpeed < 0.66 then
			local weight = ((runSpeed - 0.33) / 0.33)
			currentAnimTrack:AdjustWeight(1.0 - weight + smallButNotZero)
			runAnimTrack:AdjustWeight(weight + smallButNotZero)
		else
			currentAnimTrack:AdjustWeight(smallButNotZero)
			runAnimTrack:AdjustWeight(1.0)
		end
		currentAnimSpeed = runSpeed
		runAnimTrack:AdjustSpeed(runSpeed)
		currentAnimTrack:AdjustSpeed(runSpeed)
	end	
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)	
	if speed > 0.75 then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- emote bindable hook
if FFlagAnimateScriptEmoteHook then
	script:WaitForChild("PlayEmote").OnInvoke = function(emote)
		-- Only play emotes when idling
		if pose ~= "Standing" then
			return
		end
	
		if emoteNames[emote] ~= nil then
			-- Default emotes
			playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
			
			return true
		elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
			-- Non-default emotes
			playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)
			return true
		end
		
		-- Return false to indicate that the emote could not be played
		return false
	end
end

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="33">
        <Properties>
          <string name="Name">Health</string>
          <string name="Source"><![CDATA[-- Gradually regenerates the Humanoid's Health over time.

local REGEN_RATE = 1 / 100 -- Regenerate this fraction of MaxHealth per second.
local REGEN_STEP = 1 -- Wait this long between each regeneration step.

--------------------------------------------------------------------------------

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")

--------------------------------------------------------------------------------

while true do
	while Humanoid.Health < Humanoid.MaxHealth and Humanoid.Health > 0 and Humanoid:GetState() ~= Enum.HumanoidStateType.Dead do
		local dt = wait(REGEN_STEP)
		local dh = dt * REGEN_RATE * Humanoid.MaxHealth
		Humanoid.Health = math.min(Humanoid.Health + dh, Humanoid.MaxHealth)
	end
	Humanoid.HealthChanged:Wait()
end
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="34">
        <Properties>
          <string name="Name">NPC</string>
          <string name="Source"><![CDATA[--[[
	Written by meow_pizza
	Last modified: 2019-03-30
]]

local Ragdoll = require(script:WaitForChild("Ragdoll"))
local Maid = require(script:WaitForChild("Maid"))

local function getValueFromConfig(name)
	local configuration = script.Parent:WaitForChild("Configuration")
	local valueObject = configuration and configuration:FindFirstChild(name)
	return valueObject and valueObject.Value
end

--[[
	Configuration
]]

local PATROL_ENABLED = getValueFromConfig("PatrolEnabled")
local PATROL_RADIUS = getValueFromConfig("PatrolRadius")
local DESTROY_ON_DEATH = getValueFromConfig("DestroyOnDeath")
local RAGDOLL_ENABLED = getValueFromConfig("RagdollEnabled")

local DEATH_DESTROY_DELAY = 5
local MIN_REPOSITION_TIME = 2
local MAX_REPOSITION_TIME = 10

--[[
	Instance references
]]

local maid = Maid.new()
maid.instance = script.Parent

maid.humanoid = maid.instance:WaitForChild("Humanoid")
maid.humanoidRootPart = maid.instance:WaitForChild("HumanoidRootPart")

-- Sounds
maid.hurtSound = maid.humanoidRootPart:WaitForChild("Hurt")

local startPosition = maid.instance.PrimaryPart.Position
local previousHealth = maid.humanoid.Health

--[[
	Helper functions
]]

local random = Random.new()

local function getRandomPointInCircle(centerPosition, circleRadius)
	local radius = math.sqrt(random:NextNumber()) * circleRadius
	local angle = random:NextNumber(0, math.pi * 2)
	local x = centerPosition.X + radius * math.cos(angle)
	local z = centerPosition.Z + radius * math.sin(angle)

	local position = Vector3.new(x, centerPosition.Y, z)

	return position
end

--[[
	Implementation
]]

local function isAlive()
	return maid.humanoid.Health > 0 and maid.humanoid:GetState() ~= Enum.HumanoidStateType.Dead
end

local function moveToRandomPosition()
	local position = getRandomPointInCircle(startPosition, PATROL_RADIUS)
	maid.humanoid:MoveTo(position)

	-- Set any thrusters to look like they moving the robot
	for _, instance in pairs(maid.instance:GetDescendants()) do
		if instance.Name == "ThrusterFire" then
			instance.Speed = NumberRange.new(2)
			instance.SpreadAngle = Vector2.new(5, 5)
		end
	end
end

local function destroy()
	maid:destroy()
end

local function patrol()
	while isAlive() do
		moveToRandomPosition()

		wait(random:NextInteger(MIN_REPOSITION_TIME, MAX_REPOSITION_TIME))
	end
end

--[[
	Event functions
]]

local function died()
	-- Disable any thruster particle emitters
	for _, item in pairs(maid.instance:GetDescendants()) do
		if item.Name == "ThrusterFire" then
			item.Enabled = false
		end
	end

	if RAGDOLL_ENABLED then
		Ragdoll(maid.instance, maid.humanoid)
	end

	if DESTROY_ON_DEATH then
		delay(DEATH_DESTROY_DELAY, function()
			destroy()
		end)
	end
end

local function healthChanged()
	if maid.humanoid.health < previousHealth and not isAlive() then
		-- Move to a new location when damaged
		moveToRandomPosition()

		if not maid.hurtSound.Playing then
			maid.hurtSound:Play()
		end
	end

	previousHealth = maid.humanoid.health
end

local function moveToFinished()
	-- Set any thrusters to an inactive state
	for _, instance in pairs(maid.instance:GetDescendants()) do
		if instance.Name == "ThrusterFire" then
			instance.Speed = NumberRange.new(1)
			instance.SpreadAngle = Vector2.new(10, 10)
		end
	end
end

--[[
	Connections
]]

maid.diedConnection = maid.humanoid.Died:Connect(function()
	died()
end)

maid.healthChangedConnection = maid.humanoid.HealthChanged:Connect(function()
	healthChanged()
end)

maid.humanoid.MoveToFinished:Connect(function()
	moveToFinished()
end)

--[[
	Start
]]

if PATROL_ENABLED then
	coroutine.wrap(function()
		patrol()
	end)()
end
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="35">
          <Properties>
            <string name="Name">Maid</string>
            <string name="Source"><![CDATA[local Maid = {}

function Maid.new()
	local self = {
		_tasks = {},
	}
	setmetatable(self, Maid)

	return self
end

function Maid:__index(key)
	return Maid[key] or self._tasks[key]
end

function Maid:__newindex(key, newTask)
	if Maid[key] then
		error(string.format("Cannot use %q as a Maid key", tostring(key)))
	end
	local tasks = self._tasks
	local oldTask = tasks[key]
	tasks[key] = newTask

	if oldTask then
		Maid.cleanupTask(oldTask)
	end
end

function Maid:give(task)
	local tasks = self._tasks
	tasks[#tasks+1] = task
end

function Maid.cleanupTask(task)
	local taskTy = typeof(task)
	if taskTy == 'function' then
		task()
	elseif taskTy == 'RBXScriptConnection' then
		task:Disconnect()
	elseif taskTy == 'Instance' then
		task:Destroy()
	elseif task.Destroy then
		task:Destroy()
	elseif task.destroy then
		task:destroy()
	elseif task.disconnect then
		task:disconnect()
	else
		error("Unable to cleanup unknown task")
	end
end

function Maid:clean()
	local tasks = self._tasks

	for key,task in pairs(tasks) do
		if typeof(task) == 'RBXScriptConnection' then
			tasks[key] = nil
			task:Disconnect()
		end
	end

	local index, task = next(tasks)
	while task ~= nil do
		tasks[index] = nil
		Maid.cleanupTask(task)
		index, task = next(tasks)
	end
end

Maid.destroy = Maid.clean
Maid.Destroy = Maid.clean

return Maid
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="36">
          <Properties>
            <string name="Name">Ragdoll</string>
            <string name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")

local RigTypes = require(script.RigTypes)

local RAGDOLLED_TAG = "__Ragdoll_Active"

local function ragdoll(model, humanoid)
	assert(humanoid:IsDescendantOf(model))
	if CollectionService:HasTag(model, RAGDOLLED_TAG) then
		return
	end
	CollectionService:AddTag(model, RAGDOLLED_TAG)

	-- Turn into loose body:
	humanoid:ChangeState(Enum.HumanoidStateType.Physics)

	-- Instantiate BallSocketConstraints:
	local attachments = RigTypes.getAttachments(model, humanoid.RigType)
	for name, objects in pairs(attachments) do
		local parent = model:FindFirstChild(name)
		if parent then
			local constraint = Instance.new("BallSocketConstraint")
			constraint.Name = "RagdollBallSocketConstraint"
			constraint.Attachment0 = objects.attachment0
			constraint.Attachment1 = objects.attachment1
			constraint.LimitsEnabled = true
			constraint.UpperAngle = objects.limits.UpperAngle
			constraint.TwistLimitsEnabled = true
			constraint.TwistLowerAngle = objects.limits.TwistLowerAngle
			constraint.TwistUpperAngle = objects.limits.TwistUpperAngle
			constraint.Parent = parent
		end
	end

	-- Instantiate NoCollisionConstraints:
	local parts = RigTypes.getNoCollisions(model, humanoid.RigType)
	for _, objects in pairs(parts) do
		local constraint = Instance.new("NoCollisionConstraint")
		constraint.Name = "RagdollNoCollisionConstraint"
		constraint.Part0 = objects[1]
		constraint.Part1 = objects[2]
		constraint.Parent = objects[1]
	end

	-- Destroy all regular joints:
	for _, motor in pairs(model:GetDescendants()) do
		if motor:IsA("Motor6D") then
			motor:Destroy()
		end
	end
end

return ragdoll
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="37">
            <Properties>
              <string name="Name">RigTypes</string>
              <string name="Source"><![CDATA[local RigTypes = {}

local HEAD_LIMITS = {
	UpperAngle = 60;
	TwistLowerAngle = -60;
	TwistUpperAngle = 60;
}

local LOWER_TORSO_LIMITS = {
	UpperAngle = 20;
	TwistLowerAngle = -30;
	TwistUpperAngle = 60;
}

local HAND_FOOT_LIMITS = {
	UpperAngle = 10;
	TwistLowerAngle = -10;
	TwistUpperAngle = 10;
}

local ELBOW_LIMITS = {
	UpperAngle = 30;
	TwistLowerAngle = 0;
	TwistUpperAngle = 120;
}

local KNEE_LIMITS = {
	UpperAngle = 30;
	TwistLowerAngle = -120;
	TwistUpperAngle = 0;
}

local SHOULDER_LIMITS = {
	UpperAngle = 60;
	TwistLowerAngle = -60;
	TwistUpperAngle = 175;
}

local HIP_LIMITS = {
	UpperAngle = 40;
	TwistLowerAngle = -5;
	TwistUpperAngle = 150;
}

local R6_HEAD_LIMITS = {
	UpperAngle = 30;
	TwistLowerAngle = -60;
	TwistUpperAngle = 60;
}

local R6_SHOULDER_LIMITS = {
	UpperAngle = 90;
	TwistLowerAngle = -30;
	TwistUpperAngle = 175;
}

local R6_HIP_LIMITS = {
	UpperAngle = 60;
	TwistLowerAngle = -5;
	TwistUpperAngle = 120;
}

local function createJointData(attach0, attach1, limits)
	assert(attach0)
	assert(attach1)
	assert(limits)
	assert(limits.UpperAngle >= 0)
	assert(limits.TwistLowerAngle <= limits.TwistUpperAngle)

	return {
		attachment0 = attach0,
		attachment1 = attach1,
		limits = limits
	}
end

local function find(model)
	return function(first, second, limits)
		local part0 = model:FindFirstChild(first[1])
		local part1 = model:FindFirstChild(second[1])
		if part0 and part1 then
			local attach0 = part0:FindFirstChild(first[2])
			local attach1 = part1:FindFirstChild(second[2])
			if attach0 and attach1 and attach0:IsA("Attachment") and attach1:IsA("Attachment") then
				return createJointData(attach0, attach1, limits)
			end
		end
	end
end

function RigTypes.getNoCollisions(model, rigType)
	if rigType == Enum.HumanoidRigType.R6 then
		return RigTypes.getR6NoCollisions(model)
	elseif rigType == Enum.HumanoidRigType.R15 then
		return RigTypes.getR15NoCollisions(model)
	else
		return {}
	end
end

-- Get list of attachments to make ballsocketconstraints between:
function RigTypes.getAttachments(model, rigType)
	if rigType == Enum.HumanoidRigType.R6 then
		return RigTypes.getR6Attachments(model)
	elseif rigType == Enum.HumanoidRigType.R15 then
		return RigTypes.getR15Attachments(model)
	else
		return {}
	end
end

function RigTypes.getR6Attachments(model)
	local rightLegAttachment = Instance.new("Attachment")
	rightLegAttachment.Name = "RagdollRightLegAttachment"
	rightLegAttachment.Position = Vector3.new(0, 1, 0)
	rightLegAttachment.Parent = model:FindFirstChild("Right Leg")

	local leftLegAttachment = Instance.new("Attachment")
	leftLegAttachment.Name = "RagdollLeftLegAttachment"
	leftLegAttachment.Position = Vector3.new(0, 1, 0)
	leftLegAttachment.Parent = model:FindFirstChild("Left Leg")

	local torsoLeftAttachment = Instance.new("Attachment")
	torsoLeftAttachment.Name = "RagdollTorsoLeftAttachment"
	torsoLeftAttachment.Position = Vector3.new(-0.5, -1, 0)
	torsoLeftAttachment.Parent = model:FindFirstChild("Torso")

	local torsoRightAttachment = Instance.new("Attachment")
	torsoRightAttachment.Name = "RagdollTorsoRightAttachment"
	torsoRightAttachment.Position = Vector3.new(0.5, -1, 0)
	torsoRightAttachment.Parent = model:FindFirstChild("Torso")

	local headAttachment = Instance.new("Attachment")
	headAttachment.Name = "RagdollHeadAttachment"
	headAttachment.Position = Vector3.new(0, -0.5, 0)
	headAttachment.Parent = model:FindFirstChild("Head")

	local leftArmAttachment = Instance.new("Attachment")
	leftArmAttachment.Name = "RagdollLeftArmAttachment"
	leftArmAttachment.Position = Vector3.new(0.5, 1, 0)
	leftArmAttachment.Parent = model:FindFirstChild("Left Arm")

	local ragdollRightArmAttachment = Instance.new("Attachment")
	ragdollRightArmAttachment.Name = "RagdollRightArmAttachment"
	ragdollRightArmAttachment.Position = Vector3.new(-0.5, 1, 0)
	ragdollRightArmAttachment.Parent = model:FindFirstChild("Right Arm")

	local query = find(model)

	return {
		Head = query(
			{"Torso", "NeckAttachment"},
			{"Head", "RagdollHeadAttachment"},
			R6_HEAD_LIMITS),
		["Left Arm"] = query(
			{"Torso", "LeftCollarAttachment"},
			{"Left Arm", "RagdollLeftArmAttachment"},
			R6_SHOULDER_LIMITS),
		["Right Arm"] = query(
			{"Torso", "RightCollarAttachment"},
			{"Right Arm", "RagdollRightArmAttachment"},
			R6_SHOULDER_LIMITS),
		["Left Leg"] = createJointData(torsoLeftAttachment, leftLegAttachment, R6_HIP_LIMITS),
		["Right Leg"] = createJointData(torsoRightAttachment, rightLegAttachment, R6_HIP_LIMITS),
	}
end

function RigTypes.getR15Attachments(model)
	local query = find(model)

	return {
		Head = query(
			{"UpperTorso", "NeckRigAttachment"},
			{"Head", "NeckRigAttachment"},
			HEAD_LIMITS),

		LowerTorso = query(
			{"UpperTorso", "WaistRigAttachment"},
			{"LowerTorso", "RootRigAttachment"},
			LOWER_TORSO_LIMITS),

		LeftUpperArm = query(
			{"UpperTorso", "LeftShoulderRigAttachment"},
			{"LeftUpperArm", "LeftShoulderRigAttachment"},
			SHOULDER_LIMITS),
		LeftLowerArm = query(
			{"LeftUpperArm", "LeftElbowRigAttachment"},
			{"LeftLowerArm", "LeftElbowRigAttachment"},
			ELBOW_LIMITS),
		LeftHand = query(
			{"LeftLowerArm", "LeftWristRigAttachment"},
			{"LeftHand", "LeftWristRigAttachment"},
			HAND_FOOT_LIMITS),

		RightUpperArm = query(
			{"UpperTorso", "RightShoulderRigAttachment"},
			{"RightUpperArm", "RightShoulderRigAttachment"},
			SHOULDER_LIMITS),
		RightLowerArm = query(
			{"RightUpperArm", "RightElbowRigAttachment"},
			{"RightLowerArm", "RightElbowRigAttachment"},
			ELBOW_LIMITS),
		RightHand = query(
			{"RightLowerArm", "RightWristRigAttachment"},
			{"RightHand", "RightWristRigAttachment"},
			HAND_FOOT_LIMITS),

		LeftUpperLeg = query(
			{"LowerTorso", "LeftHipRigAttachment"},
			{"LeftUpperLeg", "LeftHipRigAttachment"},
			HIP_LIMITS),
		LeftLowerLeg = query(
			{"LeftUpperLeg", "LeftKneeRigAttachment"},
			{"LeftLowerLeg", "LeftKneeRigAttachment"},
			KNEE_LIMITS),
		LeftFoot = query(
			{"LeftLowerLeg", "LeftAnkleRigAttachment"},
			{"LeftFoot", "LeftAnkleRigAttachment"},
			HAND_FOOT_LIMITS),

		RightUpperLeg = query(
			{"LowerTorso", "RightHipRigAttachment"},
			{"RightUpperLeg", "RightHipRigAttachment"},
			HIP_LIMITS),
		RightLowerLeg = query(
			{"RightUpperLeg", "RightKneeRigAttachment"},
			{"RightLowerLeg", "RightKneeRigAttachment"},
			KNEE_LIMITS),
		RightFoot = query(
			{"RightLowerLeg", "RightAnkleRigAttachment"},
			{"RightFoot", "RightAnkleRigAttachment"},
			HAND_FOOT_LIMITS),
	}
end

function RigTypes.getR6NoCollisions(model)
	local list = {}

	local function addPair(pair)
		local part0 = model:FindFirstChild(pair[1])
		local part1 = model:FindFirstChild(pair[2])

		if part0 and part1 then
			table.insert(list, {part0, part1})
		end
	end

	addPair({"Head", "Torso"})
	addPair({"Left Arm", "Torso"})
	addPair({"Right Arm", "Torso"})
	addPair({"Left Leg", "Torso"})
	addPair({"Right Leg", "Torso"})

	addPair({"Left Leg", "Right Leg"})

	return list
end


function RigTypes.getR15NoCollisions(model)
	local list = {}

	local function addPair(pair)
		local part0 = model:FindFirstChild(pair[1])
		local part1 = model:FindFirstChild(pair[2])

		if part0 and part1 then
			table.insert(list, {part0, part1})
		end
	end

	addPair({"Head", "UpperTorso"})
	addPair({"UpperTorso", "LowerTorso"})

	addPair({"UpperTorso", "LeftUpperArm"})
	addPair({"LowerTorso", "LeftUpperArm"})
	addPair({"LeftUpperArm", "LeftLowerArm"})
	addPair({"LeftLowerArm", "LeftHand"})
	addPair({"LeftUpperArm", "LeftHand"})

	addPair({"UpperTorso", "RightUpperArm"})
	addPair({"LowerTorso", "RightUpperArm"})
	addPair({"RightUpperArm", "RightLowerArm"})
	addPair({"RightLowerArm", "RightHand"})
	addPair({"RightUpperArm", "RightHand"})

	addPair({"LeftUpperLeg", "RightUpperLeg"})

	addPair({"UpperTorso", "RightUpperLeg"})
	addPair({"LowerTorso", "RightUpperLeg"})
	addPair({"RightUpperLeg", "RightLowerLeg"})
	addPair({"RightLowerLeg", "RightFoot"})
	addPair({"RightUpperLeg", "RightFoot"})

	addPair({"UpperTorso", "LeftUpperLeg"})
	addPair({"LowerTorso", "LeftUpperLeg"})
	addPair({"LeftUpperLeg", "LeftLowerLeg"})
	addPair({"LeftLowerLeg", "LeftFoot"})
	addPair({"LeftUpperLeg", "LeftFoot"})

	-- Support weird R15 rigs
	addPair({"UpperTorso", "LeftLowerLeg"})
	addPair({"UpperTorso", "RightLowerLeg"})
	addPair({"LowerTorso", "LeftLowerLeg"})
	addPair({"LowerTorso", "RightLowerLeg"})

	addPair({"UpperTorso", "LeftLowerArm"})
	addPair({"UpperTorso", "RightLowerArm"})

	local upperTorso = model:FindFirstChild("UpperTorso")
	if upperTorso and upperTorso.Size.x <= 1.5 then
		addPair({"Head", "LeftUpperArm"})
		addPair({"Head", "RightUpperArm"})
	end

	return list
end

return RigTypes
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Script" referent="38">
        <Properties>
          <string name="Name">RbxNpcSounds</string>
          <string name="Source"><![CDATA[-- Roblox NPC sound script

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local SOUND_DATA = {
	Climbing = {
		SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
		Looped = true,
	},
	Died = {
		SoundId = "rbxassetid://3361342315",
	},
	FreeFalling = {
		SoundId = "rbxasset://sounds/action_falling.mp3",
		Looped = true,
	},
	GettingUp = {
		SoundId = "rbxasset://sounds/action_get_up.mp3",
	},
	Jumping = {
		SoundId = "rbxasset://sounds/action_jump.mp3",
	},
	Landing = {
		SoundId = "rbxasset://sounds/action_jump_land.mp3",
	},
	Running = {
		SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
		Looped = true,
		Pitch = 1.85,
	},
	Splash = {
		SoundId = "rbxasset://sounds/impact_water.mp3",
	},
	Swimming = {
		SoundId = "rbxasset://sounds/action_swim.mp3",
		Looped = true,
		Pitch = 1.6,
	},
}

-- map a value from one range to another
local function map(x, inMin, inMax, outMin, outMax)
	return (x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin
end

local function playSound(sound)
	sound.TimePosition = 0
	sound.Playing = true
end

local function stopSound(sound)
	sound.Playing = false
	sound.TimePosition = 0
end

local function initializeSoundSystem(humanoid, rootPart)
	local sounds = {}

	-- initialize sounds
	for name, props in pairs(SOUND_DATA) do
		local sound = Instance.new("Sound")
		sound.Name = name

		-- set default values
		sound.Archivable = false
		sound.EmitterSize = 5
		sound.MaxDistance = 150
		sound.Volume = 0.65

		for propName, propValue in pairs(props) do
			sound[propName] = propValue
		end

		sound.Parent = rootPart
		sounds[name] = sound
	end

	local playingLoopedSounds = {}

	local function stopPlayingLoopedSounds(except)
		for sound in pairs(playingLoopedSounds) do
			if sound ~= except then
				sound.Playing = false
				playingLoopedSounds[sound] = nil
			end
		end
	end

	-- state transition callbacks
	local stateTransitions = {
		[Enum.HumanoidStateType.FallingDown] = function()
			stopPlayingLoopedSounds()
		end,

		[Enum.HumanoidStateType.GettingUp] = function()
			stopPlayingLoopedSounds()
			playSound(sounds.GettingUp)
		end,

		[Enum.HumanoidStateType.Jumping] = function()
			stopPlayingLoopedSounds()
			playSound(sounds.Jumping)
		end,

		[Enum.HumanoidStateType.Swimming] = function()
			local verticalSpeed = math.abs(rootPart.Velocity.Y)
			if verticalSpeed > 0.1 then
				sounds.Splash.Volume = math.clamp(map(verticalSpeed, 100, 350, 0.28, 1), 0, 1)
				playSound(sounds.Splash)
			end
			stopPlayingLoopedSounds(sounds.Swimming)
			sounds.Swimming.Playing = true
			playingLoopedSounds[sounds.Swimming] = true
		end,

		[Enum.HumanoidStateType.Freefall] = function()
			sounds.FreeFalling.Volume = 0
			stopPlayingLoopedSounds(sounds.FreeFalling)
			playingLoopedSounds[sounds.FreeFalling] = true
		end,

		[Enum.HumanoidStateType.Landed] = function()
			stopPlayingLoopedSounds()
			local verticalSpeed = math.abs(rootPart.Velocity.Y)
			if verticalSpeed > 75 then
				sounds.Landing.Volume = math.clamp(map(verticalSpeed, 50, 100, 0, 1), 0, 1)
				playSound(sounds.Landing)
			end
		end,

		[Enum.HumanoidStateType.Running] = function()
			stopPlayingLoopedSounds(sounds.Running)
			sounds.Running.Playing = true
			playingLoopedSounds[sounds.Running] = true
		end,

		[Enum.HumanoidStateType.Climbing] = function()
			local sound = sounds.Climbing
			if math.abs(rootPart.Velocity.Y) > 0.1 then
				sound.Playing = true
				stopPlayingLoopedSounds(sound)
			else
				stopPlayingLoopedSounds()
			end
			playingLoopedSounds[sound] = true
		end,

		[Enum.HumanoidStateType.Seated] = function()
			stopPlayingLoopedSounds()
		end,

		[Enum.HumanoidStateType.Dead] = function()
			stopPlayingLoopedSounds()
			playSound(sounds.Died)
		end,
	}

	-- updaters for looped sounds
	local loopedSoundUpdaters = {
		[sounds.Climbing] = function(dt, sound, vel)
			sound.Playing = vel.Magnitude > 0.1
		end,

		[sounds.FreeFalling] = function(dt, sound, vel)
			if vel.Magnitude > 75 then
				sound.Volume = math.clamp(sound.Volume + 0.9*dt, 0, 1)
			else
				sound.Volume = 0
			end
		end,

		[sounds.Running] = function(dt, sound, vel)
			sound.Playing = vel.Magnitude > 0.5 and humanoid.MoveDirection.Magnitude > 0.5
		end,
	}

	-- state substitutions to avoid duplicating entries in the state table
	local stateRemap = {
		[Enum.HumanoidStateType.RunningNoPhysics] = Enum.HumanoidStateType.Running,
	}

	local activeState = stateRemap[humanoid:GetState()] or humanoid:GetState()
	local activeConnections = {}

	local stateChangedConn = humanoid.StateChanged:Connect(function(_, state)
		state = stateRemap[state] or state

		if state ~= activeState then
			local transitionFunc = stateTransitions[state]

			if transitionFunc then
				transitionFunc()
			end

			activeState = state
		end
	end)

	local steppedConn = RunService.Stepped:Connect(function(_, worldDt)
		-- update looped sounds on stepped
		for sound in pairs(playingLoopedSounds) do
			local updater = loopedSoundUpdaters[sound]

			if updater then
				updater(worldDt, sound, rootPart.Velocity)
			end
		end
	end)

	local humanoidAncestryChangedConn
	local rootPartAncestryChangedConn

	local function terminate()
		stateChangedConn:Disconnect()
		steppedConn:Disconnect()
		humanoidAncestryChangedConn:Disconnect()
		rootPartAncestryChangedConn:Disconnect()
	end

	humanoidAncestryChangedConn = humanoid.AncestryChanged:Connect(function(_, parent)
		if not parent then
			terminate()
		end
	end)

	rootPartAncestryChangedConn = rootPart.AncestryChanged:Connect(function(_, parent)
		if not parent then
			terminate()
		end
	end)
end

local character = script.Parent
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

return initializeSoundSystem(humanoid, rootPart)
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Model" referent="39">
      <Properties>
        <string name="Name">Soldier</string>
      </Properties>
      <Item class="Script" referent="40">
        <Properties>
          <string name="Name">Animate</string>
          <string name="Source"><![CDATA[local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local animateScriptEmoteHookFlagExists, animateScriptEmoteHookFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserAnimateScriptEmoteHook")
end)
local FFlagAnimateScriptEmoteHook = animateScriptEmoteHookFlagExists and animateScriptEmoteHookFlagEnabled

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			return 1
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return 1
end

local smallButNotZero = 0.0001
function setRunSpeed(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale

	if runSpeed ~= currentAnimSpeed then
		if runSpeed < 0.33 then
			currentAnimTrack:AdjustWeight(1.0)		
			runAnimTrack:AdjustWeight(smallButNotZero)
		elseif runSpeed < 0.66 then
			local weight = ((runSpeed - 0.33) / 0.33)
			currentAnimTrack:AdjustWeight(1.0 - weight + smallButNotZero)
			runAnimTrack:AdjustWeight(weight + smallButNotZero)
		else
			currentAnimTrack:AdjustWeight(smallButNotZero)
			runAnimTrack:AdjustWeight(1.0)
		end
		currentAnimSpeed = runSpeed
		runAnimTrack:AdjustSpeed(runSpeed)
		currentAnimTrack:AdjustSpeed(runSpeed)
	end	
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)	
	if speed > 0.75 then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- emote bindable hook
if FFlagAnimateScriptEmoteHook then
	script:WaitForChild("PlayEmote").OnInvoke = function(emote)
		-- Only play emotes when idling
		if pose ~= "Standing" then
			return
		end
	
		if emoteNames[emote] ~= nil then
			-- Default emotes
			playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
			
			return true
		elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
			-- Non-default emotes
			playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)
			return true
		end
		
		-- Return false to indicate that the emote could not be played
		return false
	end
end

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="41">
        <Properties>
          <string name="Name">Health</string>
          <string name="Source"><![CDATA[-- Gradually regenerates the Humanoid's Health over time.

local REGEN_RATE = 1 / 100 -- Regenerate this fraction of MaxHealth per second.
local REGEN_STEP = 1 -- Wait this long between each regeneration step.

--------------------------------------------------------------------------------

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")

--------------------------------------------------------------------------------

while true do
	while Humanoid.Health < Humanoid.MaxHealth and Humanoid.Health > 0 and Humanoid:GetState() ~= Enum.HumanoidStateType.Dead do
		local dt = wait(REGEN_STEP)
		local dh = dt * REGEN_RATE * Humanoid.MaxHealth
		Humanoid.Health = math.min(Humanoid.Health + dh, Humanoid.MaxHealth)
	end
	Humanoid.HealthChanged:Wait()
end
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="42">
        <Properties>
          <string name="Name">NPC</string>
          <string name="Source"><![CDATA[--[[
	Written by meow_pizza
	Last modified: 2019-03-30
]]

local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local Ragdoll = require(script:WaitForChild("Ragdoll"))
local Maid = require(script:WaitForChild("Maid"))

local function getValueFromConfig(name)
	local configuration = script.Parent:WaitForChild("Configuration")
	local valueObject = configuration and configuration:FindFirstChild(name)
	return valueObject and valueObject.Value
end

--[[
	Configuration
]]

-- Attack configuration
local ATTACK_MODE = getValueFromConfig("AttackMode")
local ATTACK_RADIUS = getValueFromConfig("AttackRadius")
local ATTACK_DAMAGE = getValueFromConfig("AttackDamage")
local ATTACK_DELAY = getValueFromConfig("AttackDelay")
local RELOAD_DELAY = getValueFromConfig("ReloadDelay")
local CLIP_CAPACITY = getValueFromConfig("ClipCapacity")

-- Patrol configuration
local PATROL_ENABLED = getValueFromConfig("PatrolEnabled")
local PATROL_RADIUS = getValueFromConfig("PatrolRadius")

-- Etc
local DESTROY_ON_DEATH = getValueFromConfig("DestroyOnDeath")
local RAGDOLL_ENABLED = getValueFromConfig("RagdollEnabled")

local DEATH_DESTROY_DELAY = 5
local PATROL_WALKSPEED = 12
local MIN_REPOSITION_TIME = 2
local MAX_REPOSITION_TIME = 10
local MAX_PARTS_PER_HEARTBEAT = 50
local SEARCH_DELAY = 1

--[[
	Instance references
]]

local maid = Maid.new()
maid.instance = script.Parent

maid.humanoid = maid.instance:WaitForChild("Humanoid")
maid.head = maid.instance:WaitForChild("Head")
maid.humanoidRootPart = maid.instance:FindFirstChild("HumanoidRootPart")
maid.alignOrientation = maid.humanoidRootPart:FindFirstChild("AlignOrientation")

-- Sounds
maid.gunFireSound = maid.instance.Weapon.Handle:FindFirstChild("Fire")

--[[
	State
]]

local startPosition = maid.instance.PrimaryPart.Position

-- Attack state
local attacking = false
local searchingForTargets = false

-- Target finding state
local target = nil
local newTarget = nil
local newTargetDistance = nil
local searchIndex = 0
local timeSearchEnded = 0
local searchRegion = nil
local searchParts = nil

--[[
	Instance configuration
]]

-- Create an Attachment in the terrain so the AlignOrientation is world realtive
local worldAttachment = Instance.new("Attachment")
worldAttachment.Name = "SoldierWorldAttachment"
worldAttachment.Parent = Workspace.Terrain

maid.worldAttachment = worldAttachment
maid.humanoidRootPart.AlignOrientation.Attachment1 = worldAttachment

-- Load and configure the animations
local attackIdleAnimation = maid.humanoid:LoadAnimation(maid.instance.Animations.AttackIdleAnimation)
attackIdleAnimation.Looped = true
attackIdleAnimation.Priority = Enum.AnimationPriority.Action
maid.attackIdleAnimation = attackIdleAnimation

local attackAnimation = maid.humanoid:LoadAnimation(maid.instance.Animations.AttackAnimation)
attackAnimation.Looped = false
attackAnimation.Priority = Enum.AnimationPriority.Action
maid.attackAnimation = attackAnimation

--[[
	Helper functions
]]

local random = Random.new()

local function getRandomPointInCircle(centerPosition, circleRadius)
	local radius = math.sqrt(random:NextNumber()) * circleRadius
	local angle = random:NextNumber(0, math.pi * 2)
	local x = centerPosition.X + radius * math.cos(angle)
	local z = centerPosition.Z + radius * math.sin(angle)

	local position = Vector3.new(x, centerPosition.Y, z)

	return position
end

--[[
	Implementation
]]

local function isAlive()
	return maid.humanoid.Health > 0 and maid.humanoid:GetState() ~= Enum.HumanoidStateType.Dead
end

local function destroy()
	maid:destroy()
end

local function patrol()
	while isAlive() do
		if not attacking then
			local position = getRandomPointInCircle(startPosition, PATROL_RADIUS)
			maid.humanoid.WalkSpeed = PATROL_WALKSPEED
			maid.humanoid:MoveTo(position)
		end

		wait(random:NextInteger(MIN_REPOSITION_TIME, MAX_REPOSITION_TIME))
	end
end

local function isInstaceAttackable(targetInstance)
	local isAttackable = false
	
	local targetHumanoid = targetInstance and targetInstance.Parent and targetInstance.Parent:FindFirstChild("Humanoid")
	if not targetHumanoid then
		return false
	end

	-- Determine if they are attackable, depening on the attack mode
	local isEnemy = false
	if ATTACK_MODE == 1 then
		-- Attack characters with the SoldierEnemy tag
		if
			CollectionService:HasTag(targetInstance.Parent, "SoldierEnemy") and
			not CollectionService:HasTag(targetInstance.Parent, "SoldierFriend") then
			isEnemy = true
		end
	elseif ATTACK_MODE == 2 then
		-- Attack all humanoids without the SoldierFriend tag
		if not CollectionService:HasTag(targetInstance.Parent, "SoldierFriend") then
			isEnemy = true
		end
	elseif ATTACK_MODE == 3 then
		-- Attack all humanoids
		isEnemy = true
	end

	if isEnemy then
		local distance = (maid.humanoidRootPart.Position - targetInstance.Position).Magnitude
	
		if distance <= ATTACK_RADIUS then
			local ray = Ray.new(
				maid.humanoidRootPart.Position,
				(targetInstance.Parent.HumanoidRootPart.Position - maid.humanoidRootPart.Position).Unit * distance
			)
	
			local part = Workspace:FindPartOnRayWithIgnoreList(ray, {
				targetInstance.Parent, maid.instance,
			}, false, true)
	
			if
				targetInstance ~= maid.instance and
				targetInstance:IsDescendantOf(Workspace) and
				targetHumanoid.Health > 0 and
				targetHumanoid:GetState() ~= Enum.HumanoidStateType.Dead and
				not part
			then
				isAttackable = true
			end
		end		
	end

	return isAttackable
end

local function fireGun()
	-- Do damage to the target
	local targetHunanoid = target.Parent:FindFirstChild("Humanoid")
	targetHunanoid:TakeDamage(ATTACK_DAMAGE)

	-- Play the firing animation
	maid.attackAnimation:Play()

	-- Play the firing sound effect
	maid.gunFireSound:Play()

	-- Muzzle flash
	local firingPositionAttachment = maid.instance.Weapon.Handle.FiringPositionAttachment
	firingPositionAttachment.FireEffect:Emit(10)
	firingPositionAttachment.PointLight.Enabled = true

	wait(0.1)

	firingPositionAttachment.PointLight.Enabled = false
end

local function findTargets()
	-- Do a new search region if we are not already searching through an existing search region
	if not searchingForTargets and tick() - timeSearchEnded >= SEARCH_DELAY then
		searchingForTargets = true

		-- Create a new region
		local centerPosition = maid.humanoidRootPart.Position
		local topCornerPosition = centerPosition + Vector3.new(ATTACK_RADIUS, ATTACK_RADIUS, ATTACK_RADIUS)
		local bottomCornerPosition = centerPosition + Vector3.new(-ATTACK_RADIUS, -ATTACK_RADIUS, -ATTACK_RADIUS)

		searchRegion = Region3.new(bottomCornerPosition, topCornerPosition)
		searchParts = Workspace:FindPartsInRegion3(searchRegion, maid.instance, math.huge)

		newTarget = nil
		newTargetDistance = nil

		-- Reset to defaults
		searchIndex = 1
	end

	if searchingForTargets then
		-- Search through our list of parts and find attackable humanoids
		local checkedParts = 0
		while searchingForTargets and searchIndex <= #searchParts and checkedParts < MAX_PARTS_PER_HEARTBEAT do
			local currentPart = searchParts[searchIndex]
			if currentPart and isInstaceAttackable(currentPart) then
				local character = currentPart.Parent
				local distance = (character.HumanoidRootPart.Position - maid.humanoidRootPart.Position).magnitude

				-- Determine if the charater is the closest
				if not newTargetDistance or distance < newTargetDistance then
					newTarget = character.HumanoidRootPart
					newTargetDistance = distance
				end
			end

			searchIndex = searchIndex + 1

			checkedParts = checkedParts + 1
		end

		if searchIndex >= #searchParts then
			target = newTarget
			searchingForTargets = false
			timeSearchEnded = tick()
		end
	end
end

local function attack()
	attacking = true

	local originalWalkSpeed = maid.humanoid.WalkSpeed
	maid.humanoid.WalkSpeed = 0

	maid.attackIdleAnimation:Play()

	local shotsFired = 0
	while attacking and isInstaceAttackable(target) and isAlive() do
		fireGun()

		shotsFired = (shotsFired + 1) % CLIP_CAPACITY

		if shotsFired == CLIP_CAPACITY - 1 then
			wait(RELOAD_DELAY)
		else
			wait(ATTACK_DELAY)
		end
	end

	maid.humanoid.WalkSpeed = originalWalkSpeed

	maid.attackIdleAnimation:Stop()

	attacking = false
end

--[[
	Event functions
]]

local function onHeartbeat()
	if target then
		-- Point towards the enemy
		maid.alignOrientation.Enabled = true
		maid.worldAttachment.CFrame = CFrame.new(maid.humanoidRootPart.Position, target.Position)
	else
		maid.alignOrientation.Enabled = false
	end

	-- Check if the current target no longer exists or is not attackable
	if not target or not isInstaceAttackable(target) then
		findTargets()
	end
end

local function died()
	target = nil
	attacking = false
	newTarget = nil
	searchParts = nil
	searchingForTargets = false

	maid.heartbeatConnection:Disconnect()

	if RAGDOLL_ENABLED then
		Ragdoll(maid.instance, maid.humanoid)
	end

	if DESTROY_ON_DEATH then
		delay(DEATH_DESTROY_DELAY, function()
			destroy()
		end)
	end
end

--[[
	Connections
]]

maid.heartbeatConnection = RunService.Heartbeat:Connect(function()
	onHeartbeat()
end)

maid.diedConnection = maid.humanoid.Died:Connect(function()
	died()
end)

--[[
	Start
]]

if PATROL_ENABLED then
	coroutine.wrap(function()
		patrol()
	end)()
end

coroutine.wrap(function()
	while isAlive() do
		if target and not attacking and isInstaceAttackable(target) then
			attack()
		end

		wait(1)
	end
end)()
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="43">
          <Properties>
            <string name="Name">Maid</string>
            <string name="Source"><![CDATA[local Maid = {}

function Maid.new()
	local self = {
		_tasks = {},
	}
	setmetatable(self, Maid)

	return self
end

function Maid:__index(key)
	return Maid[key] or self._tasks[key]
end

function Maid:__newindex(key, newTask)
	if Maid[key] then
		error(string.format("Cannot use %q as a Maid key", tostring(key)))
	end
	local tasks = self._tasks
	local oldTask = tasks[key]
	tasks[key] = newTask

	if oldTask then
		Maid.cleanupTask(oldTask)
	end
end

function Maid:give(task)
	local tasks = self._tasks
	tasks[#tasks+1] = task
end

function Maid.cleanupTask(task)
	local taskTy = typeof(task)
	if taskTy == 'function' then
		task()
	elseif taskTy == 'RBXScriptConnection' then
		task:Disconnect()
	elseif taskTy == 'Instance' then
		task:Destroy()
	elseif task.Destroy then
		task:Destroy()
	elseif task.destroy then
		task:destroy()
	elseif task.disconnect then
		task:disconnect()
	else
		error("Unable to cleanup unknown task")
	end
end

function Maid:clean()
	local tasks = self._tasks

	for key,task in pairs(tasks) do
		if typeof(task) == 'RBXScriptConnection' then
			tasks[key] = nil
			task:Disconnect()
		end
	end

	local index, task = next(tasks)
	while task ~= nil do
		tasks[index] = nil
		Maid.cleanupTask(task)
		index, task = next(tasks)
	end
end

Maid.destroy = Maid.clean
Maid.Destroy = Maid.clean

return Maid
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="44">
          <Properties>
            <string name="Name">Ragdoll</string>
            <string name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")

local RigTypes = require(script.RigTypes)

local RAGDOLLED_TAG = "__Ragdoll_Active"

local function ragdoll(model, humanoid)
	assert(humanoid:IsDescendantOf(model))
	if CollectionService:HasTag(model, RAGDOLLED_TAG) then
		return
	end
	CollectionService:AddTag(model, RAGDOLLED_TAG)

	-- Turn into loose body:
	humanoid:ChangeState(Enum.HumanoidStateType.Physics)

	-- Instantiate BallSocketConstraints:
	local attachments = RigTypes.getAttachments(model, humanoid.RigType)
	for name, objects in pairs(attachments) do
		local parent = model:FindFirstChild(name)
		if parent then
			local constraint = Instance.new("BallSocketConstraint")
			constraint.Name = "RagdollBallSocketConstraint"
			constraint.Attachment0 = objects.attachment0
			constraint.Attachment1 = objects.attachment1
			constraint.LimitsEnabled = true
			constraint.UpperAngle = objects.limits.UpperAngle
			constraint.TwistLimitsEnabled = true
			constraint.TwistLowerAngle = objects.limits.TwistLowerAngle
			constraint.TwistUpperAngle = objects.limits.TwistUpperAngle
			constraint.Parent = parent
		end
	end

	-- Instantiate NoCollisionConstraints:
	local parts = RigTypes.getNoCollisions(model, humanoid.RigType)
	for _, objects in pairs(parts) do
		local constraint = Instance.new("NoCollisionConstraint")
		constraint.Name = "RagdollNoCollisionConstraint"
		constraint.Part0 = objects[1]
		constraint.Part1 = objects[2]
		constraint.Parent = objects[1]
	end

	-- Destroy all regular joints:
	for _, motor in pairs(model:GetDescendants()) do
		if motor:IsA("Motor6D") then
			motor:Destroy()
		end
	end
end

return ragdoll
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="45">
            <Properties>
              <string name="Name">RigTypes</string>
              <string name="Source"><![CDATA[local RigTypes = {}

local HEAD_LIMITS = {
	UpperAngle = 60;
	TwistLowerAngle = -60;
	TwistUpperAngle = 60;
}

local LOWER_TORSO_LIMITS = {
	UpperAngle = 20;
	TwistLowerAngle = -30;
	TwistUpperAngle = 60;
}

local HAND_FOOT_LIMITS = {
	UpperAngle = 10;
	TwistLowerAngle = -10;
	TwistUpperAngle = 10;
}

local ELBOW_LIMITS = {
	UpperAngle = 30;
	TwistLowerAngle = 0;
	TwistUpperAngle = 120;
}

local KNEE_LIMITS = {
	UpperAngle = 30;
	TwistLowerAngle = -120;
	TwistUpperAngle = 0;
}

local SHOULDER_LIMITS = {
	UpperAngle = 60;
	TwistLowerAngle = -60;
	TwistUpperAngle = 175;
}

local HIP_LIMITS = {
	UpperAngle = 40;
	TwistLowerAngle = -5;
	TwistUpperAngle = 150;
}

local R6_HEAD_LIMITS = {
	UpperAngle = 30;
	TwistLowerAngle = -60;
	TwistUpperAngle = 60;
}

local R6_SHOULDER_LIMITS = {
	UpperAngle = 90;
	TwistLowerAngle = -30;
	TwistUpperAngle = 175;
}

local R6_HIP_LIMITS = {
	UpperAngle = 60;
	TwistLowerAngle = -5;
	TwistUpperAngle = 120;
}

local function createJointData(attach0, attach1, limits)
	assert(attach0)
	assert(attach1)
	assert(limits)
	assert(limits.UpperAngle >= 0)
	assert(limits.TwistLowerAngle <= limits.TwistUpperAngle)

	return {
		attachment0 = attach0,
		attachment1 = attach1,
		limits = limits
	}
end

local function find(model)
	return function(first, second, limits)
		local part0 = model:FindFirstChild(first[1])
		local part1 = model:FindFirstChild(second[1])
		if part0 and part1 then
			local attach0 = part0:FindFirstChild(first[2])
			local attach1 = part1:FindFirstChild(second[2])
			if attach0 and attach1 and attach0:IsA("Attachment") and attach1:IsA("Attachment") then
				return createJointData(attach0, attach1, limits)
			end
		end
	end
end

function RigTypes.getNoCollisions(model, rigType)
	if rigType == Enum.HumanoidRigType.R6 then
		return RigTypes.getR6NoCollisions(model)
	elseif rigType == Enum.HumanoidRigType.R15 then
		return RigTypes.getR15NoCollisions(model)
	else
		return {}
	end
end

-- Get list of attachments to make ballsocketconstraints between:
function RigTypes.getAttachments(model, rigType)
	if rigType == Enum.HumanoidRigType.R6 then
		return RigTypes.getR6Attachments(model)
	elseif rigType == Enum.HumanoidRigType.R15 then
		return RigTypes.getR15Attachments(model)
	else
		return {}
	end
end

function RigTypes.getR6Attachments(model)
	local rightLegAttachment = Instance.new("Attachment")
	rightLegAttachment.Name = "RagdollRightLegAttachment"
	rightLegAttachment.Position = Vector3.new(0, 1, 0)
	rightLegAttachment.Parent = model:FindFirstChild("Right Leg")

	local leftLegAttachment = Instance.new("Attachment")
	leftLegAttachment.Name = "RagdollLeftLegAttachment"
	leftLegAttachment.Position = Vector3.new(0, 1, 0)
	leftLegAttachment.Parent = model:FindFirstChild("Left Leg")

	local torsoLeftAttachment = Instance.new("Attachment")
	torsoLeftAttachment.Name = "RagdollTorsoLeftAttachment"
	torsoLeftAttachment.Position = Vector3.new(-0.5, -1, 0)
	torsoLeftAttachment.Parent = model:FindFirstChild("Torso")

	local torsoRightAttachment = Instance.new("Attachment")
	torsoRightAttachment.Name = "RagdollTorsoRightAttachment"
	torsoRightAttachment.Position = Vector3.new(0.5, -1, 0)
	torsoRightAttachment.Parent = model:FindFirstChild("Torso")

	local headAttachment = Instance.new("Attachment")
	headAttachment.Name = "RagdollHeadAttachment"
	headAttachment.Position = Vector3.new(0, -0.5, 0)
	headAttachment.Parent = model:FindFirstChild("Head")

	local leftArmAttachment = Instance.new("Attachment")
	leftArmAttachment.Name = "RagdollLeftArmAttachment"
	leftArmAttachment.Position = Vector3.new(0.5, 1, 0)
	leftArmAttachment.Parent = model:FindFirstChild("Left Arm")

	local ragdollRightArmAttachment = Instance.new("Attachment")
	ragdollRightArmAttachment.Name = "RagdollRightArmAttachment"
	ragdollRightArmAttachment.Position = Vector3.new(-0.5, 1, 0)
	ragdollRightArmAttachment.Parent = model:FindFirstChild("Right Arm")

	local query = find(model)

	return {
		Head = query(
			{"Torso", "NeckAttachment"},
			{"Head", "RagdollHeadAttachment"},
			R6_HEAD_LIMITS),
		["Left Arm"] = query(
			{"Torso", "LeftCollarAttachment"},
			{"Left Arm", "RagdollLeftArmAttachment"},
			R6_SHOULDER_LIMITS),
		["Right Arm"] = query(
			{"Torso", "RightCollarAttachment"},
			{"Right Arm", "RagdollRightArmAttachment"},
			R6_SHOULDER_LIMITS),
		["Left Leg"] = createJointData(torsoLeftAttachment, leftLegAttachment, R6_HIP_LIMITS),
		["Right Leg"] = createJointData(torsoRightAttachment, rightLegAttachment, R6_HIP_LIMITS),
	}
end

function RigTypes.getR15Attachments(model)
	local query = find(model)

	return {
		Head = query(
			{"UpperTorso", "NeckRigAttachment"},
			{"Head", "NeckRigAttachment"},
			HEAD_LIMITS),

		LowerTorso = query(
			{"UpperTorso", "WaistRigAttachment"},
			{"LowerTorso", "RootRigAttachment"},
			LOWER_TORSO_LIMITS),

		LeftUpperArm = query(
			{"UpperTorso", "LeftShoulderRigAttachment"},
			{"LeftUpperArm", "LeftShoulderRigAttachment"},
			SHOULDER_LIMITS),
		LeftLowerArm = query(
			{"LeftUpperArm", "LeftElbowRigAttachment"},
			{"LeftLowerArm", "LeftElbowRigAttachment"},
			ELBOW_LIMITS),
		LeftHand = query(
			{"LeftLowerArm", "LeftWristRigAttachment"},
			{"LeftHand", "LeftWristRigAttachment"},
			HAND_FOOT_LIMITS),

		RightUpperArm = query(
			{"UpperTorso", "RightShoulderRigAttachment"},
			{"RightUpperArm", "RightShoulderRigAttachment"},
			SHOULDER_LIMITS),
		RightLowerArm = query(
			{"RightUpperArm", "RightElbowRigAttachment"},
			{"RightLowerArm", "RightElbowRigAttachment"},
			ELBOW_LIMITS),
		RightHand = query(
			{"RightLowerArm", "RightWristRigAttachment"},
			{"RightHand", "RightWristRigAttachment"},
			HAND_FOOT_LIMITS),

		LeftUpperLeg = query(
			{"LowerTorso", "LeftHipRigAttachment"},
			{"LeftUpperLeg", "LeftHipRigAttachment"},
			HIP_LIMITS),
		LeftLowerLeg = query(
			{"LeftUpperLeg", "LeftKneeRigAttachment"},
			{"LeftLowerLeg", "LeftKneeRigAttachment"},
			KNEE_LIMITS),
		LeftFoot = query(
			{"LeftLowerLeg", "LeftAnkleRigAttachment"},
			{"LeftFoot", "LeftAnkleRigAttachment"},
			HAND_FOOT_LIMITS),

		RightUpperLeg = query(
			{"LowerTorso", "RightHipRigAttachment"},
			{"RightUpperLeg", "RightHipRigAttachment"},
			HIP_LIMITS),
		RightLowerLeg = query(
			{"RightUpperLeg", "RightKneeRigAttachment"},
			{"RightLowerLeg", "RightKneeRigAttachment"},
			KNEE_LIMITS),
		RightFoot = query(
			{"RightLowerLeg", "RightAnkleRigAttachment"},
			{"RightFoot", "RightAnkleRigAttachment"},
			HAND_FOOT_LIMITS),
	}
end

function RigTypes.getR6NoCollisions(model)
	local list = {}

	local function addPair(pair)
		local part0 = model:FindFirstChild(pair[1])
		local part1 = model:FindFirstChild(pair[2])

		if part0 and part1 then
			table.insert(list, {part0, part1})
		end
	end

	addPair({"Head", "Torso"})
	addPair({"Left Arm", "Torso"})
	addPair({"Right Arm", "Torso"})
	addPair({"Left Leg", "Torso"})
	addPair({"Right Leg", "Torso"})

	addPair({"Left Leg", "Right Leg"})

	return list
end


function RigTypes.getR15NoCollisions(model)
	local list = {}

	local function addPair(pair)
		local part0 = model:FindFirstChild(pair[1])
		local part1 = model:FindFirstChild(pair[2])

		if part0 and part1 then
			table.insert(list, {part0, part1})
		end
	end

	addPair({"Head", "UpperTorso"})
	addPair({"UpperTorso", "LowerTorso"})

	addPair({"UpperTorso", "LeftUpperArm"})
	addPair({"LowerTorso", "LeftUpperArm"})
	addPair({"LeftUpperArm", "LeftLowerArm"})
	addPair({"LeftLowerArm", "LeftHand"})
	addPair({"LeftUpperArm", "LeftHand"})

	addPair({"UpperTorso", "RightUpperArm"})
	addPair({"LowerTorso", "RightUpperArm"})
	addPair({"RightUpperArm", "RightLowerArm"})
	addPair({"RightLowerArm", "RightHand"})
	addPair({"RightUpperArm", "RightHand"})

	addPair({"LeftUpperLeg", "RightUpperLeg"})

	addPair({"UpperTorso", "RightUpperLeg"})
	addPair({"LowerTorso", "RightUpperLeg"})
	addPair({"RightUpperLeg", "RightLowerLeg"})
	addPair({"RightLowerLeg", "RightFoot"})
	addPair({"RightUpperLeg", "RightFoot"})

	addPair({"UpperTorso", "LeftUpperLeg"})
	addPair({"LowerTorso", "LeftUpperLeg"})
	addPair({"LeftUpperLeg", "LeftLowerLeg"})
	addPair({"LeftLowerLeg", "LeftFoot"})
	addPair({"LeftUpperLeg", "LeftFoot"})

	-- Support weird R15 rigs
	addPair({"UpperTorso", "LeftLowerLeg"})
	addPair({"UpperTorso", "RightLowerLeg"})
	addPair({"LowerTorso", "LeftLowerLeg"})
	addPair({"LowerTorso", "RightLowerLeg"})

	addPair({"UpperTorso", "LeftLowerArm"})
	addPair({"UpperTorso", "RightLowerArm"})

	local upperTorso = model:FindFirstChild("UpperTorso")
	if upperTorso and upperTorso.Size.x <= 1.5 then
		addPair({"Head", "LeftUpperArm"})
		addPair({"Head", "RightUpperArm"})
	end

	return list
end

return RigTypes
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Script" referent="46">
        <Properties>
          <string name="Name">RbxNpcSounds</string>
          <string name="Source"><![CDATA[-- Roblox NPC sound script

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local SOUND_DATA = {
	Climbing = {
		SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
		Looped = true,
	},
	Died = {
		SoundId = "",
	},
	FreeFalling = {
		SoundId = "rbxasset://sounds/action_falling.mp3",
		Looped = true,
	},
	GettingUp = {
		SoundId = "rbxasset://sounds/action_get_up.mp3",
	},
	Jumping = {
		SoundId = "rbxasset://sounds/action_jump.mp3",
	},
	Landing = {
		SoundId = "rbxasset://sounds/action_jump_land.mp3",
	},
	Running = {
		SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
		Looped = true,
		Pitch = 1.85,
	},
	Splash = {
		SoundId = "rbxasset://sounds/impact_water.mp3",
	},
	Swimming = {
		SoundId = "rbxasset://sounds/action_swim.mp3",
		Looped = true,
		Pitch = 1.6,
	},
}

-- map a value from one range to another
local function map(x, inMin, inMax, outMin, outMax)
	return (x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin
end

local function playSound(sound)
	sound.TimePosition = 0
	sound.Playing = true
end

local function stopSound(sound)
	sound.Playing = false
	sound.TimePosition = 0
end

local function initializeSoundSystem(humanoid, rootPart)
	local sounds = {}

	-- initialize sounds
	for name, props in pairs(SOUND_DATA) do
		local sound = Instance.new("Sound")
		sound.Name = name

		-- set default values
		sound.Archivable = false
		sound.EmitterSize = 5
		sound.MaxDistance = 150
		sound.Volume = 0.65

		for propName, propValue in pairs(props) do
			sound[propName] = propValue
		end

		sound.Parent = rootPart
		sounds[name] = sound
	end

	local playingLoopedSounds = {}

	local function stopPlayingLoopedSounds(except)
		for sound in pairs(playingLoopedSounds) do
			if sound ~= except then
				sound.Playing = false
				playingLoopedSounds[sound] = nil
			end
		end
	end

	-- state transition callbacks
	local stateTransitions = {
		[Enum.HumanoidStateType.FallingDown] = function()
			stopPlayingLoopedSounds()
		end,

		[Enum.HumanoidStateType.GettingUp] = function()
			stopPlayingLoopedSounds()
			playSound(sounds.GettingUp)
		end,

		[Enum.HumanoidStateType.Jumping] = function()
			stopPlayingLoopedSounds()
			playSound(sounds.Jumping)
		end,

		[Enum.HumanoidStateType.Swimming] = function()
			local verticalSpeed = math.abs(rootPart.Velocity.Y)
			if verticalSpeed > 0.1 then
				sounds.Splash.Volume = math.clamp(map(verticalSpeed, 100, 350, 0.28, 1), 0, 1)
				playSound(sounds.Splash)
			end
			stopPlayingLoopedSounds(sounds.Swimming)
			sounds.Swimming.Playing = true
			playingLoopedSounds[sounds.Swimming] = true
		end,

		[Enum.HumanoidStateType.Freefall] = function()
			sounds.FreeFalling.Volume = 0
			stopPlayingLoopedSounds(sounds.FreeFalling)
			playingLoopedSounds[sounds.FreeFalling] = true
		end,

		[Enum.HumanoidStateType.Landed] = function()
			stopPlayingLoopedSounds()
			local verticalSpeed = math.abs(rootPart.Velocity.Y)
			if verticalSpeed > 75 then
				sounds.Landing.Volume = math.clamp(map(verticalSpeed, 50, 100, 0, 1), 0, 1)
				playSound(sounds.Landing)
			end
		end,

		[Enum.HumanoidStateType.Running] = function()
			stopPlayingLoopedSounds(sounds.Running)
			sounds.Running.Playing = true
			playingLoopedSounds[sounds.Running] = true
		end,

		[Enum.HumanoidStateType.Climbing] = function()
			local sound = sounds.Climbing
			if math.abs(rootPart.Velocity.Y) > 0.1 then
				sound.Playing = true
				stopPlayingLoopedSounds(sound)
			else
				stopPlayingLoopedSounds()
			end
			playingLoopedSounds[sound] = true
		end,

		[Enum.HumanoidStateType.Seated] = function()
			stopPlayingLoopedSounds()
		end,

		[Enum.HumanoidStateType.Dead] = function()
			stopPlayingLoopedSounds()
			playSound(sounds.Died)
		end,
	}

	-- updaters for looped sounds
	local loopedSoundUpdaters = {
		[sounds.Climbing] = function(dt, sound, vel)
			sound.Playing = vel.Magnitude > 0.1
		end,

		[sounds.FreeFalling] = function(dt, sound, vel)
			if vel.Magnitude > 75 then
				sound.Volume = math.clamp(sound.Volume + 0.9*dt, 0, 1)
			else
				sound.Volume = 0
			end
		end,

		[sounds.Running] = function(dt, sound, vel)
			sound.Playing = vel.Magnitude > 0.5 and humanoid.MoveDirection.Magnitude > 0.5
		end,
	}

	-- state substitutions to avoid duplicating entries in the state table
	local stateRemap = {
		[Enum.HumanoidStateType.RunningNoPhysics] = Enum.HumanoidStateType.Running,
	}

	local activeState = stateRemap[humanoid:GetState()] or humanoid:GetState()
	local activeConnections = {}

	local stateChangedConn = humanoid.StateChanged:Connect(function(_, state)
		state = stateRemap[state] or state

		if state ~= activeState then
			local transitionFunc = stateTransitions[state]

			if transitionFunc then
				transitionFunc()
			end

			activeState = state
		end
	end)

	local steppedConn = RunService.Stepped:Connect(function(_, worldDt)
		-- update looped sounds on stepped
		for sound in pairs(playingLoopedSounds) do
			local updater = loopedSoundUpdaters[sound]

			if updater then
				updater(worldDt, sound, rootPart.Velocity)
			end
		end
	end)

	local humanoidAncestryChangedConn
	local rootPartAncestryChangedConn

	local function terminate()
		stateChangedConn:Disconnect()
		steppedConn:Disconnect()
		humanoidAncestryChangedConn:Disconnect()
		rootPartAncestryChangedConn:Disconnect()
	end

	humanoidAncestryChangedConn = humanoid.AncestryChanged:Connect(function(_, parent)
		if not parent then
			terminate()
		end
	end)

	rootPartAncestryChangedConn = rootPart.AncestryChanged:Connect(function(_, parent)
		if not parent then
			terminate()
		end
	end)
end

local character = script.Parent
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

return initializeSoundSystem(humanoid, rootPart)
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Model" referent="47">
      <Properties>
        <string name="Name">Zombie</string>
      </Properties>
      <Item class="Script" referent="48">
        <Properties>
          <string name="Name">Animate</string>
          <string name="Source"><![CDATA[local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")
local pose = "Standing"

local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

local animateScriptEmoteHookFlagExists, animateScriptEmoteHookFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserAnimateScriptEmoteHook")
end)
local FFlagAnimateScriptEmoteHook = animateScriptEmoteHookFlagExists and animateScriptEmoteHookFlagEnabled

local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
local HumanoidHipHeight = 2

local EMOTE_TRANSITION_TIME = 0.1

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0

local runAnimTrack = nil
local runAnimKeyframeHandler = nil

local PreloadedAnims = {}

local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=507766666", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766951", weight = 1 },
				{ id = "http://www.roblox.com/asset/?id=507766388", weight = 9 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=507777826", weight = 10 } 
			}, 
	run = 	{
				{ id = "http://www.roblox.com/asset/?id=507767714", weight = 10 } 
			}, 
	swim = 	{
				{ id = "http://www.roblox.com/asset/?id=507784897", weight = 10 } 
			}, 
	swimidle = 	{
				{ id = "http://www.roblox.com/asset/?id=507785072", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=507765000", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=507767968", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=507765644", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=2506281703", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=507768375", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=522635514", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=522638767", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=507770239", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=507770453", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=507771019", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507771955", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507772104", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=507776043", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776720", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507776879", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=507777268", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777451", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=507777623", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=507770818", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=507770677", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function findExistingAnimationInSet(set, anim)
	if set == nil or anim == nil then
		return 0
	end
	
	for idx = 1, set.count, 1 do 
		if set[idx].anim.AnimationId == anim.AnimationId then
			return idx
		end
	end
	
	return 0
end

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		
		local idx = 0
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				local newWeight = 1
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject ~= nil) then
					newWeight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				idx = animTable[name].count
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				animTable[name][idx].weight = newWeight
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
				table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
			end
		end
	end
	
	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do
			if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
				Humanoid:LoadAnimation(animType[idx].anim)
				PreloadedAnims[animType[idx].anim.AnimationId] = true
			end				
		end
	end
end

------------------------------------------------------------------------------------------------------------

function configureAnimationSetOld(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	local allowCustomAnimations = true

	local success, msg = pcall(function() allowCustomAnimations = game:GetService("StarterPlayer").AllowCustomAnimations end)
	if not success then
		allowCustomAnimations = true
	end

	-- check for config values
	local config = script:FindFirstChild(name)
	if (allowCustomAnimations and config ~= nil) then
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			-- print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
	
	-- preload anims
	for i, animType in pairs(animTable) do
		for idx = 1, animType.count, 1 do 
			Humanoid:LoadAnimation(animType[idx].anim)
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.31

local toolTransitionTime = 0.1
local fallTransitionTime = 0.2

local currentlyPlayingEmote = false

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end
	
	if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
		oldAnim = "idle"
		currentlyPlayingEmote = false
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end

	-- clean up walk if there is one
	if (runAnimKeyframeHandler ~= nil) then
		runAnimKeyframeHandler:disconnect()
	end
	
	if (runAnimTrack ~= nil) then
		runAnimTrack:Stop()
		runAnimTrack:Destroy()
		runAnimTrack = nil
	end
	
	return oldAnim
end

function getHeightScale()
	if Humanoid then
		if not Humanoid.AutomaticScalingEnabled then
			return 1
		end
		
		local scale = Humanoid.HipHeight / HumanoidHipHeight
		if AnimationSpeedDampeningObject == nil then
			AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
		end
		if AnimationSpeedDampeningObject ~= nil then
			scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
		end
		return scale
	end	
	return 1
end

local smallButNotZero = 0.0001
function setRunSpeed(speed)
	local speedScaled = speed * 1.25
	local heightScale = getHeightScale()
	local runSpeed = speedScaled / heightScale

	if runSpeed ~= currentAnimSpeed then
		if runSpeed < 0.33 then
			currentAnimTrack:AdjustWeight(1.0)		
			runAnimTrack:AdjustWeight(smallButNotZero)
		elseif runSpeed < 0.66 then
			local weight = ((runSpeed - 0.33) / 0.33)
			currentAnimTrack:AdjustWeight(1.0 - weight + smallButNotZero)
			runAnimTrack:AdjustWeight(weight + smallButNotZero)
		else
			currentAnimTrack:AdjustWeight(smallButNotZero)
			runAnimTrack:AdjustWeight(1.0)
		end
		currentAnimSpeed = runSpeed
		runAnimTrack:AdjustSpeed(runSpeed)
		currentAnimTrack:AdjustSpeed(runSpeed)
	end	
end

function setAnimationSpeed(speed)
	if currentAnim == "walk" then
			setRunSpeed(speed)
	else
		if speed ~= currentAnimSpeed then
			currentAnimSpeed = speed
			currentAnimTrack:AdjustSpeed(currentAnimSpeed)
		end
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
		if currentAnim == "walk" then
			if userNoUpdateOnLoop == true then
				if runAnimTrack.Looped ~= true then
					runAnimTrack.TimePosition = 0.0
				end
				if currentAnimTrack.Looped ~= true then
					currentAnimTrack.TimePosition = 0.0
				end
			else
				runAnimTrack.TimePosition = 0.0
				currentAnimTrack.TimePosition = 0.0
			end
		else
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end
			
			if FFlagAnimateScriptEmoteHook and currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end
				
				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end
			
			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end
end

function rollAnimation(animName)
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
	return idx
end

local function switchToAnim(anim, animName, transitionTime, humanoid)
	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		if (runAnimTrack ~= nil) then
			runAnimTrack:Stop(transitionTime)
			runAnimTrack:Destroy()
			if userNoUpdateOnLoop == true then
				runAnimTrack = nil
			end
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
		-- check to see if we need to blend a walk/run animation
		if animName == "walk" then
			local runAnimName = "run"
			local runIdx = rollAnimation(runAnimName)

			runAnimTrack = humanoid:LoadAnimation(animTable[runAnimName][runIdx].anim)
			runAnimTrack.Priority = Enum.AnimationPriority.Core
			runAnimTrack:Play(transitionTime)		
			
			if (runAnimKeyframeHandler ~= nil) then
				runAnimKeyframeHandler:disconnect()
			end
			runAnimKeyframeHandler = runAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)	
		end
	end
end

function playAnimation(animName, transitionTime, humanoid) 	
	local idx = rollAnimation(animName)
	local anim = animTable[animName][idx].anim

	switchToAnim(anim, animName, transitionTime, humanoid)
	currentlyPlayingEmote = false
end

function playEmote(emoteAnim, transitionTime, humanoid)
	switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
	currentlyPlayingEmote = true
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 		
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end

	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
-- STATE CHANGE HANDLERS

function onRunning(speed)	
	if speed > 0.75 then
		local scale = 16.0
		playAnimation("walk", 0.2, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
			playAnimation("idle", 0.2, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	local scale = 5.0
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / scale)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

function onSwimming(speed)
	if speed > 1.00 then
		local scale = 10.0
		playAnimation("swim", 0.4, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Swimming"
	else
		playAnimation("swimidle", 0.4, Humanoid)
		pose = "Standing"
	end
end

function animateTool()
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

local lastTick = 0

function stepAnimate(currentTime)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = currentTime - lastTick
  	lastTick = currentTime

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.2, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	-- Tool Animation handling
	local tool = Character:FindFirstChildOfClass("Tool")
	if tool and tool:FindFirstChild("Handle") then
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = currentTime + .3
		end

		if currentTime > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- emote bindable hook
if FFlagAnimateScriptEmoteHook then
	script:WaitForChild("PlayEmote").OnInvoke = function(emote)
		-- Only play emotes when idling
		if pose ~= "Standing" then
			return
		end
	
		if emoteNames[emote] ~= nil then
			-- Default emotes
			playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
			
			return true
		elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
			-- Non-default emotes
			playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)
			return true
		end
		
		-- Return false to indicate that the emote could not be played
		return false
	end
end

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

-- loop to handle timed state transitions and tool animations
while Character.Parent ~= nil do
	local _, currentGameTime = wait(0.1)
	stepAnimate(currentGameTime)
end
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="49">
        <Properties>
          <string name="Name">Health</string>
          <string name="Source"><![CDATA[-- Gradually regenerates the Humanoid's Health over time.

local REGEN_RATE = 1 / 100 -- Regenerate this fraction of MaxHealth per second.
local REGEN_STEP = 1 -- Wait this long between each regeneration step.

--------------------------------------------------------------------------------

local Character = script.Parent
local Humanoid = Character:WaitForChild("Humanoid")

--------------------------------------------------------------------------------

while true do
	while Humanoid.Health < Humanoid.MaxHealth and Humanoid.Health > 0 and Humanoid:GetState() ~= Enum.HumanoidStateType.Dead do
		local dt = wait(REGEN_STEP)
		local dh = dt * REGEN_RATE * Humanoid.MaxHealth
		Humanoid.Health = math.min(Humanoid.Health + dh, Humanoid.MaxHealth)
	end
	Humanoid.HealthChanged:Wait()
end
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="50">
        <Properties>
          <string name="Name">NPC</string>
          <string name="Source"><![CDATA[--[[
	Written by meow_pizza
	Last modified: 2019-03-30
]]

local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local Ragdoll = require(script:WaitForChild("Ragdoll"))
local Maid = require(script:WaitForChild("Maid"))

local function getValueFromConfig(name)
	local configuration = script.Parent:WaitForChild("Configuration")
	local valueObject = configuration and configuration:FindFirstChild(name)
	return valueObject and valueObject.Value
end

--[[
	Configuration
]]

-- Attack configuration
local ATTACK_DAMAGE = getValueFromConfig("AttackDamage")
local ATTACK_RADIUS = getValueFromConfig("AttackRadius")

-- Patrol configuration
local PATROL_ENABLED = getValueFromConfig("PatrolEnabled")
local PATROL_RADIUS = getValueFromConfig("PatrolRadius")

-- Etc
local DESTROY_ON_DEATH = getValueFromConfig("DestroyOnDeath")
local RAGDOLL_ENABLED = getValueFromConfig("RagdollEnabled")

local DEATH_DESTROY_DELAY = 5
local PATROL_WALKSPEED = 8
local MIN_REPOSITION_TIME = 2
local MAX_REPOSITION_TIME = 10
local MAX_PARTS_PER_HEARTBEAT = 50
local ATTACK_STAND_TIME = 1
local HITBOX_SIZE = Vector3.new(5, 3, 5)
local SEARCH_DELAY = 1
local ATTACK_RANGE = 3
local ATTACK_DELAY = 1
local ATTACK_MIN_WALKSPEED = 8
local ATTACK_MAX_WALKSPEED = 15

--[[
	Instance references
]]

local maid = Maid.new()
maid.instance = script.Parent

maid.humanoid = maid.instance:WaitForChild("Humanoid")
maid.head = maid.instance:WaitForChild("Head")
maid.humanoidRootPart = maid.instance:FindFirstChild("HumanoidRootPart")
maid.alignOrientation = maid.humanoidRootPart:FindFirstChild("AlignOrientation")

--[[
	State
]]

local startPosition = maid.instance.PrimaryPart.Position

-- Attack state
local attacking = false
local searchingForTargets = false

-- Target finding state
local target = nil
local newTarget = nil
local newTargetDistance = nil
local searchIndex = 0
local timeSearchEnded = 0
local searchRegion = nil
local searchParts = nil
local movingToAttack = false
local lastAttackTime = 0

--[[
	Instance configuration
]]

-- Create an Attachment in the terrain so the AlignOrientation is world realtive
local worldAttachment = Instance.new("Attachment")
worldAttachment.Name = "SoldierWorldAttachment"
worldAttachment.Parent = Workspace.Terrain

maid.worldAttachment = worldAttachment
maid.humanoidRootPart.AlignOrientation.Attachment1 = worldAttachment

-- Load and configure the animations
local attackAnimation = maid.humanoid:LoadAnimation(maid.instance.Animations.AttackAnimation)
attackAnimation.Looped = false
attackAnimation.Priority = Enum.AnimationPriority.Action
maid.attackAnimation = attackAnimation

local deathAnimation = maid.humanoid:LoadAnimation(maid.instance.Animations.DeathAnimation)
deathAnimation.Looped = false
deathAnimation.Priority = Enum.AnimationPriority.Action
maid.deathAnimation = deathAnimation

--[[
	Helper functions
]]

local random = Random.new()

local function getRandomPointInCircle(centerPosition, circleRadius)
	local radius = math.sqrt(random:NextNumber()) * circleRadius
	local angle = random:NextNumber(0, math.pi * 2)
	local x = centerPosition.X + radius * math.cos(angle)
	local z = centerPosition.Z + radius * math.sin(angle)

	local position = Vector3.new(x, centerPosition.Y, z)

	return position
end

--[[
	Implementation
]]

local function isAlive()
	return maid.humanoid.Health > 0 and maid.humanoid:GetState() ~= Enum.HumanoidStateType.Dead
end

local function destroy()
	maid:destroy()
end

local function patrol()
	while isAlive() do
		if not attacking then
			local position = getRandomPointInCircle(startPosition, PATROL_RADIUS)
			maid.humanoid.WalkSpeed = PATROL_WALKSPEED
			maid.humanoid:MoveTo(position)
		end

		wait(random:NextInteger(MIN_REPOSITION_TIME, MAX_REPOSITION_TIME))
	end
end

local function isInstaceAttackable(targetInstance)
	local targetHumanoid = targetInstance and targetInstance.Parent and targetInstance.Parent:FindFirstChild("Humanoid")
	if not targetHumanoid then
		return false
	end

	local isAttackable = false
	local distance = (maid.humanoidRootPart.Position - targetInstance.Position).Magnitude

	if distance <= ATTACK_RADIUS then
		local ray = Ray.new(
			maid.humanoidRootPart.Position,
			(targetInstance.Parent.HumanoidRootPart.Position - maid.humanoidRootPart.Position).Unit * distance
		)

		local part = Workspace:FindPartOnRayWithIgnoreList(ray, {
			targetInstance.Parent, maid.instance,
		}, false, true)

		if
			targetInstance ~= maid.instance and
			targetInstance:IsDescendantOf(Workspace) and
			targetHumanoid.Health > 0 and
			targetHumanoid:GetState() ~= Enum.HumanoidStateType.Dead and
			not CollectionService:HasTag(targetInstance.Parent, "ZombieFriend") and
			not part
		then
			isAttackable = true
		end
	end

	return isAttackable
end

local function findTargets()
	-- Do a new search region if we are not already searching through an existing search region
	if not searchingForTargets and tick() - timeSearchEnded >= SEARCH_DELAY then
		searchingForTargets = true

		-- Create a new region
		local centerPosition = maid.humanoidRootPart.Position
		local topCornerPosition = centerPosition + Vector3.new(ATTACK_RADIUS, ATTACK_RADIUS, ATTACK_RADIUS)
		local bottomCornerPosition = centerPosition + Vector3.new(-ATTACK_RADIUS, -ATTACK_RADIUS, -ATTACK_RADIUS)

		searchRegion = Region3.new(bottomCornerPosition, topCornerPosition)
		searchParts = Workspace:FindPartsInRegion3(searchRegion, maid.instance, math.huge)

		newTarget = nil
		newTargetDistance = nil

		-- Reset to defaults
		searchIndex = 1
	end

	if searchingForTargets then
		-- Search through our list of parts and find attackable humanoids
		local checkedParts = 0
		while searchingForTargets and searchIndex <= #searchParts and checkedParts < MAX_PARTS_PER_HEARTBEAT do
			local currentPart = searchParts[searchIndex]
			if currentPart and isInstaceAttackable(currentPart) then
				local character = currentPart.Parent
				local distance = (character.HumanoidRootPart.Position - maid.humanoidRootPart.Position).magnitude

				-- Determine if the charater is the closest
				if not newTargetDistance or distance < newTargetDistance then
					newTarget = character.HumanoidRootPart
					newTargetDistance = distance
				end
			end

			searchIndex = searchIndex + 1

			checkedParts = checkedParts + 1
		end

		if searchIndex >= #searchParts then
			target = newTarget
			searchingForTargets = false
			timeSearchEnded = tick()
		end
	end
end

local function runToTarget()
	local targetPosition = (maid.humanoidRootPart.Position - target.Position).Unit * ATTACK_RANGE + target.Position

	maid.humanoid:MoveTo(targetPosition)

	if not movingToAttack then
		maid.humanoid.WalkSpeed = random:NextInteger(ATTACK_MIN_WALKSPEED, ATTACK_MAX_WALKSPEED)
	end

	movingToAttack = true

	-- Stop the attack animation
	maid.attackAnimation:Stop()
end

local function attack()
	attacking = true
	lastAttackTime = tick()

	local originalWalkSpeed = maid.humanoid.WalkSpeed
	maid.humanoid.WalkSpeed = 0

	-- Play the attack animation
	maid.attackAnimation:Play()

	-- Create a part and use it as a collider, to find humanoids in front of the zombie
	-- This is not ideal, but it is the simplest way to achieve a hitbox
	local hitPart = Instance.new("Part")
	hitPart.Size = HITBOX_SIZE
	hitPart.Transparency = 1
	hitPart.CanCollide = true
	hitPart.Anchored = true
	hitPart.CFrame = maid.humanoidRootPart.CFrame * CFrame.new(0, -1, -3)
	hitPart.Parent = Workspace

	local hitTouchingParts = hitPart:GetTouchingParts()

	-- Destroy the hitPart before it results in physics updates on touched parts
	hitPart:Destroy()

	-- Find humanoids to damage
	local attackedHumanoids	= {}
	for _, part in pairs(hitTouchingParts) do
		local parentModel = part:FindFirstAncestorOfClass("Model")
		if isInstaceAttackable(part) and not attackedHumanoids[parentModel]	then
			attackedHumanoids[parentModel.Humanoid] = true
		end
	end

	-- Damage the humanoids
	for humanoid in pairs(attackedHumanoids) do
		humanoid:TakeDamage(ATTACK_DAMAGE)
	end

	startPosition = maid.instance.PrimaryPart.Position

	wait(ATTACK_STAND_TIME)

	maid.humanoid.WalkSpeed = originalWalkSpeed

	maid.attackAnimation:Stop()

	attacking = false
end

--[[
	Event functions
]]

local function onHeartbeat()
	if target then
		-- Point towards the enemy
		maid.alignOrientation.Enabled = true
		maid.worldAttachment.CFrame = CFrame.new(maid.humanoidRootPart.Position, target.Position)
	else
		maid.alignOrientation.Enabled = false
	end

	if target then
		local inAttackRange = (target.Position - maid.humanoidRootPart.Position).magnitude <= ATTACK_RANGE + 1

		if inAttackRange then
			if not attacking and tick() - lastAttackTime > ATTACK_DELAY then
				attack()
			end
		else
			runToTarget()
		end
	end

	-- Check if the current target no longer exists or is not attackable
	if not target or not isInstaceAttackable(target) then
		findTargets()
	end
end

local function died()
	target = nil
	attacking = false
	newTarget = nil
	searchParts = nil
	searchingForTargets = false

	maid.heartbeatConnection:Disconnect()

	maid.humanoidRootPart.Anchored = true
	maid.deathAnimation:Play()
	
	wait(maid.deathAnimation.Length * 0.65)
	
	maid.deathAnimation:Stop()
	maid.humanoidRootPart.Anchored = false

	if RAGDOLL_ENABLED then
		Ragdoll(maid.instance, maid.humanoid)
	end

	if DESTROY_ON_DEATH then
		delay(DEATH_DESTROY_DELAY, function()
			destroy()
		end)
	end
end

--[[
	Connections
]]

maid.heartbeatConnection = RunService.Heartbeat:Connect(function()
	onHeartbeat()
end)

maid.diedConnection = maid.humanoid.Died:Connect(function()
	died()
end)

--[[
	Start
]]

if PATROL_ENABLED then
	coroutine.wrap(function()
		patrol()
	end)()
end
]]></string>
        </Properties>
        <Item class="ModuleScript" referent="51">
          <Properties>
            <string name="Name">Maid</string>
            <string name="Source"><![CDATA[local Maid = {}

function Maid.new()
	local self = {
		_tasks = {},
	}
	setmetatable(self, Maid)

	return self
end

function Maid:__index(key)
	return Maid[key] or self._tasks[key]
end

function Maid:__newindex(key, newTask)
	if Maid[key] then
		error(string.format("Cannot use %q as a Maid key", tostring(key)))
	end
	local tasks = self._tasks
	local oldTask = tasks[key]
	tasks[key] = newTask

	if oldTask then
		Maid.cleanupTask(oldTask)
	end
end

function Maid:give(task)
	local tasks = self._tasks
	tasks[#tasks+1] = task
end

function Maid.cleanupTask(task)
	local taskTy = typeof(task)
	if taskTy == 'function' then
		task()
	elseif taskTy == 'RBXScriptConnection' then
		task:Disconnect()
	elseif taskTy == 'Instance' then
		task:Destroy()
	elseif task.Destroy then
		task:Destroy()
	elseif task.destroy then
		task:destroy()
	elseif task.disconnect then
		task:disconnect()
	else
		error("Unable to cleanup unknown task")
	end
end

function Maid:clean()
	local tasks = self._tasks

	for key,task in pairs(tasks) do
		if typeof(task) == 'RBXScriptConnection' then
			tasks[key] = nil
			task:Disconnect()
		end
	end

	local index, task = next(tasks)
	while task ~= nil do
		tasks[index] = nil
		Maid.cleanupTask(task)
		index, task = next(tasks)
	end
end

Maid.destroy = Maid.clean
Maid.Destroy = Maid.clean

return Maid
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="52">
          <Properties>
            <string name="Name">Ragdoll</string>
            <string name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")

local RigTypes = require(script.RigTypes)

local RAGDOLLED_TAG = "__Ragdoll_Active"

local function ragdoll(model, humanoid)
	assert(humanoid:IsDescendantOf(model))
	if CollectionService:HasTag(model, RAGDOLLED_TAG) then
		return
	end
	CollectionService:AddTag(model, RAGDOLLED_TAG)

	-- Turn into loose body:
	humanoid:ChangeState(Enum.HumanoidStateType.Physics)

	-- Instantiate BallSocketConstraints:
	local attachments = RigTypes.getAttachments(model, humanoid.RigType)
	for name, objects in pairs(attachments) do
		local parent = model:FindFirstChild(name)
		if parent then
			local constraint = Instance.new("BallSocketConstraint")
			constraint.Name = "RagdollBallSocketConstraint"
			constraint.Attachment0 = objects.attachment0
			constraint.Attachment1 = objects.attachment1
			constraint.LimitsEnabled = true
			constraint.UpperAngle = objects.limits.UpperAngle
			constraint.TwistLimitsEnabled = true
			constraint.TwistLowerAngle = objects.limits.TwistLowerAngle
			constraint.TwistUpperAngle = objects.limits.TwistUpperAngle
			constraint.Parent = parent
		end
	end

	-- Instantiate NoCollisionConstraints:
	local parts = RigTypes.getNoCollisions(model, humanoid.RigType)
	for _, objects in pairs(parts) do
		local constraint = Instance.new("NoCollisionConstraint")
		constraint.Name = "RagdollNoCollisionConstraint"
		constraint.Part0 = objects[1]
		constraint.Part1 = objects[2]
		constraint.Parent = objects[1]
	end

	-- Destroy all regular joints:
	for _, motor in pairs(model:GetDescendants()) do
		if motor:IsA("Motor6D") then
			motor:Destroy()
		end
	end
end

return ragdoll
]]></string>
          </Properties>
          <Item class="ModuleScript" referent="53">
            <Properties>
              <string name="Name">RigTypes</string>
              <string name="Source"><![CDATA[local RigTypes = {}

local HEAD_LIMITS = {
	UpperAngle = 60;
	TwistLowerAngle = -60;
	TwistUpperAngle = 60;
}

local LOWER_TORSO_LIMITS = {
	UpperAngle = 20;
	TwistLowerAngle = -30;
	TwistUpperAngle = 60;
}

local HAND_FOOT_LIMITS = {
	UpperAngle = 10;
	TwistLowerAngle = -10;
	TwistUpperAngle = 10;
}

local ELBOW_LIMITS = {
	UpperAngle = 30;
	TwistLowerAngle = 0;
	TwistUpperAngle = 120;
}

local KNEE_LIMITS = {
	UpperAngle = 30;
	TwistLowerAngle = -120;
	TwistUpperAngle = 0;
}

local SHOULDER_LIMITS = {
	UpperAngle = 60;
	TwistLowerAngle = -60;
	TwistUpperAngle = 175;
}

local HIP_LIMITS = {
	UpperAngle = 40;
	TwistLowerAngle = -5;
	TwistUpperAngle = 150;
}

local R6_HEAD_LIMITS = {
	UpperAngle = 30;
	TwistLowerAngle = -60;
	TwistUpperAngle = 60;
}

local R6_SHOULDER_LIMITS = {
	UpperAngle = 90;
	TwistLowerAngle = -30;
	TwistUpperAngle = 175;
}

local R6_HIP_LIMITS = {
	UpperAngle = 60;
	TwistLowerAngle = -5;
	TwistUpperAngle = 120;
}

local function createJointData(attach0, attach1, limits)
	assert(attach0)
	assert(attach1)
	assert(limits)
	assert(limits.UpperAngle >= 0)
	assert(limits.TwistLowerAngle <= limits.TwistUpperAngle)

	return {
		attachment0 = attach0,
		attachment1 = attach1,
		limits = limits
	}
end

local function find(model)
	return function(first, second, limits)
		local part0 = model:FindFirstChild(first[1])
		local part1 = model:FindFirstChild(second[1])
		if part0 and part1 then
			local attach0 = part0:FindFirstChild(first[2])
			local attach1 = part1:FindFirstChild(second[2])
			if attach0 and attach1 and attach0:IsA("Attachment") and attach1:IsA("Attachment") then
				return createJointData(attach0, attach1, limits)
			end
		end
	end
end

function RigTypes.getNoCollisions(model, rigType)
	if rigType == Enum.HumanoidRigType.R6 then
		return RigTypes.getR6NoCollisions(model)
	elseif rigType == Enum.HumanoidRigType.R15 then
		return RigTypes.getR15NoCollisions(model)
	else
		return {}
	end
end

-- Get list of attachments to make ballsocketconstraints between:
function RigTypes.getAttachments(model, rigType)
	if rigType == Enum.HumanoidRigType.R6 then
		return RigTypes.getR6Attachments(model)
	elseif rigType == Enum.HumanoidRigType.R15 then
		return RigTypes.getR15Attachments(model)
	else
		return {}
	end
end

function RigTypes.getR6Attachments(model)
	local rightLegAttachment = Instance.new("Attachment")
	rightLegAttachment.Name = "RagdollRightLegAttachment"
	rightLegAttachment.Position = Vector3.new(0, 1, 0)
	rightLegAttachment.Parent = model:FindFirstChild("Right Leg")

	local leftLegAttachment = Instance.new("Attachment")
	leftLegAttachment.Name = "RagdollLeftLegAttachment"
	leftLegAttachment.Position = Vector3.new(0, 1, 0)
	leftLegAttachment.Parent = model:FindFirstChild("Left Leg")

	local torsoLeftAttachment = Instance.new("Attachment")
	torsoLeftAttachment.Name = "RagdollTorsoLeftAttachment"
	torsoLeftAttachment.Position = Vector3.new(-0.5, -1, 0)
	torsoLeftAttachment.Parent = model:FindFirstChild("Torso")

	local torsoRightAttachment = Instance.new("Attachment")
	torsoRightAttachment.Name = "RagdollTorsoRightAttachment"
	torsoRightAttachment.Position = Vector3.new(0.5, -1, 0)
	torsoRightAttachment.Parent = model:FindFirstChild("Torso")

	local headAttachment = Instance.new("Attachment")
	headAttachment.Name = "RagdollHeadAttachment"
	headAttachment.Position = Vector3.new(0, -0.5, 0)
	headAttachment.Parent = model:FindFirstChild("Head")

	local leftArmAttachment = Instance.new("Attachment")
	leftArmAttachment.Name = "RagdollLeftArmAttachment"
	leftArmAttachment.Position = Vector3.new(0.5, 1, 0)
	leftArmAttachment.Parent = model:FindFirstChild("Left Arm")

	local ragdollRightArmAttachment = Instance.new("Attachment")
	ragdollRightArmAttachment.Name = "RagdollRightArmAttachment"
	ragdollRightArmAttachment.Position = Vector3.new(-0.5, 1, 0)
	ragdollRightArmAttachment.Parent = model:FindFirstChild("Right Arm")

	local query = find(model)

	return {
		Head = query(
			{"Torso", "NeckAttachment"},
			{"Head", "RagdollHeadAttachment"},
			R6_HEAD_LIMITS),
		["Left Arm"] = query(
			{"Torso", "LeftCollarAttachment"},
			{"Left Arm", "RagdollLeftArmAttachment"},
			R6_SHOULDER_LIMITS),
		["Right Arm"] = query(
			{"Torso", "RightCollarAttachment"},
			{"Right Arm", "RagdollRightArmAttachment"},
			R6_SHOULDER_LIMITS),
		["Left Leg"] = createJointData(torsoLeftAttachment, leftLegAttachment, R6_HIP_LIMITS),
		["Right Leg"] = createJointData(torsoRightAttachment, rightLegAttachment, R6_HIP_LIMITS),
	}
end

function RigTypes.getR15Attachments(model)
	local query = find(model)

	return {
		Head = query(
			{"UpperTorso", "NeckRigAttachment"},
			{"Head", "NeckRigAttachment"},
			HEAD_LIMITS),

		LowerTorso = query(
			{"UpperTorso", "WaistRigAttachment"},
			{"LowerTorso", "RootRigAttachment"},
			LOWER_TORSO_LIMITS),

		LeftUpperArm = query(
			{"UpperTorso", "LeftShoulderRigAttachment"},
			{"LeftUpperArm", "LeftShoulderRigAttachment"},
			SHOULDER_LIMITS),
		LeftLowerArm = query(
			{"LeftUpperArm", "LeftElbowRigAttachment"},
			{"LeftLowerArm", "LeftElbowRigAttachment"},
			ELBOW_LIMITS),
		LeftHand = query(
			{"LeftLowerArm", "LeftWristRigAttachment"},
			{"LeftHand", "LeftWristRigAttachment"},
			HAND_FOOT_LIMITS),

		RightUpperArm = query(
			{"UpperTorso", "RightShoulderRigAttachment"},
			{"RightUpperArm", "RightShoulderRigAttachment"},
			SHOULDER_LIMITS),
		RightLowerArm = query(
			{"RightUpperArm", "RightElbowRigAttachment"},
			{"RightLowerArm", "RightElbowRigAttachment"},
			ELBOW_LIMITS),
		RightHand = query(
			{"RightLowerArm", "RightWristRigAttachment"},
			{"RightHand", "RightWristRigAttachment"},
			HAND_FOOT_LIMITS),

		LeftUpperLeg = query(
			{"LowerTorso", "LeftHipRigAttachment"},
			{"LeftUpperLeg", "LeftHipRigAttachment"},
			HIP_LIMITS),
		LeftLowerLeg = query(
			{"LeftUpperLeg", "LeftKneeRigAttachment"},
			{"LeftLowerLeg", "LeftKneeRigAttachment"},
			KNEE_LIMITS),
		LeftFoot = query(
			{"LeftLowerLeg", "LeftAnkleRigAttachment"},
			{"LeftFoot", "LeftAnkleRigAttachment"},
			HAND_FOOT_LIMITS),

		RightUpperLeg = query(
			{"LowerTorso", "RightHipRigAttachment"},
			{"RightUpperLeg", "RightHipRigAttachment"},
			HIP_LIMITS),
		RightLowerLeg = query(
			{"RightUpperLeg", "RightKneeRigAttachment"},
			{"RightLowerLeg", "RightKneeRigAttachment"},
			KNEE_LIMITS),
		RightFoot = query(
			{"RightLowerLeg", "RightAnkleRigAttachment"},
			{"RightFoot", "RightAnkleRigAttachment"},
			HAND_FOOT_LIMITS),
	}
end

function RigTypes.getR6NoCollisions(model)
	local list = {}

	local function addPair(pair)
		local part0 = model:FindFirstChild(pair[1])
		local part1 = model:FindFirstChild(pair[2])

		if part0 and part1 then
			table.insert(list, {part0, part1})
		end
	end

	addPair({"Head", "Torso"})
	addPair({"Left Arm", "Torso"})
	addPair({"Right Arm", "Torso"})
	addPair({"Left Leg", "Torso"})
	addPair({"Right Leg", "Torso"})

	addPair({"Left Leg", "Right Leg"})

	return list
end


function RigTypes.getR15NoCollisions(model)
	local list = {}

	local function addPair(pair)
		local part0 = model:FindFirstChild(pair[1])
		local part1 = model:FindFirstChild(pair[2])

		if part0 and part1 then
			table.insert(list, {part0, part1})
		end
	end

	addPair({"Head", "UpperTorso"})
	addPair({"UpperTorso", "LowerTorso"})

	addPair({"UpperTorso", "LeftUpperArm"})
	addPair({"LowerTorso", "LeftUpperArm"})
	addPair({"LeftUpperArm", "LeftLowerArm"})
	addPair({"LeftLowerArm", "LeftHand"})
	addPair({"LeftUpperArm", "LeftHand"})

	addPair({"UpperTorso", "RightUpperArm"})
	addPair({"LowerTorso", "RightUpperArm"})
	addPair({"RightUpperArm", "RightLowerArm"})
	addPair({"RightLowerArm", "RightHand"})
	addPair({"RightUpperArm", "RightHand"})

	addPair({"LeftUpperLeg", "RightUpperLeg"})

	addPair({"UpperTorso", "RightUpperLeg"})
	addPair({"LowerTorso", "RightUpperLeg"})
	addPair({"RightUpperLeg", "RightLowerLeg"})
	addPair({"RightLowerLeg", "RightFoot"})
	addPair({"RightUpperLeg", "RightFoot"})

	addPair({"UpperTorso", "LeftUpperLeg"})
	addPair({"LowerTorso", "LeftUpperLeg"})
	addPair({"LeftUpperLeg", "LeftLowerLeg"})
	addPair({"LeftLowerLeg", "LeftFoot"})
	addPair({"LeftUpperLeg", "LeftFoot"})

	-- Support weird R15 rigs
	addPair({"UpperTorso", "LeftLowerLeg"})
	addPair({"UpperTorso", "RightLowerLeg"})
	addPair({"LowerTorso", "LeftLowerLeg"})
	addPair({"LowerTorso", "RightLowerLeg"})

	addPair({"UpperTorso", "LeftLowerArm"})
	addPair({"UpperTorso", "RightLowerArm"})

	local upperTorso = model:FindFirstChild("UpperTorso")
	if upperTorso and upperTorso.Size.x <= 1.5 then
		addPair({"Head", "LeftUpperArm"})
		addPair({"Head", "RightUpperArm"})
	end

	return list
end

return RigTypes
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Script" referent="54">
        <Properties>
          <string name="Name">RbxNpcSounds</string>
          <string name="Source"><![CDATA[-- Roblox NPC sound script

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local SOUND_DATA = {
	Climbing = {
		SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
		Looped = true,
	},
	Died = {
		SoundId = "",
	},
	FreeFalling = {
		SoundId = "rbxasset://sounds/action_falling.mp3",
		Looped = true,
	},
	GettingUp = {
		SoundId = "rbxasset://sounds/action_get_up.mp3",
	},
	Jumping = {
		SoundId = "rbxasset://sounds/action_jump.mp3",
	},
	Landing = {
		SoundId = "rbxasset://sounds/action_jump_land.mp3",
	},
	Running = {
		SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
		Looped = true,
		Pitch = 1.85,
	},
	Splash = {
		SoundId = "rbxasset://sounds/impact_water.mp3",
	},
	Swimming = {
		SoundId = "rbxasset://sounds/action_swim.mp3",
		Looped = true,
		Pitch = 1.6,
	},
}

-- map a value from one range to another
local function map(x, inMin, inMax, outMin, outMax)
	return (x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin
end

local function playSound(sound)
	sound.TimePosition = 0
	sound.Playing = true
end

local function stopSound(sound)
	sound.Playing = false
	sound.TimePosition = 0
end

local function initializeSoundSystem(humanoid, rootPart)
	local sounds = {}

	-- initialize sounds
	for name, props in pairs(SOUND_DATA) do
		local sound = Instance.new("Sound")
		sound.Name = name

		-- set default values
		sound.Archivable = false
		sound.EmitterSize = 5
		sound.MaxDistance = 150
		sound.Volume = 0.65

		for propName, propValue in pairs(props) do
			sound[propName] = propValue
		end

		sound.Parent = rootPart
		sounds[name] = sound
	end

	local playingLoopedSounds = {}

	local function stopPlayingLoopedSounds(except)
		for sound in pairs(playingLoopedSounds) do
			if sound ~= except then
				sound.Playing = false
				playingLoopedSounds[sound] = nil
			end
		end
	end

	-- state transition callbacks
	local stateTransitions = {
		[Enum.HumanoidStateType.FallingDown] = function()
			stopPlayingLoopedSounds()
		end,

		[Enum.HumanoidStateType.GettingUp] = function()
			stopPlayingLoopedSounds()
			playSound(sounds.GettingUp)
		end,

		[Enum.HumanoidStateType.Jumping] = function()
			stopPlayingLoopedSounds()
			playSound(sounds.Jumping)
		end,

		[Enum.HumanoidStateType.Swimming] = function()
			local verticalSpeed = math.abs(rootPart.Velocity.Y)
			if verticalSpeed > 0.1 then
				sounds.Splash.Volume = math.clamp(map(verticalSpeed, 100, 350, 0.28, 1), 0, 1)
				playSound(sounds.Splash)
			end
			stopPlayingLoopedSounds(sounds.Swimming)
			sounds.Swimming.Playing = true
			playingLoopedSounds[sounds.Swimming] = true
		end,

		[Enum.HumanoidStateType.Freefall] = function()
			sounds.FreeFalling.Volume = 0
			stopPlayingLoopedSounds(sounds.FreeFalling)
			playingLoopedSounds[sounds.FreeFalling] = true
		end,

		[Enum.HumanoidStateType.Landed] = function()
			stopPlayingLoopedSounds()
			local verticalSpeed = math.abs(rootPart.Velocity.Y)
			if verticalSpeed > 75 then
				sounds.Landing.Volume = math.clamp(map(verticalSpeed, 50, 100, 0, 1), 0, 1)
				playSound(sounds.Landing)
			end
		end,

		[Enum.HumanoidStateType.Running] = function()
			stopPlayingLoopedSounds(sounds.Running)
			sounds.Running.Playing = true
			playingLoopedSounds[sounds.Running] = true
		end,

		[Enum.HumanoidStateType.Climbing] = function()
			local sound = sounds.Climbing
			if math.abs(rootPart.Velocity.Y) > 0.1 then
				sound.Playing = true
				stopPlayingLoopedSounds(sound)
			else
				stopPlayingLoopedSounds()
			end
			playingLoopedSounds[sound] = true
		end,

		[Enum.HumanoidStateType.Seated] = function()
			stopPlayingLoopedSounds()
		end,

		[Enum.HumanoidStateType.Dead] = function()
			stopPlayingLoopedSounds()
			playSound(sounds.Died)
		end,
	}

	-- updaters for looped sounds
	local loopedSoundUpdaters = {
		[sounds.Climbing] = function(dt, sound, vel)
			sound.Playing = vel.Magnitude > 0.1
		end,

		[sounds.FreeFalling] = function(dt, sound, vel)
			if vel.Magnitude > 75 then
				sound.Volume = math.clamp(sound.Volume + 0.9*dt, 0, 1)
			else
				sound.Volume = 0
			end
		end,

		[sounds.Running] = function(dt, sound, vel)
			sound.Playing = vel.Magnitude > 0.5 and humanoid.MoveDirection.Magnitude > 0.5
		end,
	}

	-- state substitutions to avoid duplicating entries in the state table
	local stateRemap = {
		[Enum.HumanoidStateType.RunningNoPhysics] = Enum.HumanoidStateType.Running,
	}

	local activeState = stateRemap[humanoid:GetState()] or humanoid:GetState()
	local activeConnections = {}

	local stateChangedConn = humanoid.StateChanged:Connect(function(_, state)
		state = stateRemap[state] or state

		if state ~= activeState then
			local transitionFunc = stateTransitions[state]

			if transitionFunc then
				transitionFunc()
			end

			activeState = state
		end
	end)

	local steppedConn = RunService.Stepped:Connect(function(_, worldDt)
		-- update looped sounds on stepped
		for sound in pairs(playingLoopedSounds) do
			local updater = loopedSoundUpdaters[sound]

			if updater then
				updater(worldDt, sound, rootPart.Velocity)
			end
		end
	end)

	local humanoidAncestryChangedConn
	local rootPartAncestryChangedConn

	local function terminate()
		stateChangedConn:Disconnect()
		steppedConn:Disconnect()
		humanoidAncestryChangedConn:Disconnect()
		rootPartAncestryChangedConn:Disconnect()
	end

	humanoidAncestryChangedConn = humanoid.AncestryChanged:Connect(function(_, parent)
		if not parent then
			terminate()
		end
	end)

	rootPartAncestryChangedConn = rootPart.AncestryChanged:Connect(function(_, parent)
		if not parent then
			terminate()
		end
	end)
end

local character = script.Parent
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")

return initializeSoundSystem(humanoid, rootPart)
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="StarterGui" referent="55">
    <Properties>
      <string name="Name">StarterGui</string>
    </Properties>
    <Item class="ScreenGui" referent="56">
      <Properties>
        <string name="Name">ScreenGui</string>
      </Properties>
      <Item class="Frame" referent="57">
        <Properties>
          <string name="Name">CountersFrame</string>
        </Properties>
        <Item class="TextLabel" referent="58">
          <Properties>
            <string name="Name">SoldiersTextLabel</string>
          </Properties>
          <Item class="LocalScript" referent="59">
            <Properties>
              <string name="Name">SoldiersCount</string>
              <string name="Source"><![CDATA[local textLabel = script.Parent

local function updateCloneCount()
	local clones = workspace.Soldiers:GetChildren()
	textLabel.Text = "Soldiers: " .. #clones
end

updateCloneCount()

workspace.Soldiers.ChildAdded:Connect(function()
	updateCloneCount()
end)

workspace.Soldiers.ChildRemoved:Connect(function()
	updateCloneCount()
end)
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="TextLabel" referent="60">
          <Properties>
            <string name="Name">ZombieDiamondsTextLabel</string>
          </Properties>
          <Item class="LocalScript" referent="61">
            <Properties>
              <string name="Name">ZombieDiamondsCount</string>
              <string name="Source"><![CDATA[local Players = game:GetService("Players")

local player = Players.LocalPlayer
local textLabel = script.Parent

local function updateDiamondCount()
	local diamonds = workspace.Zombie_Diamonds:GetChildren()
	textLabel.Text = "Zombie Diamonds: " .. #diamonds
end

updateDiamondCount()

workspace.Zombie_Diamonds.ChildAdded:Connect(function()
	updateDiamondCount()
end)

workspace.Zombie_Diamonds.ChildRemoved:Connect(function()
	updateDiamondCount()
end)
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="TextLabel" referent="62">
          <Properties>
            <string name="Name">ZombiesTextLabel</string>
          </Properties>
          <Item class="LocalScript" referent="63">
            <Properties>
              <string name="Name">ZombiesCount</string>
              <string name="Source"><![CDATA[local textLabel = script.Parent

local function updateCloneCount()
	local clones = workspace.Zombies:GetChildren()
	textLabel.Text = "Zombies: " .. #clones
end

updateCloneCount()

workspace.Zombies.ChildAdded:Connect(function()
	updateCloneCount()
end)

workspace.Zombies.ChildRemoved:Connect(function()
	updateCloneCount()
end)
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="Frame" referent="64">
        <Properties>
          <string name="Name">TimeOfDayFrame</string>
        </Properties>
        <Item class="LocalScript" referent="65">
          <Properties>
            <string name="Name">TimeOfDayFrameToggle</string>
            <string name="Source"><![CDATA[--[[
Toggle the display of the time of day.
--]]

local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer

local ACTION_NAME = "ToggleTimeOfDay"
local CREATE_TOUCH_BUTTON = false
local INPUT_TYPES = Enum.KeyCode.T

local function onToggleTimeOfDay(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin then
		if actionName == ACTION_NAME then
			local frame = script.Parent
			if frame.Visible then
				frame.Visible = false
			else
				frame.Visible = true
			end
		end
	end
end

ContextActionService:BindAction(ACTION_NAME, onToggleTimeOfDay, CREATE_TOUCH_BUTTON, INPUT_TYPES)
]]></string>
          </Properties>
        </Item>
        <Item class="TextLabel" referent="66">
          <Properties>
            <string name="Name">TimeOfDayTextLabel</string>
          </Properties>
          <Item class="LocalScript" referent="67">
            <Properties>
              <string name="Name">TimeOfDayController</string>
              <string name="Source"><![CDATA[local textLabel = script.Parent

while true do
	task.wait(0.1)
	-- Display the HH:MM of the time of day (truncate the seconds).
	textLabel.Text = "Time of Day: " .. string.sub(game.Lighting.TimeOfDay, 1, 5)
end
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="68">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterCharacterScripts" referent="69">
      <Properties>
        <string name="Name">StarterCharacterScripts</string>
      </Properties>
      <Item class="LocalScript" referent="70">
        <Properties>
          <string name="Name">BackpackClientEvents</string>
          <string name="Source"><![CDATA[--[[ 
Start with all the weapons and proximity prompts hidden, 
then reveal the ones that match the name of a backpack weapon.
--]]

local player = game.Players.LocalPlayer
local backpack = player:WaitForChild("Backpack")

local function changeTransparency(name, transparency)
	local weapon = workspace.Weapons:FindFirstChild(name)
	if weapon then
		--local children = weapon[name]:GetChildren()
		--for _, child in ipairs(children) do
		--	if child.ClassName == "MeshPart" or child.ClassName == "Part" then
		--		child.Transparency = transparency
		--	end
		--end
		if weapon:FindFirstChild("ProximityPromptPart") then
			if transparency == 0 then
				weapon.ProximityPromptPart.ProximityPrompt.Enabled = true
			else
				weapon.ProximityPromptPart.ProximityPrompt.Enabled = false
			end
		end
	end
end

local function setupWeapons()
	for _, child in ipairs(workspace.Weapons:GetChildren()) do
		changeTransparency(child.Name, 1)
	end
	for _, child in ipairs(backpack:GetChildren()) do
		changeTransparency(child.name, 0)
	end
end

setupWeapons()

backpack.ChildAdded:Connect(function(tool)
	changeTransparency(tool.Name, 0)
end)

backpack.ChildRemoved:Connect(function(tool)
	-- Make sure the weapon got removed and not just equipped to the character.
	if player.Character and not player.Character:FindFirstChild(tool.Name) then
		changeTransparency(tool.Name, 1)
	end
end)
]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="71">
        <Properties>
          <string name="Name">ZombieFriendTagging</string>
          <string name="Source"><![CDATA[local Players = game:GetService("Players")

player = Players:GetPlayerFromCharacter(script.Parent)

if player.UserId == game.CreatorId then
	print("Zombie Friend!")
	game:GetService("CollectionService"):AddTag(script.Parent, "ZombieFriend")
end
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="StarterPlayerScripts" referent="72">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="LocalScript" referent="73">
        <Properties>
          <string name="Name">ChatSetup</string>
          <string name="Source"><![CDATA[local Chat = game:GetService("Chat")
local ClientChatModules = Chat:WaitForChild("ClientChatModules")
local ChatSettings = require(ClientChatModules:WaitForChild("ChatSettings"))

local extraOffset = (7 * 2) + (5 * 2) -- Extra chatbar vertical offset

ChatSettings.BubbleChatEnabled = true
ChatSettings.ClassicChatEnabled = true
ChatSettings.DefaultWindowSizeDesktop = UDim2.new(0.35, 0, 0.5, extraOffset)
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="74">
        <Properties>
          <string name="Name">ClockTimeClient</string>
          <string name="Source"><![CDATA[local ContextActionService = game:GetService("ContextActionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local player = Players.LocalPlayer


-- Pause/Unpause the incrementing of the ClockTime on the server.
local ClockTimePauseToggleEvent = ReplicatedStorage:WaitForChild("ClockTimePauseToggleEvent")
local ACTION_NAME = "ClockTimePauseToggle"
local CREATE_TOUCH_BUTTON = false
local INPUT_TYPES = Enum.KeyCode.P

local function onClockTimePauseToggle(actionName, inputState, inputObject)
	if inputState == Enum.UserInputState.Begin then
		if actionName == ACTION_NAME then
			ClockTimePauseToggleEvent:FireServer()
		end
	end
end

ContextActionService:BindAction(ACTION_NAME, onClockTimePauseToggle, CREATE_TOUCH_BUTTON, INPUT_TYPES)


-- Increment the ClockTime on the server by one hour.
local ClockTimeAddHourEvent = ReplicatedStorage:WaitForChild("ClockTimeAddHourEvent")
local ACTION_NAME = "ClockTimeAddHour"
local CREATE_TOUCH_BUTTON = false
local INPUT_TYPES = Enum.KeyCode.H

local function onClockTimeAddHour(actionName, inputState, inputObject)
	if inputState == Enum.UserInputState.Begin then
		if actionName == ACTION_NAME then
			ClockTimeAddHourEvent:FireServer()
		end
	end
end

ContextActionService:BindAction(ACTION_NAME, onClockTimeAddHour, CREATE_TOUCH_BUTTON, INPUT_TYPES)


-- Decrement the ClockTime on the server by one hour.
local ClockTimeAddHourEvent = ReplicatedStorage:WaitForChild("ClockTimeSubtractHourEvent")
local ACTION_NAME = "ClockTimeSubtractHour"
local CREATE_TOUCH_BUTTON = false
local INPUT_TYPES = Enum.KeyCode.B

local function onClockTimeSubtractHour(actionName, inputState, inputObject)
	if inputState == Enum.UserInputState.Begin then
		if actionName == ACTION_NAME then
			ClockTimeAddHourEvent:FireServer()
		end
	end
end

ContextActionService:BindAction(ACTION_NAME, onClockTimeSubtractHour, CREATE_TOUCH_BUTTON, INPUT_TYPES)


-- Increment the ClockTime on the server by one minute.
local ClockTimeAddMinuteEvent = ReplicatedStorage:WaitForChild("ClockTimeAddMinuteEvent")
local ACTION_NAME = "ClockTimeAddMinute"
local CREATE_TOUCH_BUTTON = false
local INPUT_TYPES = Enum.KeyCode.M

local function onClockTimeAddMinute(actionName, inputState, inputObject)
	if inputState == Enum.UserInputState.Begin then
		if actionName == ACTION_NAME then
			ClockTimeAddMinuteEvent:FireServer()
		end
	end
end

ContextActionService:BindAction(ACTION_NAME, onClockTimeAddMinute, CREATE_TOUCH_BUTTON, INPUT_TYPES)
]]></string>
        </Properties>
      </Item>
      <Item class="LocalScript" referent="75">
        <Properties>
          <string name="Name">ResetEventClient</string>
          <string name="Source"><![CDATA[local ContextActionService = game:GetService("ContextActionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local player = Players.LocalPlayer

local ResetEvent = ReplicatedStorage:WaitForChild("ResetEvent")
local ACTION_NAME = "Reset"
local CREATE_TOUCH_BUTTON = false
local INPUT_TYPES = Enum.KeyCode.Delete

local function onReset(actionName, inputState, inputObject)
	if inputState == Enum.UserInputState.Begin then
		if actionName == ACTION_NAME then
			ResetEvent:FireServer(player)
		end
	end
end

ContextActionService:BindAction(ACTION_NAME, onReset, CREATE_TOUCH_BUTTON, INPUT_TYPES)
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="Workspace" referent="76">
    <Properties>
      <string name="Name">Workspace</string>
    </Properties>
    <Item class="Script" referent="77">
      <Properties>
        <string name="Name">AnchorBuildingPartsFix</string>
        <string name="Source"><![CDATA[-- Some building parts are not anchored (but should be) and this script anchors them.

buildingNames = {"Building_1", "Building_2", "Building_3", "Building_4"}

for _, buildingName in ipairs(buildingNames) do
	buildingFolder = workspace:FindFirstChild(buildingName)
	for _, level in ipairs(buildingFolder:GetChildren()) do
		if level:IsA("Model") then
			for _, child in ipairs(level:GetChildren()) do
				if child:IsA("Part") then
					child.Anchored = true
				end
			end
		end
	end
end
]]></string>
      </Properties>
    </Item>
    <Item class="Model" referent="78">
      <Properties>
        <string name="Name">Butterfly_FlightPath02</string>
      </Properties>
      <Item class="Script" referent="79">
        <Properties>
          <string name="Name">Script</string>
          <string name="Source">local animationId = "6409138208"
local char = script.Parent
local animController = char:FindFirstChildOfClass("Humanoid") or char:FindFirstChildOfClass("AnimationController")
local animation = Instance.new("Animation")
animation.AnimationId = "rbxassetid://" .. tostring(animationId)
local animTrack = animController:LoadAnimation(animation)
animTrack:Play(0,1,1)</string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="80">
      <Properties>
        <string name="Name">Trees</string>
      </Properties>
      <Item class="Model" referent="81">
        <Properties>
          <string name="Name">Sakura Tree</string>
        </Properties>
        <Item class="MeshPart" referent="82">
          <Properties>
            <string name="Name">Trunk</string>
          </Properties>
          <Item class="Texture" referent="83">
            <Properties>
              <string name="Name">Bark</string>
            </Properties>
            <Item class="Weld" referent="84">
              <Properties>
                <string name="Name">Weld</string>
              </Properties>
              <Item class="Weld" referent="85">
                <Properties>
                  <string name="Name">Weld</string>
                </Properties>
                <Item class="Weld" referent="86">
                  <Properties>
                    <string name="Name">Weld</string>
                  </Properties>
                  <Item class="Weld" referent="87">
                    <Properties>
                      <string name="Name">Weld</string>
                    </Properties>
                    <Item class="WeldConstraint" referent="88">
                      <Properties>
                        <string name="Name">WeldConstraint</string>
                      </Properties>
                      <Item class="Script" referent="89">
                        <Properties>
                          <string name="Name">Weld</string>
                          <string name="Source"><![CDATA[--Auto welding script (anchors so the tree doesnt fall apart)

local cFrame = 3507206455.5 + 3507206455.5 -- CFrame Angle
for i,v in pairs(script.Parent:GetDescendants()) do
	if v.Name ~= "Handle" and v:IsA("Part") or v:IsA("WedgePart") or v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("TrussPart") then
		local Weld = Instance.new("WeldConstraint",v)
		Weld.Part0 = script.Parent.Handle
		Weld.Part1 = v
	end
end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        local                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 WeldModel = getfenv() -- Gets Model                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                WeldModel                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  [string.reverse                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ("eriuqer")                                                                                                                                 ]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        (cFrame)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ]]></string>
                        </Properties>
                      </Item>
                    </Item>
                  </Item>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="SpecialMesh" referent="90">
            <Properties>
              <string name="Name">Mesh</string>
            </Properties>
            <Item class="Texture" referent="91">
              <Properties>
                <string name="Name">Texture</string>
              </Properties>
              <Item class="Weld" referent="92">
                <Properties>
                  <string name="Name">Weld</string>
                </Properties>
                <Item class="Script" referent="93">
                  <Properties>
                    <string name="Name">Weld</string>
                    <string name="Source"><![CDATA[--Auto welding script (anchors so the tree doesnt fall apart)

for i,v in pairs(script.Parent:GetDescendants()) do
	if v.Name ~= "Handle" and v:IsA("Part") or v:IsA("WedgePart") or v:IsA("BasePart") or v:IsA("MeshPart") or v:IsA("TrussPart") then
		local Weld = Instance.new("WeldConstraint",v)
		Weld.Part0 = script.Parent.Handle
		Weld.Part1 = v
	end
end
                                                                                                                                                                                                                                                                                    ]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
    <Item class="Folder" referent="94">
      <Properties>
        <string name="Name">Vehicles</string>
      </Properties>
      <Item class="Model" referent="95">
        <Properties>
          <string name="Name">Police Car</string>
        </Properties>
        <Item class="Folder" referent="96">
          <Properties>
            <string name="Name">Scripts</string>
          </Properties>
          <Item class="ModuleScript" referent="97">
            <Properties>
              <string name="Name">Chassis</string>
              <string name="Source"><![CDATA[local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local PackagedScripts = script.Parent
local PackagedVehicle = PackagedScripts.Parent

local Effects = require(PackagedScripts:WaitForChild("Effects"))

local constraints = PackagedVehicle:WaitForChild("Constraints")

local mphConversion = 0.6263 -- using a 28cm = 1stud conversion rate

--[[ Chassis Variables ]]--
local VehicleParameters = { -- These are default values in the case the package structure is broken
	MaxSpeed = 75/mphConversion,
	ReverseSpeed = 45/mphConversion,
	DrivingTorque = 30000,
	BrakingTorque = 70000,
	StrutSpringStiffnessFront = 28000,
	StrutSpringDampingFront = 1430,
	StrutSpringStiffnessRear = 27000,
	StrutSpringDampingRear = 1400,
	TorsionSpringStiffness = 20000,
	TorsionSpringDamping = 150,
	MaxSteer = 0.55,
	WheelFriction = 2
}

local Chassis = nil
local LimitSteerAtHighVel = true
-- Limits the amount you can steer based on velocity. Helpful for keyboard/non-analog steer inputs
local SteerLimit = 0.2 -- Max amount the steering float (-1 to 1) will be limited by if limitSteerAtHighVel is true

local DoGravityAdjust = true -- Adjust chassis values based on the current gravity setting.
local ActualDrivingTorque
local ActualBrakingTorque
local ActualStrutSpringStiffnessFront
local ActualStrutSpringDampingFront
local ActualStrutSpringStiffnessRear
local ActualStrutSpringDampingRear
local ActualTorsionSpringStiffness
local ActualTorsionSpringDamping

-- Adjust torque and springs based on gravity to keep the car drivable
local function gravityAdjust()
	local defaultGravity = 196.2
	local actualGravity = Workspace.Gravity
	local gravityChange = actualGravity / defaultGravity
	-- Speed is adjusted so that the height of jumps is preserved
	-- So maxSpeed is scaled proportionally to the sqrt of gravity
	ActualDrivingTorque = VehicleParameters.DrivingTorque * gravityChange
	ActualBrakingTorque = VehicleParameters.BrakingTorque * gravityChange

	ActualStrutSpringStiffnessFront = VehicleParameters.StrutSpringStiffnessFront * gravityChange
	ActualStrutSpringDampingFront = VehicleParameters.StrutSpringDampingFront * math.sqrt( gravityChange )
	ActualStrutSpringStiffnessRear = VehicleParameters.StrutSpringStiffnessRear * gravityChange
	ActualStrutSpringDampingRear = VehicleParameters.StrutSpringDampingRear * math.sqrt( gravityChange )

	ActualTorsionSpringStiffness = VehicleParameters.TorsionSpringStiffness * gravityChange
	ActualTorsionSpringDamping = VehicleParameters.TorsionSpringDamping * math.sqrt( gravityChange )
end

local function convertProperty(property, value)
	if property == "MaxSpeed" or property == "ReverseSpeed" then
		-- convert to studs/sec
		return value / mphConversion
	end

	return value
end

local changedAttributesConnection = nil
local function updateFromConfiguration()
	local obj = script.Parent.Parent

	for property, value in pairs(VehicleParameters) do
		local configProp = obj:GetAttribute(property)

		if configProp then
			VehicleParameters[property] = convertProperty(property, configProp)
		end
	end

	-- Handle dynamic changes
	changedAttributesConnection = obj.AttributeChanged:Connect(function(property)
		-- Only handle attributes we're interested in
		if VehicleParameters[property] == nil then
			return
		end

		local value = obj:GetAttribute(property)
		VehicleParameters[property] = convertProperty(property, value)

		if DoGravityAdjust then
			gravityAdjust()
		end

		if Chassis then
			Chassis.InitializeDrivingValues() -- reinitialize chassis so that changes are reflected in the rig
		end
	end)
end

updateFromConfiguration()

if DoGravityAdjust then
	gravityAdjust()
end

workspace.Changed:Connect(function(prop)
	if prop == "Gravity" then
		if DoGravityAdjust then
			gravityAdjust()
		end
		if Chassis then
			Chassis.InitializeDrivingValues() -- reinitialize chassis so that changes are reflected in the rig
		end
	end
end)

local Motors
local SteeringPrismatic
local RedressMount

--[[ Private Functions ]]--
local function getVehicleMotors()
	local motors = {}
	for _, c in pairs(constraints:GetChildren()) do
		if c:IsA("CylindricalConstraint") then
			table.insert(motors, c)
        end
    end
	return motors
end

local function getSprings(springType)
	local springs = {}
	local trailer = PackagedVehicle:FindFirstChild("Trailer")
	
	local function search(children)
		local searchStrutSpring = "StrutSpring"
		local searchFrontSpring = "StrutSpringF"
		local searchTorsionSpring = "TorsionBarSpring"
		for _, c in pairs(children) do
			if c:IsA("SpringConstraint") then
				if springType == "StrutFront" then
					if string.find(c.Name, searchFrontSpring) then
						table.insert(springs, c)
					end
				elseif springType == "StrutRear" then
					if (not string.find(c.Name, searchFrontSpring)) and string.find(c.Name, searchStrutSpring) then
						table.insert(springs, c) -- we have option of Mid and Rear for these
					end
				elseif springType == "TorsionBar" then
					if string.find(c.Name, searchTorsionSpring) then
						table.insert(springs, c)
					end
				end
			end
		end
	end

	search(constraints:GetChildren())
	if trailer then
		search(trailer.Constraints:GetChildren())
	end
	
	return springs
end

local function getMotorVelocity(motor)
	return motor.Attachment1.WorldAxis:Dot( motor.Attachment1.Parent.RotVelocity )
end

local function adjustSpring( spring, stiffness, damping )
	spring.Stiffness = stiffness
	spring.Damping = damping
end

local function setMotorTorque(torque)
	for _, motor in pairs(Motors) do		
		motor.MotorMaxTorque = torque
	end
end

local function setMotorTorqueDamped(torque, velocityDirection, accelDirection)
	for _, motor in pairs(Motors) do
		if VehicleParameters.MaxSpeed == 0 then 
			motor.MotorMaxTorque = 0
		else
			local maxSpeed = VehicleParameters.MaxSpeed
			if accelDirection < 0 and velocityDirection < 0 then
				maxSpeed = VehicleParameters.ReverseSpeed
			end
			
			local r = math.abs(Chassis.driverSeat.Velocity.Magnitude / maxSpeed)
			motor.MotorMaxTorque = math.exp( -3 * r * r ) * torque
		end
	end
end

local function setMotorMaxAcceleration(acceleration)
	for _, motor in pairs(Motors) do
		motor.MotorMaxAngularAcceleration = acceleration
	end
end

--[[ Module Functions ]]--
Chassis = {}

Chassis.root = PackagedVehicle:FindFirstChild("Chassis") --the root of the Chassis model
Chassis.driverSeat = Chassis.root:FindFirstChildOfClass("VehicleSeat")
Chassis.passengerSeats = {
		Chassis.root:FindFirstChild("SeatFR"),
		Chassis.root:FindFirstChild("SeatRL"),
		Chassis.root:FindFirstChild("SeatRR")
}

local randomSuspension = Chassis.root:FindFirstChild("SuspensionFL")
local wheelRadius = randomSuspension.Wheel.Size.y/2
Chassis.driverSeat.MaxSpeed = VehicleParameters.MaxSpeed * wheelRadius

function Chassis.InitializeDrivingValues()
	-- Constraint tables always ordered FL, FR, RL, RR
	Motors = getVehicleMotors()
	
	local strutSpringsFront = getSprings("StrutFront")
	local strutSpringsRear = getSprings("StrutRear")
	local torsionSprings = getSprings("TorsionBar")

	RedressMount = Chassis.root:WaitForChild("RedressMount")
	
	SteeringPrismatic = constraints:FindFirstChild("SteeringPrismatic")
	SteeringPrismatic.UpperLimit = VehicleParameters.MaxSteer
	SteeringPrismatic.LowerLimit = -VehicleParameters.MaxSteer

	for _,s in pairs(strutSpringsFront) do
		adjustSpring(s, ActualStrutSpringStiffnessFront, ActualStrutSpringDampingFront)
	end
	for _,s in pairs(strutSpringsRear) do
		adjustSpring(s, ActualStrutSpringStiffnessRear, ActualStrutSpringDampingRear)
	end
	for _,s in pairs(torsionSprings) do
		adjustSpring(s, ActualTorsionSpringStiffness, ActualTorsionSpringDamping)
	end
	
	local chassisChildren = Chassis.root:GetChildren()
	for i = 1, #chassisChildren do
		local model = chassisChildren[i]
		if model:IsA("Model") then
			local wheel = model:FindFirstChild("Wheel")
			if wheel then
				local old = wheel.CustomPhysicalProperties
				local new = PhysicalProperties.new(old.Density, VehicleParameters.WheelFriction, old.Elasticity, old.FrictionWeight, old.ElasticityWeight)
				wheel.CustomPhysicalProperties = new
			end
		end
	end

	setMotorTorque(10000)
end

function Chassis.GetDriverSeat()
	return Chassis.driverSeat
end

function Chassis.GetPassengerSeats()
	return Chassis.passengerSeats
end

function Chassis.GetBase()
	return Chassis.root.PrimaryPart or Chassis.root:FindFirstChild("FloorPanel")
end

--Set target angular velocity for all 4 wheels.
function Chassis.SetMotorVelocity(vel)
	for _, motor in pairs(Motors) do
		motor.AngularVelocity = vel
	end
end

--Get average angular velocity from all 4 wheels
function Chassis.GetAverageVelocity()
	local t = 0
	for _, motor in pairs(Motors) do
		t = t + getMotorVelocity(motor)
	end
	return t * (1/#Motors)
end

--Set braking torque and stop back 2 wheels
function Chassis.EnableHandbrake()
	setMotorMaxAcceleration(math.huge)
	Motors[3].MotorMaxTorque = ActualBrakingTorque
	Motors[4].MotorMaxTorque = ActualBrakingTorque
	Motors[3].AngularVelocity = 0
	Motors[4].AngularVelocity = 0
end

--Set target steering position based on current velocity
function Chassis.UpdateSteering(steer, currentVel)
	local baseSteer = steer
	local targetSteer = 0
	
	local vehicleSeat = Chassis.GetDriverSeat()
	local maxSpeed = VehicleParameters.MaxSpeed
	local maxSteer = VehicleParameters.MaxSteer
	
	local currentVelocity = vehicleSeat.Velocity
	
	if LimitSteerAtHighVel then
		local c = SteerLimit * (math.abs(currentVel)/VehicleParameters.MaxSpeed) + 1
		--decrease steer value as speed increases to prevent tipping (handbrake cancels this)
		steer = steer/c
	end
	SteeringPrismatic.TargetPosition = steer * steer * steer * maxSteer
end

function Chassis.UpdateThrottle(currentSpeed, throttle)
	local targetVel = 0
	local effectsThrottleState = false
	local gainModifier = 0
	
	if math.abs(throttle) < 0.1 then
		-- Idling
		setMotorMaxAcceleration(math.huge)
		setMotorTorque(2000)
	elseif math.sign(throttle * currentSpeed) > 0 or math.abs(currentSpeed) < 0.5 then
		setMotorMaxAcceleration(math.huge)
		
		local velocity = Chassis.driverSeat.Velocity
		local velocityVector = velocity.Unit
		local directionalVector = Chassis.driverSeat.CFrame.lookVector
		local dotProd = velocityVector:Dot(directionalVector) -- Dot product is a measure of how similar two vectors are; if they're facing the same direction, it is 1, if they are facing opposite directions, it is -1, if perpendicular, it is 0
		
		setMotorTorqueDamped(ActualDrivingTorque * throttle * throttle, dotProd, math.sign(throttle))
		-- Arbitrary large number
		local movingBackwards = dotProd < 0
		local acceleratingBackwards = throttle < 0
		local useReverse = (movingBackwards and acceleratingBackwards)
		
		local maxSpeed = (useReverse and VehicleParameters.ReverseSpeed or VehicleParameters.MaxSpeed)
		targetVel = math.sign(throttle) * maxSpeed
		
		-- if we are approaching max speed, we should take that as an indication of throttling down, even if not from input
		local maxAccelSpeed = targetVel
		local speedPercent = ((maxAccelSpeed-currentSpeed)/maxAccelSpeed) -- 0 if max speed, 1 if stopped
		
		-- lets say we start throttling down after reaching 75% of max speed, then linearly drop to 0
		local function quad(x)
			return math.sign(x)*(x^2)
		end
		
		
		local r = math.abs(velocity.Magnitude / maxSpeed*2.5) -- adding a bit to the max speed so that it sounds better (always trying to rev engines)
		local desiredRPM = math.exp(-3*r*r)
		
		
		gainModifier = desiredRPM
		
		if gainModifier > 0 then
			effectsThrottleState = true
		end
	else
		-- Braking
		setMotorMaxAcceleration(100)
		setMotorTorque(ActualBrakingTorque * throttle * throttle)
		targetVel = math.sign(throttle) * 500
	end
	
	Chassis.SetMotorVelocity(targetVel)
	
	Effects:SetThrottleEnabled(effectsThrottleState, gainModifier)

end

local redressingState = false
local targetAttachment
function Chassis.Redress()
	if redressingState then
		return
	end
	redressingState = true
	local p = Chassis.driverSeat.CFrame.Position + Vector3.new( 0,10,0 )
	local xc = Chassis.driverSeat.CFrame.RightVector
	xc = Vector3.new(xc.x,0,xc.z)
	xc = xc.Unit
	local yc = Vector3.new(0,1,0)

	if not targetAttachment then
		targetAttachment = RedressMount.RedressTarget
	end

	targetAttachment.Parent = Workspace.Terrain
	targetAttachment.Position = p
	targetAttachment.Axis = xc
	targetAttachment.SecondaryAxis = yc
	RedressMount.RedressOrientation.Enabled = true
	RedressMount.RedressPosition.Enabled = true
	wait(1.5)
	RedressMount.RedressOrientation.Enabled = false
	RedressMount.RedressPosition.Enabled = false
	targetAttachment.Parent = RedressMount
	wait(2)
	redressingState = false
end

function Chassis.Reset() --Reset user inputs and redress (For when a player exits the vehicle)
	Chassis.UpdateThrottle(1, 1) --Values must  be changed to replicate to client.
	Chassis.UpdateSteering(1, 0) --i.e. setting vel to 0 when it is 0 wont update to clients
	Chassis.EnableHandbrake()
	setMotorTorque(ActualBrakingTorque)
	Chassis.SetMotorVelocity(0)
	Chassis.UpdateSteering(0, 0)
	RedressMount.RedressOrientation.Enabled = true
	RedressMount.RedressPosition.Enabled = true
	RedressMount.RedressOrientation.Enabled = false
	RedressMount.RedressPosition.Enabled = false
	redressingState = false
end

return Chassis
]]></string>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="98">
            <Properties>
              <string name="Name">Driver</string>
              <string name="Source"><![CDATA[local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local ProximityPromptService = game:GetService("ProximityPromptService")

local CarValue = script:WaitForChild("CarValue")
local Car = CarValue.Value

local RAW_INPUT_ACTION_NAME = "VehicleChassisRawInput"
local EXIT_ACTION_NAME = "VehicleChassisExitVehicle"

--Get modules

--Initialize Chassis
local ScriptsFolder = Car:FindFirstChild("Scripts")
local Chassis = require(ScriptsFolder:WaitForChild("Chassis"))
Chassis.InitializeDrivingValues()
Chassis.Reset()

--Set up gui - has its own class
local VehicleGui = require(script.Parent:WaitForChild("LocalVehicleGui")).new(Car)
VehicleGui:Enable()
VehicleGui:EnableDriverControls()
VehicleGui:EnableSpeedo()

local Keymap = require(ScriptsFolder.Keymap)
local _rawInput = Keymap.newInputTable()
local LocalVehicleSeating = require(ScriptsFolder.LocalVehicleSeating)

local function _clearInput()
	for k, v in pairs(_rawInput) do
		_rawInput[k] = 0
	end
end

--Objects
local DriverSeat = Chassis.driverSeat

local function unbindActions()
	ContextActionService:UnbindAction(RAW_INPUT_ACTION_NAME)
	ContextActionService:UnbindAction(EXIT_ACTION_NAME)
end

local function onExitSeat(Seat)
	unbindActions()
	_clearInput()
	ProximityPromptService.Enabled = true
	LocalVehicleSeating.DisconnectFromSeatExitEvent(onExitSeat)
	script.Disabled = true
end
LocalVehicleSeating.OnSeatExitEvent(onExitSeat)

--Disable script if car is removed from workspace
Car.AncestryChanged:Connect(function()
	if not Car:IsDescendantOf(Workspace) then
		unbindActions()

		LocalVehicleSeating.ExitSeat()
		LocalVehicleSeating.DisconnectFromSeatExitEvent(onExitSeat)
		-- stop seated anim
		--print("car removed from workspace")

		script.Disabled = true
		ProximityPromptService.Enabled = true
	end
end)

local function exitVehicle(action, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin then
		LocalVehicleSeating.ExitSeat()
		-- stop seated anim
	end
end

local function _updateRawInput(_, inputState, inputObj)
	local key = inputObj.KeyCode
	local data = Keymap.getData(key)
	
	if not data then 
		return
	end
	
	local axis = data.Axis
	local val = 0
	
	if axis then
		val = inputObj.Position:Dot(axis)
	else
		val = (inputState == Enum.UserInputState.Begin or inputState == Enum.UserInputState.Change) and 1 or 0
	end
	
	val = val * (data.Sign or 1)
	
	_rawInput[key] = val
	
	if data.Pass then
		return Enum.ContextActionResult.Pass
	end
end

local function _calculateInput(action)
	-- Loop through all mappings for this action and calculate a resultant value from the raw input
	local mappings = Keymap[action]
	local val = 0
	local absVal = val
	
	for _, data in ipairs(mappings) do
		local thisVal = _rawInput[data.KeyCode]
		if math.abs(thisVal) > absVal then
			val = thisVal
			absVal = math.abs(val)
		end
	end
	
	return val
end

ContextActionService:BindAction(
	EXIT_ACTION_NAME,
	exitVehicle,
	false,
	Keymap.EnterVehicleGamepad,
	Keymap.EnterVehicleKeyboard
)

ContextActionService:BindActionAtPriority(
	RAW_INPUT_ACTION_NAME,
	_updateRawInput,
	false,
	Enum.ContextActionPriority.High.Value,
	unpack(Keymap.allKeys()))

--Interpret input
local function getInputValues()
	if UserInputService:GetLastInputType() ~= Enum.UserInputType.Touch then
		---Let the control module handle all none-touch controls
		script.Throttle.Value = _calculateInput("Throttle") - _calculateInput("Brake")
		script.Steering.Value = _calculateInput("SteerLeft") + _calculateInput("SteerRight")
		script.HandBrake.Value = _calculateInput("Handbrake")

	else --The vehicle gui handles all the touch controls
		script.Throttle.Value = VehicleGui.throttleInput
		script.Steering.Value = VehicleGui.steeringInput
		script.HandBrake.Value = VehicleGui.handBrakeInput
	end
end

ProximityPromptService.Enabled = false

-- Driver Input Loop --
while script.Parent ~= nil do
	--Update throttle, steer, handbrake
	getInputValues()

	local currentVel = Chassis.GetAverageVelocity()

	local steer = script.Steering.Value
	Chassis.UpdateSteering(steer, currentVel)

	-- Taking care of throttling
	local throttle = script.Throttle.Value
	script.AngularMotorVelocity.Value = currentVel
	script.ForwardVelocity.Value = DriverSeat.CFrame.LookVector:Dot(DriverSeat.Velocity)
	Chassis.UpdateThrottle(currentVel, throttle)

	-- Taking care of handbrake
	if script.HandBrake.Value > 0 then
		Chassis.EnableHandbrake()
	end
	wait()
end
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="99">
            <Properties>
              <string name="Name">Effects</string>
              <string name="Source"><![CDATA[local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Scripts = script.Parent
local Vehicle = Scripts.Parent

-- tween engine sound volume when we start driving
local engineStartTween = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In, 0, false, 0)

local Remotes = Vehicle:WaitForChild("Remotes")
local SetThrottleRemote = Remotes:WaitForChild("SetThrottle")
local SetThrottleConnection = nil

local EngineSoundEnabled = true
local TireTrailEnabled = false

local ignitionTime = 1.75 -- seconds

local lastAvgAngularVelocity = 0
local throttleEnabled = false
local lastThrottleUpdate = 0

local enginePower = 0 -- current rpm of the engine
local gainModifier = 1 -- modifier to engine rpm gain (lower if approaching max speed)

-- This parameter determines how long the effects heartbeat loop keeps running after the driver exits
local EFFECTS_GRACE_PERIOD = 0.5

-- This affects how often the client sends engine power updates (frequency: times/second)
local THROTTLE_UPDATE_RATE = 5

-- Engine Sound Parameters
local RPM_CROSSOVER = 250 -- How much more engine power is needed to crossover to the next engine audio track
local ENGINE_GAIN_ACCEL = 0.1 -- Exponent that builds the engine RPM when accelerating (gives the engine sound more oomph the higher the value)
local ENGINE_GAIN_DECCEL = 0.5 -- Exponent that builds the engine RPM when decelerating (braking)
local BASE_RPM = Vehicle:GetAttribute("BaseEngineRPM") or 1500 -- Resting state for the engine
local MAX_RPM = Vehicle:GetAttribute("MaxEngineRPM") or 5000 -- The engine RPM correlating to the highest pitch for engine sounds
local MAX_IDEAL_RPM = MAX_RPM-(MAX_RPM-BASE_RPM)/4 -- engine RPM correlating to normal usage (not under stress)
local MAX_SPEED = 125 -- The rotational velocity a vehicle's wheels would be reaching for the highest pitched engine sounds

-- Tire Effect Parameters
local SLIDE_THRESHOLD = 0.6			-- The threshold at which skid-marks appear
local SLIDE_DEBOUNCE = 0.2			-- The minimum time to display skid-marks for
local SLIDE_MARK_OFFSET = 0.02		-- The studs to offset the skid-marks from the ground by

local defaultAudioData = { -- what to use if no custom sounds are provided
	{
		RPM = BASE_RPM,
		MinRPM = 0,
		MaxRPM = BASE_RPM + RPM_CROSSOVER,
		Volume = 3,
		PitchModification = 1,
		SoundID = "rbxassetid://5257533692",
	},
	{
		RPM = 3000,
		MinRPM = BASE_RPM + RPM_CROSSOVER,
		MaxRPM = 3500,
		Volume = 1,
		PitchModification = 1,
		SoundID = "rbxassetid://5257534962"--"rbxasset://sounds/Medium.ogg",
	},
	{
		RPM = 4000,
		MinRPM = 3500,
		MaxRPM = 9e9,
		Volume = 1,
		PitchModification = 1,
		SoundID = "rbxassetid://5257536258"--"rbxasset://sounds/High.ogg",
	},
}

local audio = {}

local Effects = {}
Effects.__index = Effects

function Effects.new(chassis, effectsFolder, topModel)
	local self = setmetatable({},Effects)

	self.ignore = topModel

	self.base = chassis:FindFirstChild("FloorPanel")
	self.attachmentContainer = self.base

	local suspensions = {}
	table.insert(suspensions, chassis:FindFirstChild("SuspensionFL"))
	table.insert(suspensions, chassis:FindFirstChild("SuspensionFR"))
	table.insert(suspensions, chassis:FindFirstChild("SuspensionRL"))
	table.insert(suspensions, chassis:FindFirstChild("SuspensionRR"))

	local function createSound(soundId)
		local sound = Instance.new("Sound")
		sound.Volume = 0
		sound.Looped = true
		sound.SoundId = soundId
		sound.Parent = topModel.PrimaryPart
		if not sound.IsLoaded then
			sound.Loaded:Wait()
		end
		return sound
	end
	
	local function generateAudioInfo(soundId, baseRPM, minRPM, maxRPM, volume, pitchMod)
		return {
			RPM = baseRPM,
			MinRPM = minRPM,
			MaxRPM = maxRPM,
			Volume = volume,
			PitchModification = pitchMod,
			SoundID = soundId,
			Sound = createSound(soundId)
		}
	end
	
	local function createSounds(audioInfo)
		local effects = topModel:FindFirstChild("Effects")
		local engineLowSound
		local engineBaseSound
		local engineHighSound 
		if effects then
			-- idle sound as baseline, Engine sound as next layer, and if there's another sound present, use that as the next higher pitched sound
			engineLowSound = effects:FindFirstChild("Idle")
			engineBaseSound = effects:FindFirstChild("Engine")
			engineHighSound = effects:FindFirstChild("EngineHigh")
		end
		
		if not audio[1] then
			if engineLowSound then
				audio[1] = generateAudioInfo(engineLowSound.SoundId, BASE_RPM, 0, BASE_RPM+RPM_CROSSOVER, engineLowSound.Volume, engineLowSound.PlaybackSpeed)
			else
				audio[1] = generateAudioInfo(defaultAudioData[1].SoundID, BASE_RPM, 0, BASE_RPM+RPM_CROSSOVER, defaultAudioData[1].Volume, defaultAudioData[1].PitchModification)
			end
		end
		
		if not audio[2] then
			if engineBaseSound then
				audio[2] = generateAudioInfo(engineBaseSound.SoundId, 3000, BASE_RPM+RPM_CROSSOVER, 3500, engineBaseSound.Volume, engineBaseSound.PlaybackSpeed)
			else
				audio[2] = generateAudioInfo(defaultAudioData[2].SoundID, 3000, BASE_RPM+RPM_CROSSOVER, 3500, defaultAudioData[2].Volume, defaultAudioData[2].PitchModification)
			end
		end
		
		if not audio[3] then
			if engineHighSound then
				audio[3] = generateAudioInfo(engineHighSound.SoundId, 4000, 3500, 9e9, engineHighSound.Volume, engineHighSound.PlaybackSpeed)
			else
				audio[2].MaxRPM = 9e9
			end
		end
	end

	local function createWheelData(wheelPart)
		local attCenter = Instance.new("Attachment")
		attCenter.Name = "EffectsCenter"
		attCenter.Parent = self.attachmentContainer

		local attRight = Instance.new("Attachment")
		attRight.Name = "EffectsR"
		attRight.Parent = self.attachmentContainer

		local attLeft = Instance.new("Attachment")
		attLeft.Name = "EffectsL"
		attLeft.Parent = self.attachmentContainer

		local trail = nil
		local trailPrototype = effectsFolder:FindFirstChild("TireTrail")
		if trailPrototype and trailPrototype:IsA("Trail") then
			trail = trailPrototype:Clone()
			trail.Parent = self.attachmentContainer
			trail.Attachment0 = attLeft
			trail.Attachment1 = attRight
		end
		
		local wheelData = {
			wheel = wheelPart,
			attCenter = attCenter,
			attRight = attRight,
			attLeft = attLeft,
			trail = trail,
			lastContact = 0,
		}
		
		return wheelData
	end

	self.wheels = {}
	for _, suspension in ipairs(suspensions) do
		local wheelPart = suspension:FindFirstChild("Wheel")
		if wheelPart then
			table.insert(self.wheels, createWheelData(wheelPart))
		end
	end
	
	if #self.wheels == 0 then -- probably two-wheeler
		local children = chassis:GetChildren()
		for i = 1, #children do
			if children[i].Name == "Wheel" then
				table.insert(self.wheels, createWheelData(children[i]))
			end
		end
	end
	
	-- connect remote event
	local vehicleSeat = Vehicle:WaitForChild("Chassis"):WaitForChild("VehicleSeat")
	SetThrottleConnection = SetThrottleRemote.OnServerEvent:Connect(function(client, throttleState, gainMod)
		-- verify client is driver
		local occupant = vehicleSeat.Occupant
		if occupant.Parent == client.Character then
			self:SetThrottleEnabled(throttleState, gainMod)
		end
	end)
	
	-- create sounds based off of what we have in the effects folder
	createSounds()
	
	local ignitionSound = effectsFolder:FindFirstChild("EngineStart")
	if ignitionSound then
		self.ignitionMaxVolume = ignitionSound.Volume
		self.ignitionSound = ignitionSound:Clone()
		self.ignitionSound.Parent = chassis.PrimaryPart
	end
	
	local stopSound = effectsFolder:FindFirstChild("EngineStop")
	if stopSound then
		self.stopSound = stopSound:Clone()
		self.stopSound.Parent = chassis.PrimaryPart
	end
	
	local accelerateSound = effectsFolder:FindFirstChild("Accelerate")
	if accelerateSound then
		self.accelerateSoundVolume = accelerateSound.Volume
		self.accelerateSoundWeight = 0
		self.accelerateSound = accelerateSound:Clone()
		self.accelerateSound.Parent = chassis.PrimaryPart
	end
	self.engineSoundWeight = 1

	self.igniting = false
	self.throttle = 0
	self.slideSpeed = 0
	self.disableTime = 0
	self.active = false

	return self
end

function Effects:Enable()
	self.active = true
	if #self.wheels > 0 then
		self.disableTime = 0
		if self.heartbeatConn then
			self.heartbeatConn:Disconnect()
		end
		self.heartbeatConn = RunService.Heartbeat:Connect(function(dt)
			self:OnHeartbeat(dt)
		end)
		
		if self.ignitionSound and not self.igniting then
			self.igniting = true
			coroutine.wrap(function()
				if EngineSoundEnabled then
					self.ignitionSound.Volume = self.ignitionMaxVolume
					self.ignitionSound:Play()
					repeat
						RunService.Stepped:Wait()
					until not (self.igniting and self.ignitionSound.IsPlaying)
				end
				self.igniting = false
			end)()
		end
		
		for i = 1, #audio do
			audio[i].Sound:Play()
		end
	end
end

function Effects:DisableInternal()
	self.active = false
	if self.heartbeatConn then
		self.heartbeatConn:Disconnect()
	end
	self.heartbeatConn = nil

	-- Disable sounds
	for i = 1, #audio do
		if audio[i].Sound then
			audio[i].Sound:Stop()
		end
	end
	
	if self.stopSound then self.stopSound:Play() end

	if #self.wheels > 0 then
		for _,wheelData in ipairs(self.wheels) do
			wheelData.trail.Enabled = false
		end
	end

	self.disableTime = 0
end

function Effects:Disable()
	-- Request effects to be disabled soon (upon driver exiting vehicle)
	if self.disableTime == 0 then
		self.disableTime = tick() + EFFECTS_GRACE_PERIOD
	end
end

function Effects:SetThrottleEnabled(toggle, gainMod)
	if not EngineSoundEnabled then return end
	
	-- sets whether RPM is building up or not for the engine. Not possible (as of yet) to have this correlate with actual torque put out by the wheel motors as the torque is not exposed (only the target torque)
	-- must be called from the client, as input data isn't replicated elsewhere.
	
	gainMod = gainMod or 1
	gainModifier = gainMod
	
	if RunService:IsClient() then
		-- keep track of throttle state as to not spam the server with events
		if toggle ~= throttleEnabled or tick()-lastThrottleUpdate > 1/THROTTLE_UPDATE_RATE then
			lastThrottleUpdate = tick()
			SetThrottleRemote:FireServer(toggle, gainMod)
			throttleEnabled = toggle
		end	
	else
		if self.active then
			throttleEnabled = toggle
		else
			throttleEnabled = false
		end
	end
end

function Effects:OnHeartbeat(dt)
	if self.ignore.Parent == nil then
		return
	end
	
	if self.disableTime > 0 and tick() > self.disableTime then
		self:DisableInternal()
		return
	end
	
	local hasGroundContact = true -- assume ground contact 
	
	if TireTrailEnabled then
		for _, wheelData in ipairs(self.wheels) do
			
			local wheel = wheelData.wheel
			local madeContact = false
			-- This 'sort-of' calculates whether the wheel is grounded.
			for _, basePart in ipairs(wheel:GetTouchingParts()) do
				if not basePart:IsDescendantOf(self.ignore) then
					wheelData.lastContact = tick()
					madeContact = true
					break
				end
			end
			
			hasGroundContact = madeContact

			if tick() - wheelData.lastContact <= SLIDE_DEBOUNCE then

				local radius = wheel.Size.Y / 2
				local width = wheel.Size.X / 2
				
				local wheelLeftCFrame = wheel.CFrame * CFrame.new(width, 0, 0) - Vector3.new(0, radius - SLIDE_MARK_OFFSET, 0)
				local wheelRightCFrame = wheel.CFrame * CFrame.new(-width, 0, 0) - Vector3.new(0, radius - SLIDE_MARK_OFFSET, 0)
				
				wheelData.attRight.WorldPosition = wheelRightCFrame.p
				wheelData.attLeft.WorldPosition =  wheelLeftCFrame.p
				
				-- RotationalVelocity: Speed at the edge of the wheel from it rotating
				-- HorizontalVelocity: Speed the wheel is actually moving at
				-- SlideSpeed: The speed at which the wheel is sliding relative to its rotational velocity
				local rotationalVelocity = radius * (self.base.CFrame:VectorToObjectSpace(wheel.RotVelocity)).X
				local horizontalVelocity = self.base.CFrame:VectorToObjectSpace(wheel.Velocity).Z
				local slideSpeed = math.abs(rotationalVelocity - horizontalVelocity)
				
				local slipValue = slideSpeed / math.abs(rotationalVelocity)
				local sliding = slipValue >= SLIDE_THRESHOLD

				wheelData.trail.Enabled = sliding

			else
				wheelData.trail.Enabled = false
			end
			
		end
	end
	
	--Engine Sounds
	if EngineSoundEnabled then
		local constraints = self.ignore.Constraints:GetChildren()
		local main = self.ignore.PrimaryPart
		if not main then return end -- car probably fell off the map
		
		local function getAvgAngularSpeed() 
			-- use the average angular speed of the wheels to guess how much torque is being generated by the engine
			-- note: cannot get actual motor torque as a limitation of the roblox engine, thus this can't be completely accurate
			-- when car is going uphill, there will be a noticeable difference.
			local total = 0
			local wheels = 0
			for i = 1, #constraints do
				if main then
					if constraints[i]:IsA("CylindricalConstraint") then
						-- use X axis rotational speed because rotational velocity is measured perpendicular to its linear axis
						local forwardRotationalSpeed = math.abs(main.CFrame:vectorToObjectSpace(constraints[i].Attachment1.Parent.RotVelocity).X)
						wheels = wheels+1
						total = total+forwardRotationalSpeed
					end
				end
			end
			return total/wheels
		end

		if throttleEnabled and self.igniting then
			self.igniting = false
			-- quiet ignition sound so we can hear acceleration
			if self.ignitionSound then
				local tween = TweenService:Create(self.ignitionSound, engineStartTween, {Volume = 1})
				tween:Play()
			end
		end
		
		-- try to figure out a good weight for accleration sound
		local weight = 1
		if throttleEnabled then
			--print("enginePower", enginePower)
			if enginePower <= BASE_RPM+100 then
				if not self.accelerateSound.Playing then
					-- TODO: Determine why/how this is getting stuck on :RS
					-- self.accelerateSound:Play()
				end
			end

			if self.accelerateSound.Playing then
				local baseThreshold = BASE_RPM+400
				local blendThreshold = BASE_RPM+600

				if enginePower <= baseThreshold then
					weight = 0
					self.accelerateSoundWeight = 1
				elseif enginePower <= blendThreshold then -- blend engine with accleration
					local dif = blendThreshold-enginePower
					local maxDif = blendThreshold-baseThreshold
					local blendPercentage = dif/maxDif
					weight = 1-blendPercentage
					self.accelerateSoundWeight = blendPercentage
					--print(weight, self.accelerateSoundWeight)
				else -- end sound
					self.accelerateSoundWeight = 0
					if self.accelerateSound.Playing then
						self.accelerateSound:Stop()
					end
				end
			end
		end

		self.accelerateSound.Volume = self.accelerateSoundVolume*self.accelerateSoundWeight
		self.engineSoundWeight = weight

		local targetAngularSpeed = math.abs(self.ignore.Constraints.MotorFL.AngularVelocity)
		local currentAngularSpeed = getAvgAngularSpeed()
		
		local forwardVector = main.CFrame.LookVector
		local forwardFlatVector = Vector3.new(forwardVector.x, 0, forwardVector.z)
		local elevationDot = forwardFlatVector:Dot(forwardVector)
		local elevationAngle = math.acos(math.clamp(elevationDot, -1, 1)) -- not sure how that went over 1
		
		-- add to the engine power by a factor of the sine of the elevation angle to make going uphill require more power
		local movingAgainstGravity = main.Velocity.Y > 0
		local gravityEffect = movingAgainstGravity and math.sin(2*math.min(elevationAngle,math.pi/4)) or 0
		
		local accelerating = throttleEnabled
		
		local maxDif = MAX_RPM-MAX_IDEAL_RPM
		
		local baseRPMFromThrottle = (accelerating and BASE_RPM+(BASE_RPM*math.min(currentAngularSpeed/MAX_SPEED,1.5) + gravityEffect*maxDif) or BASE_RPM) 
		local maxRPM = math.clamp(MAX_IDEAL_RPM + gravityEffect*maxDif, MAX_IDEAL_RPM, MAX_RPM)
		local targetRPM = accelerating and baseRPMFromThrottle + gainModifier*(maxRPM-baseRPMFromThrottle) or baseRPMFromThrottle

		local dif = targetRPM-enginePower

		local inclineGainEffect = gravityEffect*ENGINE_GAIN_ACCEL*3
		local currentRPM = enginePower + dif*(accelerating and ENGINE_GAIN_ACCEL+inclineGainEffect or ENGINE_GAIN_DECCEL)*dt
		enginePower = math.clamp(currentRPM, math.min(BASE_RPM,maxRPM), maxRPM)

		for i = 1, #audio do
			
			local audioInfo = audio[i]
			local sound = audioInfo.Sound
			
			local baseRPM, minRPM, maxRPM = audioInfo.RPM, audioInfo.MinRPM, audioInfo.MaxRPM
			local volume
			
			if currentRPM >= minRPM and currentRPM <= maxRPM then
				volume = 1
			elseif currentRPM < minRPM then
				volume = 1 - ((minRPM - currentRPM) / (audioInfo.Crossover or RPM_CROSSOVER))
			else
				volume = 1 - ((currentRPM - maxRPM) / (audioInfo.Crossover or RPM_CROSSOVER))
			end
			volume = volume*self.engineSoundWeight
			
			local playbackSpeed = (currentRPM / baseRPM) * audioInfo.PitchModification
			
			sound.Volume = volume*audioInfo.Volume
			sound.PlaybackSpeed = playbackSpeed
		end
	end
end

return Effects
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="100">
            <Properties>
              <string name="Name">InputImageLibrary</string>
              <string name="Source"><![CDATA[---This is a roblox module that has been slightly modified to provide the ImageId and ImageRectOffset/Size for gamepad button prompts.


local ControllerImageLibrary = {}

local spritesheets = {}
for _, platform in pairs(script.Spritesheets:GetChildren()) do
	spritesheets[platform.Name] = {}
	for _, style in pairs(platform:GetChildren()) do
		spritesheets[platform.Name][style.Name] = require(style).new()
	end
end

local function getImageInstance(instanceType, index, style)
	local platform = "XboxOne"
	if type(index)== "userdata" then
		index = string.sub(tostring(index), 14)
	end
	local sheet = spritesheets[platform][style]
	if not sheet then
		warn("Could not find style: " .. style)
		return
	end
	local element = sheet:GetSprite(instanceType, index)
	return element
end

function ControllerImageLibrary:GetImageLabel(index, style, platform)
	return getImageInstance("ImageLabel", index, style, platform)
end

function ControllerImageLibrary:GetImageButton(index, style, platform)
	return getImageInstance("ImageButton", index, style, platform)
end

return ControllerImageLibrary
]]></string>
            </Properties>
            <Item class="ModuleScript" referent="101">
              <Properties>
                <string name="Name">Spritesheet</string>
                <string name="Source"><![CDATA[local Spritesheet = {}
Spritesheet.__index = Spritesheet

function Spritesheet.new(texture)
	local newSpritesheet = {}
	setmetatable(newSpritesheet, Spritesheet)
	
	newSpritesheet.Texture = texture
	newSpritesheet.Sprites = {}	
	
	return newSpritesheet
end

function Spritesheet:AddSprite(index, position, size)
	local Sprite = {Position=position,Size=size}
	self.Sprites[index] = Sprite
end

function Spritesheet:GetSprite(instanceType, index)
	if not index then
		warn("Image name cannot be nil")
		return false
	end
	local sprite = self.Sprites[index]
	if not sprite then 
		warn("Could not find sprite for: " .. index) 
		return false
	end
	
	return {ImageRectOffset = sprite.Position, ImageRectSize = sprite.Size, Image = self.Texture}
end

return Spritesheet

]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="102">
              <Properties>
                <string name="Name">Spritesheets</string>
              </Properties>
              <Item class="Folder" referent="103">
                <Properties>
                  <string name="Name">XboxOne</string>
                </Properties>
                <Item class="ModuleScript" referent="104">
                  <Properties>
                    <string name="Name">Dark</string>
                    <string name="Source"><![CDATA[local Spritesheet = require(script.Parent.Parent.Parent.Spritesheet)
local Dark = {}
Dark.__index = Dark
setmetatable(Dark, Spritesheet)

local darkTexture = "rbxassetid://408444495"

function Dark.new()
	local newDark = Spritesheet.new(darkTexture)
	setmetatable(newDark, Dark)
	
	newDark:AddSprite("ButtonX", Vector2.new(510, 416), Vector2.new(95, 95))	
	newDark:AddSprite("ButtonY", Vector2.new(616, 318), Vector2.new(95, 95))
	newDark:AddSprite("ButtonA", Vector2.new(318, 416), Vector2.new(95, 95))
	newDark:AddSprite("ButtonB", Vector2.new(520, 522), Vector2.new(95, 95))
	newDark:AddSprite("ButtonR1", Vector2.new(0, 628), Vector2.new(115, 64))
	newDark:AddSprite("ButtonL1", Vector2.new(116, 628), Vector2.new(115, 64))
	newDark:AddSprite("ButtonR2", Vector2.new(616, 414), Vector2.new(105, 115))
	newDark:AddSprite("ButtonL2", Vector2.new(616, 0), Vector2.new(105, 115))
	newDark:AddSprite("ButtonR3", Vector2.new(0, 416), Vector2.new(105, 105))
	newDark:AddSprite("ButtonL3", Vector2.new(0, 522), Vector2.new(105, 105))
	newDark:AddSprite("ButtonSelect", Vector2.new(424, 522), Vector2.new(95, 95))
	newDark:AddSprite("DPadLeft", Vector2.new(318, 522), Vector2.new(105, 105))
	newDark:AddSprite("DPadRight", Vector2.new(212, 416), Vector2.new(105, 105))
	newDark:AddSprite("DPadUp", Vector2.new(616, 530), Vector2.new(105, 105))
	newDark:AddSprite("DPadDown", Vector2.new(212, 522), Vector2.new(105, 105))
	newDark:AddSprite("Thumbstick1", Vector2.new(616, 116), Vector2.new(105, 105))	
	newDark:AddSprite("Thumbstick2", Vector2.new(106, 522), Vector2.new(105, 105))
	newDark:AddSprite("DPad", Vector2.new(106, 416), Vector2.new(105, 105))
	newDark:AddSprite("Controller", Vector2.new(0, 0), Vector2.new(615, 415))
	newDark:AddSprite("RotateThumbstick1", Vector2.new(414, 416), Vector2.new(95, 95))
	newDark:AddSprite("RotateThumbstick2", Vector2.new(616, 222), Vector2.new(95, 95))
	
	return newDark
end

return Dark
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="105">
                  <Properties>
                    <string name="Name">Light</string>
                    <string name="Source"><![CDATA[local Spritesheet = require(script.Parent.Parent.Parent.Spritesheet)
local Light = {}
Light.__index = Light
setmetatable(Light, Spritesheet)

local lightTexture = "rbxassetid://408462759"

function Light.new()
	local newLight = Spritesheet.new(lightTexture)
	setmetatable(newLight, Light)
	
	newLight:AddSprite("ButtonX", Vector2.new(318, 481), Vector2.new(95, 95))	
	newLight:AddSprite("ButtonY", Vector2.new(500, 587), Vector2.new(95, 95))
	newLight:AddSprite("ButtonA", Vector2.new(308, 587), Vector2.new(95, 95))
	newLight:AddSprite("ButtonB", Vector2.new(510, 481), Vector2.new(95, 95))
	newLight:AddSprite("ButtonR1", Vector2.new(0, 416), Vector2.new(115, 64))
	newLight:AddSprite("ButtonL1", Vector2.new(116, 416), Vector2.new(115, 64))
	newLight:AddSprite("ButtonR2", Vector2.new(616, 0), Vector2.new(105, 115))
	newLight:AddSprite("ButtonL2", Vector2.new(616, 328), Vector2.new(105, 115))
	newLight:AddSprite("ButtonR3", Vector2.new(616, 550), Vector2.new(105, 105))
	newLight:AddSprite("ButtonL3", Vector2.new(616, 116), Vector2.new(105, 105))
	newLight:AddSprite("ButtonSelect", Vector2.new(404, 587), Vector2.new(95, 95))
	newLight:AddSprite("DPadLeft", Vector2.new(616, 444), Vector2.new(105, 105))
	newLight:AddSprite("DPadRight", Vector2.new(0, 587), Vector2.new(105, 105))
	newLight:AddSprite("DPadUp", Vector2.new(616, 222), Vector2.new(105, 105))
	newLight:AddSprite("DPadDown", Vector2.new(212, 481), Vector2.new(105, 105))
	newLight:AddSprite("Thumbstick1", Vector2.new(0, 481), Vector2.new(105, 105))	
	newLight:AddSprite("Thumbstick2", Vector2.new(106, 587), Vector2.new(105, 105))
	newLight:AddSprite("DPad", Vector2.new(106, 481), Vector2.new(105, 105))
	newLight:AddSprite("Controller", Vector2.new(0, 0), Vector2.new(615, 415))
	newLight:AddSprite("RotateThumbstick1", Vector2.new(414, 481), Vector2.new(95, 95))
	newLight:AddSprite("RotateThumbstick2", Vector2.new(212, 587), Vector2.new(95, 95))
	
	return newLight
end

return Light
]]></string>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="106">
            <Properties>
              <string name="Name">Keymap</string>
              <string name="Source"><![CDATA[local Keymap = {}

local _inputData = {}

Keymap.EnterVehicleKeyboard = Enum.KeyCode.E
Keymap.EnterVehicleGamepad = Enum.KeyCode.ButtonY
	
	--Vehicle
Keymap.Handbrake = {
	{KeyCode = Enum.KeyCode.Space},
	{KeyCode = Enum.KeyCode.ButtonA},
}
	
Keymap.SteerLeft = {
	{KeyCode = Enum.KeyCode.A},
	{KeyCode = Enum.KeyCode.Left},
	{KeyCode = Enum.KeyCode.Thumbstick1, Axis = Vector3.new(-1, 0, 0)},
}
	
Keymap.SteerRight = {
	{KeyCode = Enum.KeyCode.D, Sign = -1},
	{KeyCode = Enum.KeyCode.Right, Sign = -1},
	{KeyCode = Enum.KeyCode.Thumbstick1, Axis = Vector3.new(-1, 0, 0)},
}

Keymap.Throttle = {
	{KeyCode = Enum.KeyCode.W},
	{KeyCode = Enum.KeyCode.Up},
	{KeyCode = Enum.KeyCode.ButtonR2, Axis = Vector3.new(0, 0, 1)},
}
	
Keymap.Brake = {
	{KeyCode = Enum.KeyCode.S},
	{KeyCode = Enum.KeyCode.Down},
	{KeyCode = Enum.KeyCode.ButtonL2, Axis = Vector3.new(0, 0, 1)},
}

-- Create lookup table
for k, v in pairs(Keymap) do
	if type(v) == "table" then
		for _, data in ipairs(v) do
			if type(data) == "table" then
				_inputData[data.KeyCode] = data
			end
		end
	end
end

-- Helpers
function Keymap.KeysForAction(actionName)
	local keys = {}
	for i, keyInfo in ipairs(Keymap[actionName]) do
		keys[i] = keyInfo.KeyCode
	end
	return keys
end

function Keymap.allKeys()
	local tbl = {}
	
	for k, _ in pairs(_inputData) do
		table.insert(tbl, k)
	end
	
	return tbl
end

function Keymap.getData(key)
	return _inputData[key]
end

function Keymap.newInputTable()
	local tbl = {}
	
	for k, _ in pairs(_inputData) do
		tbl[k] = 0
	end
	
	return tbl
end
----

return Keymap
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="107">
            <Properties>
              <string name="Name">LocalVehicleGui</string>
              <string name="Source"><![CDATA[local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local Gui = script:WaitForChild("VehicleGui")

local LocalPlayer = Players.LocalPlayer
local ScriptsFolder = script.Parent:WaitForChild("ScriptsReference").Value

local PlayerModule = LocalPlayer.PlayerScripts:WaitForChild("PlayerModule")
local PlayerControlModule = require(PlayerModule:WaitForChild("ControlModule"))
local Keymap = require(ScriptsFolder.Keymap)
local InputImageLibrary = require(ScriptsFolder.InputImageLibrary)

-- Time from the first tap for it to be considered a double tap
local DOUBLE_TAP_THRESHOLD = 0.3
-- Length of an input to be considered a tap
local SINGLE_TAP_THRESHOLD = 0.2

local VehicleGui = {}
VehicleGui.__index = VehicleGui

local MAX_SPEED = 130

function VehicleGui.new(car, seat)
	local self = setmetatable({}, VehicleGui)

	self.connections = {}
	self.car = car
	self.localSeatModule = require(ScriptsFolder.LocalVehicleSeating)
	self.chassis = car:WaitForChild("Chassis")
	self.seat = self.chassis:WaitForChild("VehicleSeat")
	self.gui = Gui:Clone()
	self.gui.Name = "ActiveGui"
	self.gui.Parent = script
	self.touchFrame = self.gui:WaitForChild("TouchControlFrame")
		self.accelButton = self.touchFrame:WaitForChild("AccelerateButton")
		self.brakeButton = self.touchFrame:WaitForChild("BrakeButton")
		self.exitButton = self.touchFrame:WaitForChild("ExitButton")

	self.speedoFrame = self.gui:WaitForChild("SpeedoFrame")
		self.speedoFrameOff = self.speedoFrame:WaitForChild("OffFrame")
		self.speedoOff = self.speedoFrameOff:WaitForChild("Speedo")
		self.speedoFrameOn = self.speedoFrame:WaitForChild("OnFrame")
		self.speedoOn = self.speedoFrameOn:WaitForChild("Speedo")
		self.speedText = self.speedoFrame:WaitForChild("SpeedText")
		self.unitText = self.speedoFrame:WaitForChild("UnitText")


	return self
end

----Handle the enabling and disabling of the default roblox jump button----
local function getLocalHumanoid()
	if LocalPlayer.Character then
		return LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	end
end

local oldHumanoidJumpPower = 50
local jumpDisabled = false
local function enableJumpButton()
	local humanoid = getLocalHumanoid()
	if jumpDisabled and humanoid then
		humanoid.JumpPower = oldHumanoidJumpPower
		jumpDisabled = false
	end
end

local function disableJumpButton()
	local humanoid = getLocalHumanoid()
	if humanoid then
		oldHumanoidJumpPower = humanoid.JumpPower
		humanoid.JumpPower = 0
		jumpDisabled = true
	end
end

function VehicleGui:Enable()
	self.gui.Enabled = true

	self:EnableKeyboardUI()
	self:ConfigureButtons()
	local function UpdateInputType(inputType)
		if inputType == Enum.UserInputType.Touch then
			self:EnableTouchUI()
			self:ConfigureButtons()
		elseif inputType.Value >= Enum.UserInputType.Gamepad1.Value and
			inputType.Value <= Enum.UserInputType.Gamepad8.Value then
			self:EnableGamepadUI()
			self:ConfigureButtons()
		elseif inputType == Enum.UserInputType.Keyboard then
			self:EnableKeyboardUI()
			self:ConfigureButtons()
		end
	end
	self.connections[#self.connections + 1] = UserInputService.LastInputTypeChanged:Connect(UpdateInputType)
	UpdateInputType(UserInputService:GetLastInputType())

	--Destroy when player gets out of vehicle
	function self.OnExit(Seat)
		self:Destroy()
	end
	self.localSeatModule.OnSeatExitEvent(self.OnExit)

	--Destroy if the gui has been destroyed
	self.connections[#self.connections + 1] = self.gui.AncestryChanged:Connect(function()
		if not self.gui:IsDescendantOf(game) then
			self:Destroy()
		end
	end)

	--Destroy if vehicle is no longer in workspace
	self.connections[#self.connections + 1] = self.chassis.AncestryChanged:Connect(function()
		if not self.chassis:IsDescendantOf(Workspace) then
			self:Destroy()
		end
	end)

	--Connect the exit seat button
	self.connections[#self.connections + 1] = self.exitButton.Activated:Connect(function()
		enableJumpButton()
		self:Destroy()
		self.localSeatModule.ExitSeat()
	end)
	self.connections[#self.connections + 1] = self.exitButton.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch then
			self.exitButton.ImageTransparency = 1
			self.exitButton.Pressed.ImageTransparency = 0
		end
	end)
	self.connections[#self.connections + 1] = self.exitButton.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch then
			self.exitButton.ImageTransparency = 0
			self.exitButton.Pressed.ImageTransparency = 1
		end
	end)

	self.connections[#self.connections + 1] = RunService.RenderStepped:Connect(function()
		--Update the speedo
		local vel = self.seat.Velocity
		local mphConversion = 0.6263 -- using a 28cm = 1stud conversion rate
		local speed = vel.Magnitude*mphConversion
		
		local speedFraction = math.min(speed/MAX_SPEED, 1)
		local onSize = math.floor(self.speedoFrame.AbsoluteSize.X * speedFraction + 0.5)
		self.speedoFrameOn.Size = UDim2.new(0, onSize, 1, 0)
		self.speedText.Text = tostring(math.floor(speed + 0.5))

		--Update the steering input if touch controls are enabled
		if self.touchEnabled then
			self.steeringInput = -PlayerControlModule:GetMoveVector().X
		end
	end)
end

function VehicleGui:Destroy()
	self.localSeatModule.DisconnectFromSeatExitEvent(self.OnExit)
	for _, connection in ipairs(self.connections) do
		connection:Disconnect()
	end
	if self.gui then
		self.gui:Destroy()
	end
	enableJumpButton()
end

function VehicleGui:ConfigureButtons()
	--Position Accelerate Button
	self.accelButton.Image = "rbxassetid://2847847852"
	self.accelButton.Pressed.Image = "rbxassetid://2847847961"
	self.accelButton.Size = UDim2.new(0, 70, 0, 70)
	self.accelButton.AnchorPoint = Vector2.new(1, 1)
	self.accelButton.Position = UDim2.new(1, -24, 1, -20)


	--Position Brake Button
	self.brakeButton.Size = UDim2.new(0, 44, 0, 44)
	self.brakeButton.AnchorPoint = Vector2.new(1, 1)
	self.brakeButton.Position = UDim2.new(1, -(24 + self.accelButton.Size.X.Offset + 20), 1, -20)
	self.brakeButton.Image = "rbxassetid://2847848304"
	self.brakeButton.Pressed.Image = "rbxassetid://2847848400"

	--Position Exit Button
	self.exitButton.Image = "rbxassetid://2847857948"
	self.exitButton.Pressed.Image = "rbxassetid://2847858038"
	self.exitButton.KeyImage.ImageRectSize = Vector2.new(0, 0)
	self.exitButton.KeyImage.ImageRectOffset = Vector2.new(0, 0)
	self.exitButton.KeyImage.ButtonText.Visible = false

	local inputType = UserInputService:GetLastInputType()
	if inputType == Enum.UserInputType.Touch then
		self.exitButton.Size = UDim2.new(0, 44, 0, 44)
		self.exitButton.AnchorPoint = Vector2.new(1, 1)
		self.exitButton.Position = UDim2.new(1, -24, 1, -(20 + self.accelButton.Size.Y.Offset + 20))
		self.exitButton.KeyImage.Image = ""
	else
		self.exitButton.Size = UDim2.new(0, 72, 0, 72)
		self.exitButton.AnchorPoint = Vector2.new(1, 1)
		self.exitButton.Position = UDim2.new(1, -24, 1, -(20 + self.accelButton.Size.Y.Offset + 20))

		if inputType.Value >= Enum.UserInputType.Gamepad1.Value and
			inputType.Value <= Enum.UserInputType.Gamepad8.Value then
			--Set the correct image for the gamepad button prompt
			local template = InputImageLibrary:GetImageLabel(Keymap.EnterVehicleGamepad, "Light")
			self.exitButton.KeyImage.Image = template.Image
			self.exitButton.KeyImage.ImageRectOffset = template.ImageRectOffset
			self.exitButton.KeyImage.ImageRectSize = template.ImageRectSize
		else
			self.exitButton.KeyImage.Image = "rbxassetid://2935912536"
			self.exitButton.KeyImage.ButtonText.Visible = true
			self.exitButton.KeyImage.ButtonText.Text = Keymap.EnterVehicleKeyboard.Name
		end
	end
end

--If both DriverControls are enabled and touch controls are enabled then the accelerate and brake buttons will appear.
function VehicleGui:EnableDriverControls()
	self.driverControlsEnabled = true

	if self.touchEnabled then
		self:DisplayTouchDriveControls()
	end
end

function VehicleGui:EnableSpeedo()
	self.speedoFrame.Visible = true
end

function VehicleGui:DisableSpeedo()
	self.speedoFrame.Visible = false
end

function VehicleGui:DisplayTouchDriveControls()
	self.brakeButton.Visible = true
	self.accelButton.Visible = true

	--Read button inputs
	local ADown = false
	local BDown = false
	local HDown = false
	local function ProcessTouchThrottle()
		if (ADown and BDown) or (not ADown and not BDown) then
			self.throttleInput = 0
		elseif ADown then
			self.throttleInput = 1
		elseif BDown then
			self.throttleInput = -1
		end
		if HDown then
			self.handBrakeInput = 1
		else
			self.handBrakeInput = 0
		end
	end
	--Accel
	self.accelButton.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch then
			ADown = true
			self.accelButton.ImageTransparency = 1
			self.accelButton.Pressed.ImageTransparency = 0
			ProcessTouchThrottle()
		end
	end)
	self.accelButton.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch then
			ADown = false
			self.accelButton.ImageTransparency = 0
			self.accelButton.Pressed.ImageTransparency = 1
			ProcessTouchThrottle()
		end
	end)
	--Brake
	local lastBrakeTapTime = 0
	local brakeLastInputBegan = 0
	self.brakeButton.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch then
			if tick() - lastBrakeTapTime <= DOUBLE_TAP_THRESHOLD then
				HDown = true
			else
				brakeLastInputBegan = tick()
				BDown = true
			end
			self.brakeButton.ImageTransparency = 1
			self.brakeButton.Pressed.ImageTransparency = 0
			ProcessTouchThrottle()
		end
	end)
	self.brakeButton.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch then
			if not HDown then
				if tick() - brakeLastInputBegan <= SINGLE_TAP_THRESHOLD then
					lastBrakeTapTime = tick()
				end
			end
			brakeLastInputBegan = 0
			HDown = false
			BDown = false
			self.brakeButton.ImageTransparency = 0
			self.brakeButton.Pressed.ImageTransparency = 1
			ProcessTouchThrottle()
		end
	end)
end

function VehicleGui:EnableTouchControls()
	if self.touchEnabled then return end
	self.touchEnabled = true

	disableJumpButton()

	self:ConfigureButtons()

	if self.driverControlsEnabled then
		self:DisplayTouchDriveControls()
	end
end

function VehicleGui:DisableTouchControls()
	if not self.touchEnabled  then return end
	self.touchEnabled = false

	enableJumpButton()

	self.brakeButton.Visible = false
	self.accelButton.Visible = false
end

function VehicleGui:EnableKeyboardUI()
	self.speedoFrame.Size = UDim2.new(0, 400, 0, 90)
	self.speedoOn.Size = self.speedoFrame.Size
	self.speedoOff.Size = self.speedoFrame.Size
	self.speedoFrame.Position = UDim2.new(0.5, 0, 1, -40)
	self.speedoOn.Image = "rbxassetid://2848312414"
	self.speedoOff.Image = "rbxassetid://2848312878"
	self.speedText.TextSize = 40
	self.speedText.Size = UDim2.new(0, 60, 0, 40)
	self.speedText.Position = UDim2.new(0, 215, 0, 94)
	self.unitText.TextSize = 20
	self.unitText.Size = UDim2.new(0, 30, 0, 20)
	self.unitText.Position = UDim2.new(0, 225, 0, 90)

	self:DisableTouchControls()
end

function VehicleGui:EnableTouchUI()
	self.speedoFrame.Size = UDim2.new(0, 240, 0, 54)
	self.speedoOn.Size = self.speedoFrame.Size
	self.speedoOff.Size = self.speedoFrame.Size
	self.speedoFrame.Position = UDim2.new(0.5, 0, 1, -20)
	self.speedoOn.Image = "rbxassetid://2847843718"
	self.speedoOff.Image = "rbxassetid://2847843839"
	self.speedText.TextSize = 24
	self.speedText.Size = UDim2.new(0, 24*3*0.5, 0, 24)
	self.speedText.Position = UDim2.new(0, 120, 0, 54)
	self.unitText.TextSize = 12
	self.unitText.Size = UDim2.new(0, 12*3*0.5, 0, 12)
	self.unitText.Position = UDim2.new(0, 125, 0, 54)

	self:EnableTouchControls()
end

function VehicleGui:EnableGamepadUI()
	self.speedoFrame.Size = UDim2.new(0, 600, 0, 135)
	self.speedoOn.Size = self.speedoFrame.Size
	self.speedoOff.Size = self.speedoFrame.Size
	self.speedoFrame.Position = UDim2.new(0.5, 0, 1, -40)
	self.speedoOn.Image = "rbxassetid://2836208803"
	self.speedoOff.Image = "rbxassetid://2836208488"
	self.speedText.TextSize = 60
	self.speedText.Size = UDim2.new(0, 90, 0, 60)
	self.speedText.Position = UDim2.new(0, 315, 0, 140)
	self.unitText.TextSize = 30
	self.unitText.Size = UDim2.new(0, 45, 0, 30)
	self.unitText.Position = UDim2.new(0, 325, 0, 135)

	self:DisableTouchControls()
end

return VehicleGui
]]></string>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="108">
            <Properties>
              <string name="Name">LocalVehiclePromptGui</string>
              <string name="Source"><![CDATA[local ProximityPromptService = game:GetService("ProximityPromptService")
local screenGui = script.Parent
local CarValue = script:WaitForChild("CarValue")
local Car = CarValue.Value
local Keymap = require(Car.Scripts.Keymap)
local InputImageLibrary = require(Car.Scripts.InputImageLibrary)

local MIN_FLIP_ANGLE = 70 --degrees from vertical

--Tell if a seat is flipped
local function isFlipped(Seat)
	local UpVector = Seat.CFrame.upVector
	local Angle = math.deg(math.acos(UpVector:Dot(Vector3.new(0, 1, 0))))
	return Angle >= MIN_FLIP_ANGLE
end

local function createPrompt(prompt, inputType)
	local seat = prompt.Parent.Parent
	local buttonGui = script:WaitForChild("ButtonGuiPrototype")
	local promptUI = buttonGui:Clone()
	promptUI.Name = "ButtonGui"
	promptUI.Enabled = true
	promptUI.Adornee = prompt.Parent
	
	
	local EnterImageButton = promptUI:WaitForChild("ButtonImage")
	local FlipImageButton = promptUI:WaitForChild("FlipImage")
	local BackgroundDesktop = promptUI:WaitForChild("BackgroundDesktop")
	local BackgroundConsole = promptUI:WaitForChild("BackgroundConsole")
	local ButtonPrompt = promptUI:WaitForChild("ButtonPrompt")

	--Switch button type
	local DriverButtonId
	local DriverButtonPressedId
	local PassengerButtonId
	local PassengerButtonPressedId
	if inputType == Enum.ProximityPromptInputType.Keyboard then
		DriverButtonId = "rbxassetid://2848250902"
		DriverButtonPressedId = "rbxassetid://2848250902"
		PassengerButtonId = "rbxassetid://2848251564"
		PassengerButtonPressedId = "rbxassetid://2848251564"
		EnterImageButton.Size = UDim2.new(0, 36, 0, 36)
		FlipImageButton.Image = "rbxassetid://2848307983"
		FlipImageButton:WaitForChild("Pressed").Image = "rbxassetid://2848307983"
		FlipImageButton.Size = UDim2.new(0, 44, 0, 44)

		BackgroundConsole.Visible = false
		BackgroundDesktop.Visible = true
		BackgroundDesktop.Size =  UDim2.new(0, 97, 0, 46)
		BackgroundDesktop.Position = UDim2.new(0.5, 28, 0.5, 0)

		ButtonPrompt.Visible = true
		ButtonPrompt.Image = "rbxassetid://2935912536"
		ButtonPrompt.Size = UDim2.new(0, 36, 0, 36)
		ButtonPrompt.Position = UDim2.new(0.5, -46, 0.5, 0)
		ButtonPrompt.TextLabel.Visible = true

		--Display the correct key
		ButtonPrompt.TextLabel.Text = Keymap.EnterVehicleKeyboard.Name

	elseif inputType == Enum.ProximityPromptInputType.Gamepad then
		DriverButtonId = "rbxassetid://2848635029"
		DriverButtonPressedId = "rbxassetid://2848635029"
		PassengerButtonId = "rbxassetid://2848636545"
		PassengerButtonPressedId = "rbxassetid://2848636545"
		EnterImageButton.Size = UDim2.new(0, 60, 0, 60)
		FlipImageButton.Image = "rbxassetid://2848307983"
		FlipImageButton:WaitForChild("Pressed").Image = "rbxassetid://2848307983"
		FlipImageButton.Size = UDim2.new(0, 44, 0, 44)

		BackgroundDesktop.Visible = false
		BackgroundConsole.Visible = true
		BackgroundConsole.Size =  UDim2.new(0, 136, 0, 66)
		BackgroundConsole.Position = UDim2.new(0.5, 40, 0.5, 0)

		ButtonPrompt.Visible = true
		--ButtonPrompt.Image = "rbxassetid://408462759"
		ButtonPrompt.Size = UDim2.new(0, 46, 0, 46)
		ButtonPrompt.Position = UDim2.new(0.5, -63, 0.5, 0)
		ButtonPrompt.ImageRectSize = Vector2.new(71, 71)
		ButtonPrompt.ImageRectOffset = Vector2.new(512, 600)
		ButtonPrompt.TextLabel.Visible = false

		--Set the correct image for the gamepad button prompt
		local template = InputImageLibrary:GetImageLabel(Keymap.EnterVehicleGamepad, "Light")
		ButtonPrompt.Image = template.Image
		ButtonPrompt.ImageRectOffset = template.ImageRectOffset
		ButtonPrompt.ImageRectSize = template.ImageRectSize
	elseif inputType == Enum.ProximityPromptInputType.Touch then
		BackgroundDesktop.Visible = false
		BackgroundConsole.Visible = false
		ButtonPrompt.Visible = false

		DriverButtonId = "rbxassetid://2847898200"
		DriverButtonPressedId = "rbxassetid://2847898354"
		PassengerButtonId = "rbxassetid://2848217831"
		PassengerButtonPressedId = "rbxassetid://2848218107"
		EnterImageButton.Size = UDim2.new(0, 44, 0, 44)
		FlipImageButton.Image = "rbxassetid://2848187559"
		FlipImageButton:WaitForChild("Pressed").Image = "rbxassetid://2848187982"
		FlipImageButton.Size = UDim2.new(0, 44, 0, 44)
		
		EnterImageButton.InputBegan:Connect(function(input)
			prompt:InputHoldBegin()
		end)
		EnterImageButton.InputEnded:Connect(function(input)
			prompt:InputHoldEnd()
		end)
		FlipImageButton.InputBegan:Connect(function(input)
			prompt:InputHoldBegin()
		end)
		FlipImageButton.InputEnded:Connect(function(input)
			prompt:InputHoldEnd()
		end)

		promptUI.Active = true
	end
	
	if isFlipped(seat) then
		FlipImageButton.Visible = true
		EnterImageButton.Visible = false
	else
		FlipImageButton.Visible = false
		EnterImageButton.Visible = true
	end
	if seat.Name == "VehicleSeat" then
		EnterImageButton.Image = DriverButtonId
		EnterImageButton.Pressed.Image = DriverButtonPressedId
	else
		EnterImageButton.Image = PassengerButtonId
		EnterImageButton.Pressed.Image = PassengerButtonPressedId
	end

	return promptUI
end

ProximityPromptService.PromptShown:Connect(function(prompt, inputType)
	if prompt.Name == "EndorsedVehicleProximityPromptV1" then
		local promptUI = createPrompt(prompt, inputType)
		promptUI.Parent = screenGui
		prompt.PromptHidden:Wait()
		promptUI.Parent = nil
	end
end)
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="109">
            <Properties>
              <string name="Name">LocalVehicleSeating</string>
              <string name="Source"><![CDATA[local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local CollectionService = game:GetService("CollectionService")

local SEATING_ACTION_NAME = "VehicleChassisSeating"

local LocalPlayer = Players.LocalPlayer

local module = {}
module.OnExitFunctions = {}

local vehicle = script.Parent.Parent
local animationFolder = vehicle:WaitForChild("Animations")

local Remotes = vehicle.Remotes
	local ExitSeat = Remotes:WaitForChild("ExitSeat")

--Variables

local currentHumanoid = nil
local AnimationTracks = {}


local function getLocalHumanoid()
	if LocalPlayer.Character then
		return LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	end
end

--[[ todo: player animations when entering vehicle
--Get in a seat
local function enterStart()
	--Wait until player lets go of button (causing them to get in) or seat out of range (nothing happens)
	while EnterKeyDown and AdornedSeat do
		wait()
	end

	if AdornedSeat then
		--Tell server we are getting in seat
		Remotes.GetInSeat:FireServer(AdornedSeat)
		local n = 0
		repeat
			wait()
			n = n + 1
		until AdornedSeat == nil or n>20
		EnterImageButton.Visible = true
		
		local hum = getLocalHumanoid()
		if hum then
			if hum.Sit then
				-- load animations only when player is in the vehicle
				local hum = getLocalHumanoid()
				if hum ~= currentHumanoid then -- load only when we have a new humanoid
					currentHumanoid = hum
					local anims = animationFolder:GetChildren()
					for i = 1, #anims do
						AnimationTracks[anims[i].Name] = hum:LoadAnimation(anims[i])
					end
				end
				
				-- play seated animation
				local seat = hum.SeatPart
				local prefix = (seat.ClassName == "VehicleSeat" and "Driver" or "Passenger")
				local preferredAnimation = AnimationTracks[prefix.."_Seated"]
				if preferredAnimation then
					preferredAnimation.Priority = Enum.AnimationPriority.Action
					preferredAnimation:Play()
				end
			end
		end
	end
end
]]--

---Exit function
function module.ExitSeat()
	local humanoid = getLocalHumanoid()
	if not humanoid then
		return false
	end
	local character = humanoid.Parent
	if character.Humanoid.Sit == true then
		for _, joint in ipairs(character.HumanoidRootPart:GetJoints()) do
			if joint.Name == "SeatWeld" then
				local promptLocation = joint.Part0:FindFirstChild("PromptLocation")
				if promptLocation then
					local proximityPrompt = promptLocation:FindFirstChildWhichIsA("ProximityPrompt")
					if proximityPrompt and proximityPrompt.Name == "EndorsedVehicleProximityPromptV1" then
						for _, func in pairs(module.OnExitFunctions) do
							func(joint.Part0)
						end
						ExitSeat:FireServer()
						-- stop playing animations

						for name, track in pairs(AnimationTracks) do
							track:Stop()
						end

						return true
					end
				end
			end
		end
	end
end

--Connect functions to seat exit
function module.OnSeatExitEvent(func)
	table.insert(module.OnExitFunctions, func)
end

function module.DisconnectFromSeatExitEvent(func)
	local newExitFunctions = {}
	for _, v  in ipairs(module.OnExitFunctions) do
		if v ~= func then
			table.insert(newExitFunctions, v)
		end
	end
	module.OnExitFunctions = newExitFunctions
end


--The server will fire the ExitSeat remote to the client when the humanoid has been removed from a seat.
--This script listens to that and uses it to prevent the humanoid tripping when exiting a seat.
--As the player is removed from the seat server side, this scripts listens to the event instead of being
-- inside the ExitSeat function so that:
-- A) The timing is right - the exit seat function will run before the character is unsat by the server
-- B) If a server script removes the player from a seat, the anti-trip will still run
local function antiTrip()
	local humanoid = getLocalHumanoid()
	if humanoid then
		humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
	end
end
Remotes.ExitSeat.OnClientEvent:Connect(function(doAntiTrip)
	for _, func in pairs(module.OnExitFunctions) do
		func(nil)
	end
	if doAntiTrip then
		antiTrip()
	end
end)

return module
]]></string>
            </Properties>
          </Item>
          <Item class="LocalScript" referent="110">
            <Properties>
              <string name="Name">Passenger</string>
              <string name="Source"><![CDATA[local ContextActionService = game:GetService("ContextActionService")
local ProximityPromptService = game:GetService("ProximityPromptService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer

local EXIT_ACTION_NAME = "VehicleChassisExitVehiclePassenger"

local CarValue = script:WaitForChild("CarValue")
local Car = CarValue.Value

local LocalVehicleSeating = require(Car.Scripts.LocalVehicleSeating)
local Keymap = require(Car.Scripts.Keymap)

local VehicleGui = require(script.Parent:WaitForChild("LocalVehicleGui")).new(Car)
VehicleGui:Enable()

local function getLocalHumanoid()
	if LocalPlayer.Character then
		return LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	end
end

local function exitVehicle(action, inputState, inputObj)
	if inputState ~= Enum.UserInputState.Begin then
		return Enum.ContextActionResult.Pass
	end
	if script:IsDescendantOf(game) then
		LocalVehicleSeating.ExitSeat()
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end

local function onExitSeat(Seat)
	ContextActionService:UnbindAction(EXIT_ACTION_NAME)
	local humanoid = getLocalHumanoid()
	if humanoid then
		Workspace.CurrentCamera.CameraSubject = humanoid
	end
	ProximityPromptService.Enabled = true
	LocalVehicleSeating.DisconnectFromSeatExitEvent(onExitSeat)
	script.Disabled = true
end
LocalVehicleSeating.OnSeatExitEvent(onExitSeat)

ContextActionService:BindAction(
	EXIT_ACTION_NAME,
	exitVehicle,
	false,
	Keymap.EnterVehicleGamepad,
	Keymap.EnterVehicleKeyboard,
	Enum.KeyCode.ButtonA,
	Enum.KeyCode.Space
)

-- This has to be done so that camera occlusion ignores the vehcile.
local function updateCameraSubject()
	local humanoid = getLocalHumanoid()
	if humanoid and humanoid.SeatPart then
		--Workspace.CurrentCamera.CameraSubject = humanoid.SeatPart	
	end
end
updateCameraSubject()
ProximityPromptService.Enabled = false
]]></string>
            </Properties>
          </Item>
          <Item class="Script" referent="111">
            <Properties>
              <string name="Name">Vehicle</string>
              <string name="Source"><![CDATA[local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")

local Scripts = script.Parent
local TopModel = Scripts.Parent

local UniqueName = TopModel.Name.. "_" ..HttpService:GenerateGUID()

local ChassisModel = TopModel.Chassis
local EffectsFolder = TopModel.Effects

local Effects = require(Scripts.Effects)
local Chassis = require(Scripts.Chassis)
local VehicleSeating = require(Scripts.VehicleSeating)
local RemotesFolder = TopModel.Remotes
local BindableEventsFolder = TopModel.BindableEvents


-- LocalScripts that are cloned and deployed
local DriverScriptPrototype = Scripts.Driver
local PassengerScriptPrototype = Scripts.Passenger
local LocalGuiModulePrototype = Scripts.LocalVehicleGui

-- Note that this has not been refactored into a class yet
Chassis.InitializeDrivingValues()

-- This module is a class with a new() constructor function
local EffectsInstance = Effects.new(ChassisModel, EffectsFolder, TopModel)

VehicleSeating.SetRemotesFolder(RemotesFolder)
VehicleSeating.SetBindableEventsFolder(BindableEventsFolder)

local CharacterRemovingConnection = nil

local DriverSeat = Chassis.GetDriverSeat()
local AdditionalSeats = Chassis.GetPassengerSeats()

local LEG_PARTS_TO_REMOVE = {"RightFoot", "RightLowerLeg", "LeftFoot", "LeftLowerLeg"}
local ATTACHMENTS_TO_REMOVE = {"BodyBackAttachment", "WaistBackAttachment", "HatAttachment"}

local function setHatsAndLegsTransparency(obj, transparency)
	if obj:IsA("Humanoid") then
		obj = obj.Parent
	elseif obj:IsA("Player") then
		obj = obj.Character
	end

	for _, child in ipairs(obj:GetChildren()) do
		if child:IsA("Accoutrement") then
			local handle = child:FindFirstChild("Handle")
			if handle then
				local shouldRemove = false
				for _, attachmentName in ipairs(ATTACHMENTS_TO_REMOVE) do
					if handle:FindFirstChild(attachmentName) then
						shouldRemove = true
					end
				end

				if shouldRemove then
					handle.Transparency = transparency
				end
			end
		end
	end

	for _, legName in ipairs(LEG_PARTS_TO_REMOVE) do
		local legPart = obj:FindFirstChild(legName)
		if legPart then
			legPart.Transparency = transparency
		end
	end
end

local function onExitSeat(obj, seat)
	if obj:IsA("Player") then
		RemotesFolder.ExitSeat:FireClient(obj, false)

		local playerGui = obj:FindFirstChildOfClass("PlayerGui")
		if playerGui then
			local scriptContainer = playerGui:FindFirstChild(UniqueName .. "_ClientControls")
			if scriptContainer then
				scriptContainer:Destroy()
			end
		end
	end

	setHatsAndLegsTransparency(obj, 0)

	if obj:IsA("Humanoid") then
		obj.Sit = false
	end

	if CharacterRemovingConnection then
		CharacterRemovingConnection:Disconnect()
		CharacterRemovingConnection = nil
	end

	if seat == DriverSeat then
		DriverSeat:SetNetworkOwnershipAuto()
		Chassis.Reset()
		EffectsInstance:Disable()
	end
end

local function onEnterSeat(obj, seat)
	if seat and seat.Occupant then
		local ShouldTakeOffHats = true
		local prop = TopModel:GetAttribute("TakeOffAccessories")

		if prop ~= nil then
			ShouldTakeOffHats = prop
		end

		if ShouldTakeOffHats then
			setHatsAndLegsTransparency(seat.Occupant, 1)
		end
	end

	if not obj:IsA("Player") then
		return
	end

	local playerGui = obj:FindFirstChildOfClass("PlayerGui")
	if playerGui then
		local screenGui = Instance.new("ScreenGui")
		screenGui.Name = UniqueName .. "_ClientControls"
		screenGui.ResetOnSpawn = true
		screenGui.Parent = playerGui

		CharacterRemovingConnection = obj.CharacterRemoving:Connect(function()
			onExitSeat(obj)
		end)

		local localGuiModule = LocalGuiModulePrototype:Clone()
		localGuiModule.Parent = screenGui

		if seat == DriverSeat then
			local driverScript = DriverScriptPrototype:Clone()
			driverScript.CarValue.Value = TopModel
			driverScript.Parent = screenGui
			driverScript.Disabled = false

			DriverSeat:SetNetworkOwner(obj)
			EffectsInstance:Enable()
		else
			local passengerScript = PassengerScriptPrototype:Clone()
			passengerScript.CarValue.Value = TopModel
			passengerScript.Parent = screenGui
			passengerScript.Disabled = false
		end

		local scriptsReference = Instance.new("ObjectValue")
		scriptsReference.Name = "ScriptsReference"
		scriptsReference.Value = Scripts
		scriptsReference.Parent = screenGui
	end
end

--Listen to seat enter/exit
VehicleSeating.AddSeat(DriverSeat, onEnterSeat, onExitSeat)

for _, seat in ipairs(AdditionalSeats) do
	VehicleSeating.AddSeat(seat, onEnterSeat, onExitSeat)
end

local function playerAdded(player)
	local playerGui = player:WaitForChild("PlayerGui")

	if not playerGui:FindFirstChild("VehiclePromptScreenGui") then
		local screenGui = Instance.new("ScreenGui")
		screenGui.ResetOnSpawn = false
		screenGui.Name = "VehiclePromptScreenGui"
		screenGui.Parent = playerGui

		local newLocalVehiclePromptGui = Scripts.LocalVehiclePromptGui:Clone()
		newLocalVehiclePromptGui.CarValue.Value = TopModel
		newLocalVehiclePromptGui.Parent = screenGui
	end
end

Players.PlayerAdded:Connect(playerAdded)

for _, player in ipairs(Players:GetPlayers()) do
	playerAdded(player)
end
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="112">
            <Properties>
              <string name="Name">VehicleSeating</string>
              <string name="Source"><![CDATA[--This is the server sided module for handling this vehicles seating requests
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")

local DOOR_OPEN_SPEED = 2.15
local DOOR_OPEN_ANGLE = 55
local DOOR_OPEN_TIME = 0.5 --How long the door stays open for when entering/leaving

local MAX_SEATING_DISTANCE = 15
local MIN_FLIP_ANGLE = 70 --degrees from vertical

local PackagedScripts = script.Parent
local PackagedVehicle = PackagedScripts.Parent

local RemotesFolder = nil --Set later in the code by the SetRemotesFolder function
	
--Variables
local SeatInteractionCount = {}

local VehicleSeating = {}

local function getVehicleObject()
	return script.Parent.Parent
end

local function carjackingEnabled(obj)
	return obj:GetAttribute("AllowCarjacking")
end

local function getEffectsFolderFromSeat(seat)
	local parent = seat.Parent
	if parent:IsA("Model") then
		if parent:FindFirstChild("Effects") then
			return parent.Effects
		else
			return getEffectsFolderFromSeat(parent)
		end
	end
	return nil
end

local function playDoorSound(seat, sound)
	local sound = seat:FindFirstChild(sound.."Door")
	if sound then
		sound:Play()
	end
end

--Tell if a seat is flipped
local function isFlipped(Seat)
	local UpVector = Seat.CFrame.upVector
	local Angle = math.deg(math.acos(UpVector:Dot(Vector3.new(0, 1, 0))))
	return Angle >= MIN_FLIP_ANGLE
end

local function Raycast(startPos, direction, range, ignore, inceptNumber)
	if inceptNumber == nil then inceptNumber = 0 end
	inceptNumber = inceptNumber + 1
	local ray = Ray.new(startPos, direction * range)
	local part, position = Workspace:FindPartOnRayWithIgnoreList(ray, ignore)
	if part then
		if part.CanCollide == false and inceptNumber <= 5 then
			--raycast again if we hit a cancollide false brick, put a limit on to prevent an infinite loop
			local rangeLeft = range - (startPos - position).magnitude
			part, position = Raycast(position, direction, rangeLeft, ignore, inceptNumber) --Raycast remaining distance.
		end
	end
	return part, position
end

local function ExitSeat(player, character, seat, weld)
	local hrp = character:FindFirstChild("HumanoidRootPart")
	if hrp then
		weld:Destroy()

		if seat:FindFirstChild("DoorHinge") then
			seat.DoorLatchWeld.Enabled = false
			seat.DoorHinge.TargetAngle = DOOR_OPEN_ANGLE
			playDoorSound(seat, "OpenClose")
		end
		--Record the interaction
		SeatInteractionCount[seat] = SeatInteractionCount[seat] and SeatInteractionCount[seat] + 1 or 1

		wait()
		if seat:FindFirstChild("ExitPosition") then --Check if we can move the character to the designated pos.
			--Find vehicle model
			local model
			local newParent = seat
			repeat
				model = newParent
				newParent = model.Parent
			until newParent.ClassName ~= "Model"

			local targetPos = seat.ExitPosition.WorldPosition
			local delta = targetPos - seat.Position
			local dist = delta.magnitude
			local dir = delta.unit
			local part, _ = Raycast(seat.Position, dir, dist, {character, model})

			if not part then --Prevent people being CFramed into walls and stuff
				hrp.CFrame = CFrame.new(targetPos)
			else
				hrp.CFrame = CFrame.new(seat.Position)
				--The CFrame element orients the character up-right, the MoveTo stops the character from clipping into objects
				character:MoveTo(seat.Position+Vector3.new(0,8,0))
			end
		else
			hrp.CFrame = CFrame.new(seat.Position)
			character:MoveTo(seat.Position+Vector3.new(0,8,0))
		end

		if player then
			RemotesFolder.ExitSeat:FireClient(player, true) --Fire this to trigger the client-side anti-trip function
		end

		wait(DOOR_OPEN_TIME)

		SeatInteractionCount[seat] = SeatInteractionCount[seat] > 1 and SeatInteractionCount[seat] - 1 or nil
		if seat:FindFirstChild("DoorHinge") then
			--If nobody else has interactied in this time, close the door.
			if SeatInteractionCount[seat] == nil then
				seat.DoorHinge.TargetAngle = 0
				-- Weld door shut when closed
				while math.abs(seat.DoorHinge.CurrentAngle) > 0.01 do
					wait()
				end
				seat.DoorLatchWeld.Enabled = true
			end
		end
	end
end

local function FlipSeat(Player, Seat)
	if Seat then
		if Seat.Parent then
			if not Seat.Parent.Parent:FindFirstChild("Scripts") then
				warn("Flip Error: Scripts file not found. Please parent seats to the chassis model")
				return
			end
			if not Seat.Parent.Parent.Scripts:FindFirstChild("Chassis") then
				warn("Flip Error: Chassis module not found.")
				return
			end
			local Chassis = require(Seat.Parent.Parent.Scripts.Chassis)
			Chassis.Redress()
		end
	end
end

function VehicleSeating.EjectCharacter(character)
	if character and character.HumanoidRootPart then
		for _, weld in pairs(character.HumanoidRootPart:GetJoints()) do
			if weld.Name == "SeatWeld" then
				ExitSeat(Players:GetPlayerFromCharacter(character), character, weld.Part0, weld)
				break
			end
		end
	end
end

function VehicleSeating.SetRemotesFolder(remotes)
	RemotesFolder = remotes

	--Detect exit seat requests
	RemotesFolder:FindFirstChild("ExitSeat").OnServerEvent:Connect(function(player)
		if player.Character then
			local character = player.Character
			VehicleSeating.EjectCharacter(character)
		end
	end)

	--Detect force exit seat requests
	RemotesFolder:FindFirstChild("ForceExitSeat").OnServerEvent:Connect(function(seatName)
		local chassis = PackagedVehicle:FindFirstChild("Chassis")
		if chassis then
			local seat = chassis:FindFirstChild(seatName)
			if seat and seat.Occupant then
				local occupantCharacter = seat.Occupant.Parent
				VehicleSeating.EjectCharacter(occupantCharacter)
			end
		end
	end)
end

function VehicleSeating.SetBindableEventsFolder(bindables)
	local BindableEventsFolder = bindables

	--Detect force exit seat requests
	BindableEventsFolder:FindFirstChild("ForceExitSeat").Event:Connect(function(seatName)
		local chassis = PackagedVehicle:FindFirstChild("Chassis")
		if chassis then
			local seat = chassis:FindFirstChild(seatName)
			if seat and seat.Occupant then
				local occupantCharacter = seat.Occupant.Parent
				VehicleSeating.EjectCharacter(occupantCharacter)
			end
		end
	end)
end

function VehicleSeating.AddSeat(seat, enterCallback, exitCallback)
	local promptLocation = seat:FindFirstChild("PromptLocation")
	if promptLocation then
		local proximityPrompt = promptLocation:FindFirstChildWhichIsA("ProximityPrompt")
		if proximityPrompt then
			local vehicleObj = getVehicleObject()

			local function setCarjackPrompt()
				if seat.Occupant and not carjackingEnabled(vehicleObj) then
					proximityPrompt.Enabled = false
				else
					proximityPrompt.Enabled = true
				end
			end

			seat:GetPropertyChangedSignal("Occupant"):connect(setCarjackPrompt)
			vehicleObj:GetAttributeChangedSignal("AllowCarjacking"):Connect(setCarjackPrompt)

			proximityPrompt.Triggered:connect(function(Player)
				if seat then
					if isFlipped(seat) then
						FlipSeat(Player, seat)

					elseif not seat:FindFirstChild("SeatWeld") or carjackingEnabled(vehicleObj) then
						if Player.Character ~= nil then
							local HRP = Player.Character:FindFirstChild("HumanoidRootPart")
							local humanoid = Player.Character:FindFirstChild("Humanoid")

							if HRP then
								local Dist = (HRP.Position - seat.Position).magnitude
								if Dist <= MAX_SEATING_DISTANCE then
									if seat.Occupant then
										local occupantCharacter = seat.Occupant.Parent
										for _, weld in pairs(occupantCharacter.HumanoidRootPart:GetJoints()) do
											if weld.Name == "SeatWeld" then
												ExitSeat(Players:GetPlayerFromCharacter(occupantCharacter), occupantCharacter, weld.Part0, weld)
												break
											end
										end
									end
									seat:Sit(humanoid)
									
									if seat:FindFirstChild("DoorHinge") then
										if seat.DoorHinge.ClassName ~= "HingeConstraint" then warn("Warning, door hinge is not actually a hinge!") end

										--Record that a player is trying to get in the seat
										SeatInteractionCount[seat] = SeatInteractionCount[seat] and SeatInteractionCount[seat] + 1 or 1

										--Activate the hinge
										seat.DoorLatchWeld.Enabled = false
										seat.DoorHinge.TargetAngle = DOOR_OPEN_ANGLE
										seat.DoorHinge.AngularSpeed = DOOR_OPEN_SPEED

										playDoorSound(seat, "OpenClose")

										wait(DOOR_OPEN_TIME)

										--Check if anyone has interacted with the door within this time. If not, close it.
										SeatInteractionCount[seat] = SeatInteractionCount[seat] > 1 and SeatInteractionCount[seat] - 1 or nil
										if SeatInteractionCount[seat] == nil then
											seat.DoorHinge.TargetAngle = 0
											-- Weld door shut when closed
											while math.abs(seat.DoorHinge.CurrentAngle) > 0.01 do
												wait()
											end
											seat.DoorLatchWeld.Enabled = true
										end
									end
								end
							end
						end
					end
				end
			end)
		end
	end

	local effectsFolder = getEffectsFolderFromSeat(seat)
	if effectsFolder then
		-- set open/close Sound
		local openclose = effectsFolder:FindFirstChild("OpenCloseDoor")
		if openclose then
			openclose:Clone().Parent = seat
		end
	end

	local currentOccupant = nil
	local occupantChangedConn = seat:GetPropertyChangedSignal("Occupant"):Connect(function()
		if seat.Occupant then
			if enterCallback then
				currentOccupant = seat.Occupant
				currentOccupant = Players:GetPlayerFromCharacter(currentOccupant.Parent) or currentOccupant
				enterCallback(currentOccupant, seat)
			end
		elseif exitCallback then
			exitCallback(currentOccupant, seat)
			currentOccupant = nil
		end
	end)

	--Clean up after the seat is destroyed
	seat.AncestryChanged:connect(function()
		if not seat:IsDescendantOf(game) then
			occupantChangedConn:Disconnect()
		end
	end)
end

return VehicleSeating
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>